package com.android.server.devicepolicy;

import android.R;
import android.accessibilityservice.AccessibilityServiceInfo;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AuthenticatorException;
import android.accounts.OperationCanceledException;
import android.app.ActivityManager;
import android.app.ActivityManagerInternal;
import android.app.AlarmManager;
import android.app.AppGlobals;
import android.app.AppOpsManager;
import android.app.BroadcastOptions;
import android.app.IApplicationThread;
import android.app.IServiceConnection;
import android.app.IStopUserCallback;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.admin.AccountTypePolicyKey;
import android.app.admin.BooleanPolicyValue;
import android.app.admin.BundlePolicyValue;
import android.app.admin.ComponentNamePolicyValue;
import android.app.admin.DeviceAdminAuthority;
import android.app.admin.DeviceAdminInfo;
import android.app.admin.DevicePolicyCache;
import android.app.admin.DevicePolicyEventLogger;
import android.app.admin.DevicePolicyManager;
import android.app.admin.DevicePolicyManagerInternal;
import android.app.admin.DevicePolicyManagerLiteInternal;
import android.app.admin.DevicePolicySafetyChecker;
import android.app.admin.DevicePolicyState;
import android.app.admin.DeviceStateCache;
import android.app.admin.DpcAuthority;
import android.app.admin.FactoryResetProtectionPolicy;
import android.app.admin.FullyManagedDeviceProvisioningParams;
import android.app.admin.IAuditLogEventsCallback;
import android.app.admin.IDevicePolicyManager;
import android.app.admin.IntegerPolicyValue;
import android.app.admin.IntentFilterPolicyKey;
import android.app.admin.LockTaskPolicy;
import android.app.admin.ManagedSubscriptionsPolicy;
import android.app.admin.PackagePolicy;
import android.app.admin.PackagePolicyKey;
import android.app.admin.PackageSetPolicyValue;
import android.app.admin.ParcelableGranteeMap;
import android.app.admin.ParcelableResource;
import android.app.admin.PasswordMetrics;
import android.app.admin.PasswordPolicy;
import android.app.admin.PolicyKey;
import android.app.admin.PolicySizeVerifier;
import android.app.admin.PolicyValue;
import android.app.admin.PreferentialNetworkServiceConfig;
import android.app.admin.RoleAuthority;
import android.app.admin.SecurityLog;
import android.app.admin.StartInstallingUpdateCallback;
import android.app.admin.SystemUpdateInfo;
import android.app.admin.SystemUpdatePolicy;
import android.app.admin.UnsafeStateException;
import android.app.admin.UserRestrictionPolicyKey;
import android.app.admin.WifiSsidPolicy;
import android.app.admin.flags.Flags;
import android.app.backup.IBackupManager;
import android.app.compat.CompatChanges;
import android.app.role.OnRoleHoldersChangedListener;
import android.app.role.RoleManager;
import android.app.usage.UsageStatsManagerInternal;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.IIntentReceiver;
import android.content.IIntentSender;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.IntentSender;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.CrossProfileApps;
import android.content.pm.CrossProfileAppsInternal;
import android.content.pm.IPackageDataObserver;
import android.content.pm.IPackageDeleteObserver;
import android.content.pm.IPackageManager;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManagerInternal;
import android.content.pm.ParceledListSlice;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.content.pm.StringParceledListSlice;
import android.content.pm.UserInfo;
import android.content.pm.UserPackage;
import android.content.pm.parsing.FrameworkParsingPackageUtils;
import android.database.ContentObserver;
import android.database.Cursor;
import android.frameworks.vibrator.VibrationParam$1$$ExternalSyntheticOutline0;
import android.graphics.Bitmap;
import android.graphics.drawable.Icon;
import android.hardware.audio.common.V2_0.AudioChannelMask$$ExternalSyntheticOutline0;
import android.location.Location;
import android.location.LocationManager;
import android.media.AudioManager;
import android.net.ConnectivityModuleConnector$$ExternalSyntheticOutline0;
import android.net.ConnectivitySettingsManager;
import android.net.ProfileNetworkPreference;
import android.net.ProxyInfo;
import android.net.Uri;
import android.net.VpnManager;
import android.net.util.NetdService$$ExternalSyntheticOutline0;
import android.os.AsyncTask;
import android.os.Binder;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.FileUtils;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.ParcelFileDescriptor;
import android.os.Parcelable;
import android.os.PersistableBundle;
import android.os.PowerManager;
import android.os.Process;
import android.os.RemoteCallback;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.ServiceManager;
import android.os.ServiceSpecificException;
import android.os.ShellCallback;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.os.UserHandle;
import android.os.UserManager;
import android.os.storage.StorageManager;
import android.permission.AdminPermissionControlParams;
import android.permission.IPermissionManager;
import android.permission.PermissionControllerManager;
import android.provider.ContactsContract;
import android.provider.DeviceConfig;
import android.provider.Settings;
import android.provider.Telephony;
import android.sec.enterprise.auditlog.AuditLog;
import android.security.AppUriAuthenticationPolicy;
import android.security.Credentials;
import android.security.IKeyChainAliasCallback;
import android.security.IKeyChainService;
import android.security.KeyChain;
import android.security.keymaster.KeymasterCertificateChain;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.ParcelableKeyGenParameterSpec;
import android.telecom.TelecomManager;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.telephony.data.ApnSetting;
import android.text.TextUtils;
import android.text.format.DateUtils;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.AtomicFile;
import android.util.DebugUtils;
import android.util.IndentingPrintWriter;
import android.util.IntArray;
import android.util.Log;
import android.util.Pair;
import android.util.Slog;
import android.util.SparseArray;
import android.util.Xml;
import android.view.IWindowManager;
import android.view.accessibility.AccessibilityManager;
import android.view.accessibility.IAccessibilityManager;
import android.view.inputmethod.InputMethodInfo;
import com.android.internal.infra.AndroidFuture;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.net.NetworkUtilsInternal;
import com.android.internal.notification.SystemNotificationChannels;
import com.android.internal.policy.IKeyguardDismissCallback;
import com.android.internal.statusbar.IStatusBarService;
import com.android.internal.telephony.SmsApplication;
import com.android.internal.util.ArrayUtils;
import com.android.internal.util.DumpUtils;
import com.android.internal.util.FrameworkStatsLog;
import com.android.internal.util.FunctionalUtils;
import com.android.internal.util.JournaledFile;
import com.android.internal.util.Preconditions;
import com.android.internal.util.StatLogger;
import com.android.internal.util.jobs.DumpUtils$$ExternalSyntheticOutline0;
import com.android.internal.util.jobs.XmlUtils$$ExternalSyntheticOutline0;
import com.android.internal.widget.LockPatternUtils;
import com.android.internal.widget.LockSettingsInternal;
import com.android.internal.widget.LockscreenCredential;
import com.android.modules.utils.TypedXmlPullParser;
import com.android.modules.utils.TypedXmlSerializer;
import com.android.server.BatteryService$$ExternalSyntheticOutline0;
import com.android.server.BinaryTransparencyService$$ExternalSyntheticOutline0;
import com.android.server.DirEncryptServiceHelper$$ExternalSyntheticOutline0;
import com.android.server.DualAppManagerService$$ExternalSyntheticOutline0;
import com.android.server.ExplicitHealthCheckController$$ExternalSyntheticOutline0;
import com.android.server.ExtendedEthernetServiceImpl$1$$ExternalSyntheticLambda1;
import com.android.server.LocalManagerRegistry;
import com.android.server.LocalServices;
import com.android.server.LockGuard;
import com.android.server.SystemServerInitThreadPool;
import com.android.server.SystemService;
import com.android.server.SystemServiceManager;
import com.android.server.SystemUpdateManagerService$$ExternalSyntheticOutline0;
import com.android.server.alarm.GmsAlarmManager$$ExternalSyntheticOutline0;
import com.android.server.ambientcontext.AmbientContextManagerPerUserService$$ExternalSyntheticOutline0;
import com.android.server.devicepolicy.ActiveAdmin;
import com.android.server.devicepolicy.DevicePolicyEngine;
import com.android.server.devicepolicy.DevicePolicyManagerService;
import com.android.server.devicepolicy.DualDarProvisioningHelper;
import com.android.server.devicepolicy.FactoryResetter;
import com.android.server.devicepolicy.OwnersData;
import com.android.server.devicepolicy.TransferOwnershipMetadataManager;
import com.android.server.inputmethod.InputMethodManagerInternal;
import com.android.server.knox.KnoxAnalyticsContainer;
import com.android.server.knox.dar.sdp.SDPLog;
import com.android.server.net.NetworkPolicyManagerService;
import com.android.server.pdb.PersistentDataBlockManagerInternal;
import com.android.server.pdb.PersistentDataBlockService;
import com.android.server.pm.DefaultCrossProfileIntentFilter;
import com.android.server.pm.DefaultCrossProfileIntentFiltersUtils;
import com.android.server.pm.PackageManagerLocal;
import com.android.server.pm.PackageManagerService;
import com.android.server.pm.PersonaManagerService;
import com.android.server.pm.RestrictionsSet;
import com.android.server.pm.UserManagerInternal;
import com.android.server.pm.UserRestrictionsUtils;
import com.android.server.pm.WatchedIntentFilter;
import com.android.server.pm.pkg.PackageState;
import com.android.server.uri.UriGrantsManagerInternal;
import com.android.server.uri.UriGrantsManagerService;
import com.android.server.usage.UsageStatsService;
import com.android.server.utils.Slogf;
import com.samsung.android.knox.ContextInfo;
import com.samsung.android.knox.EdmConstants;
import com.samsung.android.knox.EnterpriseDeviceManager;
import com.samsung.android.knox.EnterpriseKnoxManager;
import com.samsung.android.knox.SemPersonaManager;
import com.samsung.android.knox.analytics.activation.DevicePolicyListener;
import com.samsung.android.knox.container.KnoxContainerManager;
import com.samsung.android.knox.custom.KnoxCustomManagerService;
import com.samsung.android.knox.custom.utils.KnoxsdkFileLog;
import com.samsung.android.knox.dar.IDarManagerService;
import com.samsung.android.knox.dar.ddar.DualDarManager;
import com.samsung.android.knox.localservice.ApplicationRestrictionsInternal;
import com.samsung.android.knox.net.wifi.IWifiPolicy;
import com.samsung.android.knox.zt.devicetrust.EndpointMonitorConst;
import com.samsung.android.knoxguard.KnoxGuardManager;
import com.samsung.android.security.SemSdCardEncryption;
import com.samsung.android.security.mdf.MdfUtils;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.DateFormat;
import java.time.LocalDate;
import java.time.chrono.ChronoLocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.Executor;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.xmlpull.v1.XmlPullParserException;

/* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
/* loaded from: classes.dex */
public final class DevicePolicyManagerService extends IDevicePolicyManager.Stub {
    static final String ACTION_PROFILE_OFF_DEADLINE = "com.android.server.ACTION_PROFILE_OFF_DEADLINE";
    static final String ACTION_TURN_PROFILE_ON_NOTIFICATION = "com.android.server.ACTION_TURN_PROFILE_ON_NOTIFICATION";
    public static final List ADDITIONAL_AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS;
    public static final List ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS;
    public static final List ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS;
    public static final List ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS;
    public static final List AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS;
    public static final Map APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS;
    public static final HashMap CROSS_USER_PERMISSIONS;
    public static final Set DA_DISALLOWED_POLICIES;
    public static final List DEFAULT_DEVICE_OWNER_PERMISSIONS;
    public static final HashMap DELEGATE_SCOPES;
    public static final String[] DELEGATIONS;
    public static final List DEVICE_OWNER_OR_MANAGED_PROFILE_OWNER_DELEGATIONS;
    public static final List DEVICE_OWNER_OR_ORGANIZATION_OWNED_MANAGED_PROFILE_OWNER_DELEGATIONS;
    public static final HashMap DPC_PERMISSIONS;
    public static final List EXCLUSIVE_DELEGATIONS;
    public static final long EXPIRATION_GRACE_PERIOD_MS;
    public static final List FINANCED_DEVICE_OWNER_PERMISSIONS;
    public static final List FRP_PROTECTED_PACKAGES;
    public static final Set GLOBAL_SETTINGS_ALLOWLIST;
    public static final Set GLOBAL_SETTINGS_DEPRECATED;
    public static final long MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD;
    public static final long MANAGED_PROFILE_OFF_WARNING_PERIOD;
    public static final long MINIMUM_STRONG_AUTH_TIMEOUT_MS;
    public static final long MS_PER_DAY;
    public static final List PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS;
    public static final List PROFILE_OWNER_ON_USER_0_PERMISSIONS;
    public static final List PROFILE_OWNER_ON_USER_PERMISSIONS;
    public static final List PROFILE_OWNER_PERMISSIONS;
    public static final Set SECURE_SETTINGS_ALLOWLIST;
    public static final Set SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST;
    public static final List SENSOR_PERMISSIONS;
    public static final Set SYSTEM_SETTINGS_ALLOWLIST;
    public static final HashMap USER_RESTRICTION_PERMISSIONS;
    public final ThreadPoolExecutor calculateHasIncompatibleAccountsExecutor;
    public final AuditLogHelper mAuditLogHelper;
    public final Handler mBackgroundHandler;
    public final RemoteBugreportManager mBugreportCollectionManager;
    public final CertificateMonitor mCertificateMonitor;
    public DevicePolicyConstants mConstants;
    public final Set mContactSystemRoleHolders;
    public final Context mContext;
    public final DeviceAdminServiceController mDeviceAdminServiceController;
    public final DeviceManagementResourcesProvider mDeviceManagementResourcesProvider;
    public final DevicePolicyEngine mDevicePolicyEngine;
    public final DualDarProvisioningHelper mDualDarProvisioningHelper;
    public EnterpriseSpecificIdCalculator mEsidCalculator;
    public final Handler mHandler;
    public final boolean mHasFeature;
    public volatile Map mHasIncompatibleAccounts;
    public final boolean mHasTelephonyDataFeature;
    public final boolean mHasTelephonyFeature;
    public final IPackageManager mIPackageManager;
    public final IPermissionManager mIPermissionManager;
    public final Injector mInjector;
    public final boolean mIsAutomotive;
    public final boolean mIsWatch;
    public final KnoxAnalyticsHelper mKnoxAnalyticsHelper;
    public final KnoxPolicyHelper mKnoxPolicyHelper;
    public final LocalService mLocalService;
    public final LockPatternUtils mLockPatternUtils;
    public final LockSettingsInternal mLockSettingsInternal;
    public NetworkLogger mNetworkLogger;
    public final OverlayPackagesProvider mOverlayPackagesProvider;
    final Owners mOwners;
    public final PolicyPathProvider mPathProvider;
    public final AnonymousClass1 mReceiver;
    public final RoleManager mRoleManager;
    public DevicePolicySafetyChecker mSafetyChecker;
    public final SecurityLogMonitor mSecurityLogMonitor;
    public final SecurityPolicyHelper mSecurityPolicyHelper;
    public final SetupContentObserver mSetupContentObserver;
    public AnonymousClass8 mSubscriptionsChangedListener;
    public final TelephonyManager mTelephonyManager;
    final TransferOwnershipMetadataManager mTransferOwnershipMetadataManager;
    public final UCMProvisioningHelper mUCMProvisioningHelper;
    public final UsageStatsManagerInternal mUsageStatsManagerInternal;
    public final SparseArray mUserData;
    public final UserManager mUserManager;
    public final UserManagerInternal mUserManagerInternal;
    public final DevicePolicyCacheImpl mPolicyCache = new DevicePolicyCacheImpl();
    public final DeviceStateCacheImpl mStateCache = new DeviceStateCacheImpl();
    public final Object mESIDInitilizationLock = new Object();
    public final Object mSubscriptionsChangedListenerLock = new Object();
    public boolean mNotifyChanges = true;
    public boolean oldAllowWifi = true;
    public final Set mPackagesToRemove = new ArraySet();
    public final Binder mToken = new Binder();
    public int mLogoutUserId = -10000;
    public int mNetworkLoggingNotificationUserId = -10000;
    public final StatLogger mStatLogger = new StatLogger(new String[]{"LockGuard.guard()"});
    public final Object mLockDoNoUseDirectly = LockGuard.installNewLock(8, true);
    public final ArrayList mPendingUserCreatedCallbackTokens = new ArrayList();

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    /* renamed from: com.android.server.devicepolicy.DevicePolicyManagerService$1, reason: invalid class name */
    public final class AnonymousClass1 extends BroadcastReceiver {
        public final /* synthetic */ int $r8$classId;
        public final /* synthetic */ Object this$0;

        public /* synthetic */ AnonymousClass1(int i, Object obj) {
            this.$r8$classId = i;
            this.this$0 = obj;
        }

        @Override // android.content.BroadcastReceiver
        public final void onReceive(Context context, Intent intent) {
            switch (this.$r8$classId) {
                case 0:
                    String action = intent.getAction();
                    final int intExtra = intent.getIntExtra("android.intent.extra.user_handle", getSendingUserId());
                    if ("android.intent.action.USER_STARTED".equals(action) && intExtra == 0) {
                        synchronized (((DevicePolicyManagerService) this.this$0).getLockObject()) {
                            if (((DevicePolicyManagerService) this.this$0).isNetworkLoggingEnabledInternalLocked()) {
                                ((DevicePolicyManagerService) this.this$0).setNetworkLoggingActiveInternal(true);
                            }
                        }
                    }
                    if ("android.intent.action.BOOT_COMPLETED".equals(action)) {
                        ((DevicePolicyManagerService) this.this$0).calculateHasIncompatibleAccounts();
                    }
                    if ("android.intent.action.BOOT_COMPLETED".equals(action) && intExtra == ((DevicePolicyManagerService) this.this$0).mOwners.getDeviceOwnerUserId()) {
                        RemoteBugreportManager remoteBugreportManager = ((DevicePolicyManagerService) this.this$0).mBugreportCollectionManager;
                        if (remoteBugreportManager.mService.getDeviceOwnerRemoteBugreportUriAndHash() != null) {
                            remoteBugreportManager.mContext.registerReceiver(remoteBugreportManager.mRemoteBugreportConsentReceiver, DirEncryptServiceHelper$$ExternalSyntheticOutline0.m("com.android.server.action.REMOTE_BUGREPORT_SHARING_DECLINED", "com.android.server.action.REMOTE_BUGREPORT_SHARING_ACCEPTED"));
                            remoteBugreportManager.notify(3);
                        }
                    }
                    if ("android.intent.action.BOOT_COMPLETED".equals(action) || "com.android.server.ACTION_EXPIRED_PASSWORD_NOTIFICATION".equals(action)) {
                        ((DevicePolicyManagerService) this.this$0).mHandler.post(new Runnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService.1.1
                            @Override // java.lang.Runnable
                            public final void run() {
                                int i;
                                DevicePolicyManagerService devicePolicyManagerService = (DevicePolicyManagerService) AnonymousClass1.this.this$0;
                                int i2 = intExtra;
                                String[] strArr = DevicePolicyManagerService.DELEGATIONS;
                                devicePolicyManagerService.getClass();
                                Bundle bundle = new Bundle();
                                bundle.putParcelable("android.intent.extra.USER", UserHandle.of(i2));
                                synchronized (devicePolicyManagerService.getLockObject()) {
                                    try {
                                        long currentTimeMillis = System.currentTimeMillis();
                                        ArrayList arrayList = (ArrayList) devicePolicyManagerService.getActiveAdminsForLockscreenPoliciesLocked(i2);
                                        int size = arrayList.size();
                                        while (i < size) {
                                            ActiveAdmin activeAdmin = (ActiveAdmin) arrayList.get(i);
                                            i = (activeAdmin.isPermissionBased || activeAdmin.info.usesPolicy(6)) ? 0 : i + 1;
                                            if (activeAdmin.passwordExpirationTimeout > 0) {
                                                long j = activeAdmin.passwordExpirationDate;
                                                if (currentTimeMillis >= j - DevicePolicyManagerService.EXPIRATION_GRACE_PERIOD_MS && j > 0) {
                                                    devicePolicyManagerService.sendAdminCommandLocked(activeAdmin, "android.app.action.ACTION_PASSWORD_EXPIRING", bundle, null, false);
                                                    devicePolicyManagerService.mInjector.getClass();
                                                    devicePolicyManagerService.mKnoxPolicyHelper.handlePasswordExpirationNotification(i2, activeAdmin);
                                                }
                                            }
                                        }
                                        devicePolicyManagerService.setExpirationAlarmCheckLocked(devicePolicyManagerService.mContext, i2, false);
                                    } catch (Throwable th) {
                                        throw th;
                                    }
                                }
                            }
                        });
                    }
                    if ("android.intent.action.USER_ADDED".equals(action)) {
                        sendDeviceOwnerUserCommand(intExtra, "android.app.action.USER_ADDED");
                        synchronized (((DevicePolicyManagerService) this.this$0).getLockObject()) {
                            ((DevicePolicyManagerService) this.this$0).maybePauseDeviceWideLoggingLocked();
                        }
                        return;
                    }
                    if ("android.intent.action.USER_REMOVED".equals(action)) {
                        sendDeviceOwnerUserCommand(intExtra, "android.app.action.USER_REMOVED");
                        synchronized (((DevicePolicyManagerService) this.this$0).getLockObject()) {
                            try {
                                boolean isUserAffiliatedWithDeviceLocked = ((DevicePolicyManagerService) this.this$0).isUserAffiliatedWithDeviceLocked(intExtra);
                                ((DevicePolicyManagerService) this.this$0).removeUserData(intExtra);
                                if (!isUserAffiliatedWithDeviceLocked) {
                                    DevicePolicyManagerService.m419$$Nest$mdiscardDeviceWideLogsLocked((DevicePolicyManagerService) this.this$0);
                                    DevicePolicyManagerService devicePolicyManagerService = (DevicePolicyManagerService) this.this$0;
                                    boolean areAllUsersAffiliatedWithDeviceLocked = devicePolicyManagerService.areAllUsersAffiliatedWithDeviceLocked();
                                    boolean isOrganizationOwnedDeviceWithManagedProfile = devicePolicyManagerService.isOrganizationOwnedDeviceWithManagedProfile();
                                    Injector injector = devicePolicyManagerService.mInjector;
                                    DevicePolicyManagerService$$ExternalSyntheticLambda158 devicePolicyManagerService$$ExternalSyntheticLambda158 = new DevicePolicyManagerService$$ExternalSyntheticLambda158(devicePolicyManagerService, areAllUsersAffiliatedWithDeviceLocked, isOrganizationOwnedDeviceWithManagedProfile);
                                    injector.getClass();
                                    Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda158);
                                }
                            } finally {
                            }
                        }
                        ((DevicePolicyManagerService) this.this$0).mDevicePolicyEngine.handleUserRemoved(intExtra);
                        return;
                    }
                    if ("android.intent.action.USER_STARTED".equals(action)) {
                        sendDeviceOwnerUserCommand(intExtra, "android.app.action.USER_STARTED");
                        synchronized (((DevicePolicyManagerService) this.this$0).getLockObject()) {
                            DevicePolicyManagerService.m422$$Nest$mmaybeSendAdminEnabledBroadcastLocked((DevicePolicyManagerService) this.this$0, intExtra);
                            ((DevicePolicyManagerService) this.this$0).mUserData.remove(intExtra);
                        }
                        DevicePolicyManagerService.m421$$Nest$mhandlePackagesChanged(intExtra, (DevicePolicyManagerService) this.this$0, null);
                        DevicePolicyManagerService devicePolicyManagerService2 = (DevicePolicyManagerService) this.this$0;
                        int managedUserId = devicePolicyManagerService2.getManagedUserId(intExtra);
                        if (managedUserId >= 0) {
                            devicePolicyManagerService2.updatePersonalAppsSuspension(managedUserId);
                            return;
                        } else {
                            devicePolicyManagerService2.suspendPersonalAppsInternal(intExtra, managedUserId, false);
                            return;
                        }
                    }
                    if ("android.intent.action.USER_STOPPED".equals(action)) {
                        sendDeviceOwnerUserCommand(intExtra, "android.app.action.USER_STOPPED");
                        if (((DevicePolicyManagerService) this.this$0).isManagedProfile(intExtra)) {
                            Slogf.d("DevicePolicyManager", "Managed profile was stopped");
                            ((DevicePolicyManagerService) this.this$0).updatePersonalAppsSuspension(intExtra);
                            return;
                        }
                        return;
                    }
                    if ("android.intent.action.USER_SWITCHED".equals(action)) {
                        sendDeviceOwnerUserCommand(intExtra, "android.app.action.USER_SWITCHED");
                        return;
                    }
                    if ("android.intent.action.USER_UNLOCKED".equals(action)) {
                        synchronized (((DevicePolicyManagerService) this.this$0).getLockObject()) {
                            DevicePolicyManagerService.m422$$Nest$mmaybeSendAdminEnabledBroadcastLocked((DevicePolicyManagerService) this.this$0, intExtra);
                        }
                        if (((DevicePolicyManagerService) this.this$0).isManagedProfile(intExtra)) {
                            Slogf.d("DevicePolicyManager", "Managed profile became unlocked");
                            DevicePolicyManagerService.m424$$Nest$mtriggerPolicyComplianceCheckIfNeeded(intExtra, (DevicePolicyManagerService) this.this$0, ((DevicePolicyManagerService) this.this$0).updatePersonalAppsSuspension(intExtra));
                            return;
                        }
                        return;
                    }
                    if ("android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE".equals(action)) {
                        DevicePolicyManagerService.m421$$Nest$mhandlePackagesChanged(intExtra, (DevicePolicyManagerService) this.this$0, null);
                        return;
                    }
                    if ("android.intent.action.PACKAGE_CHANGED".equals(action)) {
                        DevicePolicyManagerService.m421$$Nest$mhandlePackagesChanged(intExtra, (DevicePolicyManagerService) this.this$0, intent.getData().getSchemeSpecificPart());
                        return;
                    }
                    if ("android.intent.action.PACKAGE_ADDED".equals(action)) {
                        if (intent.getBooleanExtra("android.intent.extra.REPLACING", false)) {
                            DevicePolicyManagerService.m421$$Nest$mhandlePackagesChanged(intExtra, (DevicePolicyManagerService) this.this$0, intent.getData().getSchemeSpecificPart());
                            return;
                        }
                        DevicePolicyManagerService devicePolicyManagerService3 = (DevicePolicyManagerService) this.this$0;
                        String schemeSpecificPart = intent.getData().getSchemeSpecificPart();
                        devicePolicyManagerService3.setCrossProfileAppToIgnored(schemeSpecificPart, intExtra);
                        if (devicePolicyManagerService3.getUserData(intExtra).mAppsSuspended) {
                            String[] strArr = {schemeSpecificPart};
                            if (devicePolicyManagerService3.mInjector.getPackageManager(intExtra).getUnsuspendablePackages(strArr).length == 0) {
                                devicePolicyManagerService3.mInjector.getClass();
                                Injector.getPackageManagerInternal().setPackagesSuspendedByAdmin(intExtra, true, strArr);
                                return;
                            } else {
                                Slogf.i("DevicePolicyManager", "Newly installed package is unsuspendable: " + schemeSpecificPart);
                                return;
                            }
                        }
                        return;
                    }
                    if ("android.intent.action.PACKAGE_REMOVED".equals(action) && !intent.getBooleanExtra("android.intent.extra.REPLACING", false)) {
                        DevicePolicyManagerService.m421$$Nest$mhandlePackagesChanged(intExtra, (DevicePolicyManagerService) this.this$0, intent.getData().getSchemeSpecificPart());
                        DevicePolicyManagerService devicePolicyManagerService4 = (DevicePolicyManagerService) this.this$0;
                        devicePolicyManagerService4.mBackgroundHandler.post(new DevicePolicyManagerService$$ExternalSyntheticLambda27(devicePolicyManagerService4, intent.getData().getSchemeSpecificPart(), 2));
                        return;
                    }
                    if (DevicePolicyListener.ACTION_PROFILE_OWNER_ADDED.equals(action)) {
                        ((DevicePolicyManagerService) this.this$0).mInjector.getNotificationManager().cancel(1001);
                        return;
                    }
                    if ("android.intent.action.DATE_CHANGED".equals(action) || "android.intent.action.TIME_SET".equals(action)) {
                        ((DevicePolicyManagerService) this.this$0).updateSystemUpdateFreezePeriodsRecord(true);
                        DevicePolicyManagerService devicePolicyManagerService5 = (DevicePolicyManagerService) this.this$0;
                        int managedUserId2 = devicePolicyManagerService5.getManagedUserId(devicePolicyManagerService5.getMainUserId());
                        if (managedUserId2 >= 0) {
                            ((DevicePolicyManagerService) this.this$0).updatePersonalAppsSuspension(managedUserId2);
                            return;
                        }
                        return;
                    }
                    if (DevicePolicyManagerService.ACTION_PROFILE_OFF_DEADLINE.equals(action)) {
                        Slogf.i("DevicePolicyManager", "Profile off deadline alarm was triggered");
                        DevicePolicyManagerService devicePolicyManagerService6 = (DevicePolicyManagerService) this.this$0;
                        int managedUserId3 = devicePolicyManagerService6.getManagedUserId(devicePolicyManagerService6.getMainUserId());
                        if (managedUserId3 >= 0) {
                            ((DevicePolicyManagerService) this.this$0).updatePersonalAppsSuspension(managedUserId3);
                            return;
                        } else {
                            Slogf.wtf("DevicePolicyManager", "Got deadline alarm for nonexistent profile");
                            return;
                        }
                    }
                    if (DevicePolicyManagerService.ACTION_TURN_PROFILE_ON_NOTIFICATION.equals(action)) {
                        Slogf.i("DevicePolicyManager", "requesting to turn on the profile: " + intExtra);
                        ((DevicePolicyManagerService) this.this$0).mUserManager.requestQuietModeEnabled(false, UserHandle.of(intExtra));
                        return;
                    }
                    if ("android.intent.action.MANAGED_PROFILE_UNAVAILABLE".equals(action)) {
                        DevicePolicyManagerService.m423$$Nest$mnotifyIfManagedSubscriptionsAreUnavailable((DevicePolicyManagerService) this.this$0, UserHandle.of(intExtra), false);
                        ((DevicePolicyManagerService) this.this$0).updatePersonalAppsSuspension(intExtra);
                        return;
                    } else if ("android.intent.action.MANAGED_PROFILE_AVAILABLE".equals(action)) {
                        DevicePolicyManagerService.m423$$Nest$mnotifyIfManagedSubscriptionsAreUnavailable((DevicePolicyManagerService) this.this$0, UserHandle.of(intExtra), true);
                        DevicePolicyManagerService.m424$$Nest$mtriggerPolicyComplianceCheckIfNeeded(intExtra, (DevicePolicyManagerService) this.this$0, ((DevicePolicyManagerService) this.this$0).updatePersonalAppsSuspension(intExtra));
                        return;
                    } else {
                        if ("android.accounts.LOGIN_ACCOUNTS_CHANGED".equals(action)) {
                            ((DevicePolicyManagerService) this.this$0).calculateHasIncompatibleAccounts();
                            return;
                        }
                        return;
                    }
                default:
                    ((RemoteCallback) this.this$0).sendResult(getResultExtras(false));
                    return;
            }
        }

        public void sendDeviceOwnerUserCommand(int i, String str) {
            synchronized (((DevicePolicyManagerService) this.this$0).getLockObject()) {
                try {
                    ActiveAdmin deviceOwnerAdminLocked = ((DevicePolicyManagerService) this.this$0).getDeviceOwnerAdminLocked();
                    if (deviceOwnerAdminLocked != null) {
                        Bundle bundle = new Bundle();
                        bundle.putParcelable("android.intent.extra.USER", UserHandle.of(i));
                        ((DevicePolicyManagerService) this.this$0).sendAdminCommandLocked(deviceOwnerAdminLocked, str, bundle, null, true);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    /* renamed from: com.android.server.devicepolicy.DevicePolicyManagerService$2, reason: invalid class name */
    public final class AnonymousClass2 implements PolicyPathProvider {
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    public final class CalculateHasIncompatibleAccountsTask extends AsyncTask {
        public static final String[] FEATURE_ALLOW = {"android.account.DEVICE_OR_PROFILE_OWNER_ALLOWED"};
        public static final String[] FEATURE_DISALLOW = {"android.account.DEVICE_OR_PROFILE_OWNER_DISALLOWED"};

        public CalculateHasIncompatibleAccountsTask() {
        }

        public static boolean hasAccountFeatures(AccountManager accountManager, Account account, String[] strArr) {
            try {
                return accountManager.hasFeatures(account, strArr, null, null).getResult(30L, TimeUnit.SECONDS).booleanValue();
            } catch (Exception e) {
                Slogf.w("DevicePolicyManager", "Failed to get account feature", e);
                return false;
            }
        }

        @Override // android.os.AsyncTask
        public final Object doInBackground(Object[] objArr) {
            List users = DevicePolicyManagerService.this.mUserManagerInternal.getUsers(true);
            HashMap hashMap = new HashMap();
            Iterator it = ((ArrayList) users).iterator();
            while (it.hasNext()) {
                UserInfo userInfo = (UserInfo) it.next();
                Integer valueOf = Integer.valueOf(userInfo.id);
                boolean z = false;
                AccountManager accountManager = (AccountManager) DevicePolicyManagerService.this.mContext.createContextAsUser(UserHandle.of(userInfo.id), 0).getSystemService(AccountManager.class);
                for (Account account : accountManager.getAccounts()) {
                    if (hasAccountFeatures(accountManager, account, FEATURE_DISALLOW) || !hasAccountFeatures(accountManager, account, FEATURE_ALLOW)) {
                        z = true;
                        break;
                    }
                }
                hashMap.put(valueOf, Boolean.valueOf(z));
            }
            return hashMap;
        }

        @Override // android.os.AsyncTask
        public final void onPostExecute(Object obj) {
            DevicePolicyManagerService.this.mHasIncompatibleAccounts = Collections.unmodifiableMap((Map) obj);
            Slogf.i("DevicePolicyManager", "Finished calculating hasIncompatibleAccountsTask");
        }
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    public final class DevicePolicyConstantsObserver extends ContentObserver {
        public final Uri mConstantsUri;

        public DevicePolicyConstantsObserver(Handler handler) {
            super(handler);
            this.mConstantsUri = Settings.Global.getUriFor("device_policy_constants");
        }

        @Override // android.database.ContentObserver
        public final void onChange(boolean z, Uri uri, int i) {
            DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
            devicePolicyManagerService.mConstants = new DevicePolicyConstants(Settings.Global.getString(devicePolicyManagerService.mInjector.mContext.getContentResolver(), "device_policy_constants"));
            DevicePolicyManager.invalidateBinderCaches();
            Injector injector = DevicePolicyManagerService.this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda57 devicePolicyManagerService$$ExternalSyntheticLambda57 = new DevicePolicyManagerService$$ExternalSyntheticLambda57(14, this);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda57);
        }
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    public final class DevicePolicyManagementRoleObserver implements OnRoleHoldersChangedListener {
        public final Context mContext;
        public final Executor mExecutor;
        public final RoleManager mRm;

        public DevicePolicyManagementRoleObserver(Context context) {
            this.mContext = context;
            this.mExecutor = context.getMainExecutor();
            this.mRm = (RoleManager) context.getSystemService(RoleManager.class);
        }

        public final String[] getDefaultRoleHolderPackageNameAndSignature() {
            String string = this.mContext.getString(R.string.config_devicePolicyManagement);
            if (TextUtils.isEmpty(string)) {
                return null;
            }
            return string.contains(":") ? string.split(":") : new String[]{string};
        }

        /* JADX WARN: Removed duplicated region for block: B:41:0x00b0  */
        /* JADX WARN: Removed duplicated region for block: B:44:0x00b7  */
        /*
            Code decompiled incorrectly, please refer to instructions dump.
            To view partially-correct code enable 'Show inconsistent code' option in preferences
        */
        public final void onRoleHoldersChanged(java.lang.String r11, android.os.UserHandle r12) {
            /*
                Method dump skipped, instructions count: 309
                To view this dump change 'Code comments level' option to 'DEBUG'
            */
            throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.DevicePolicyManagementRoleObserver.onRoleHoldersChanged(java.lang.String, android.os.UserHandle):void");
        }
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    public final class DpmsUpgradeDataProvider implements PolicyUpgraderDataProvider {
        public DpmsUpgradeDataProvider() {
        }
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    class Injector {
        public final Context mContext;
        public DevicePolicySafetyChecker mSafetyChecker;

        public Injector(Context context) {
            this.mContext = context;
        }

        public static void disableDocumentsUIComponent(int i) {
            Log.d("DevicePolicyManager::KnoxUtils", "Disabling google's documentsui launcher component for user: " + i);
            KnoxUtils.disableComponent(i, new ComponentName("com.google.android.documentsui", "com.android.documentsui.LauncherActivity"));
            KnoxUtils.disableComponent(i, new ComponentName("com.android.documentsui", "com.android.documentsui.LauncherActivity"));
        }

        public static ActivityManagerInternal getActivityManagerInternal() {
            return (ActivityManagerInternal) LocalServices.getService(ActivityManagerInternal.class);
        }

        public static PackageManagerInternal getPackageManagerInternal() {
            return (PackageManagerInternal) LocalServices.getService(PackageManagerInternal.class);
        }

        public static boolean isChangeEnabled(int i, String str, long j) {
            return CompatChanges.isChangeEnabled(j, str, UserHandle.of(i));
        }

        public static boolean isDeviceRootKeyInstalled() {
            IDarManagerService asInterface = IDarManagerService.Stub.asInterface(ServiceManager.getService("dar"));
            if (asInterface == null) {
                Log.d("DevicePolicyManager::KnoxUtils", "check Device Root Key - failed. cannot get DAR Service");
                return false;
            }
            try {
                return asInterface.isDeviceRootKeyInstalled();
            } catch (RemoteException e) {
                NetdService$$ExternalSyntheticOutline0.m("check Device Root Key - RemoteException : ", e, "DevicePolicyManager::KnoxUtils");
                return false;
            }
        }

        public static void logUserForSDP(int i, String str) {
            SDPLog.i(str + i);
        }

        public static int userHandleGetCallingUserId() {
            return UserHandle.getUserId(Binder.getCallingUid());
        }

        public static boolean verifyDeviceIntegrity() {
            IDarManagerService asInterface = IDarManagerService.Stub.asInterface(ServiceManager.getService("dar"));
            if (asInterface == null) {
                Log.d("DevicePolicyManager::KnoxUtils", "check Device Integrity - failed. cannot get DAR Service");
                return false;
            }
            try {
                return asInterface.isKnoxKeyInstallable();
            } catch (RemoteException e) {
                NetdService$$ExternalSyntheticOutline0.m("check Device Integrity - RemoteException : ", e, "DevicePolicyManager::KnoxUtils");
                return false;
            }
        }

        public final AppOpsManager getAppOpsManager() {
            return (AppOpsManager) this.mContext.getSystemService(AppOpsManager.class);
        }

        public final CrossProfileApps getCrossProfileApps(int i) {
            return (CrossProfileApps) this.mContext.createContextAsUser(UserHandle.of(i), 0).getSystemService(CrossProfileApps.class);
        }

        public final NotificationManager getNotificationManager() {
            return (NotificationManager) this.mContext.getSystemService(NotificationManager.class);
        }

        public final PackageManager getPackageManager(int i) {
            try {
                UserHandle of = UserHandle.of(i);
                return this.mContext.createPackageContextAsUser(this.mContext.getPackageName(), 0, of).getPackageManager();
            } catch (PackageManager.NameNotFoundException e) {
                throw new IllegalStateException(e);
            }
        }

        public final PermissionControllerManager getPermissionControllerManager(UserHandle userHandle) {
            if (userHandle.equals(this.mContext.getUser())) {
                return (PermissionControllerManager) this.mContext.getSystemService(PermissionControllerManager.class);
            }
            try {
                Context context = this.mContext;
                return (PermissionControllerManager) context.createPackageContextAsUser(context.getPackageName(), 0, userHandle).getSystemService(PermissionControllerManager.class);
            } catch (PackageManager.NameNotFoundException e) {
                throw new IllegalStateException(e);
            }
        }

        public final boolean recoverySystemRebootWipeUserData(String str, boolean z, boolean z2, boolean z3) {
            FactoryResetter.Builder builder = new FactoryResetter.Builder(this.mContext);
            builder.mSafetyChecker = this.mSafetyChecker;
            Objects.requireNonNull(str);
            builder.mReason = str;
            builder.mShutdown = false;
            builder.mForce = true;
            builder.mWipeEuicc = z;
            builder.mWipeAdoptableStorage = z2;
            builder.mWipeFactoryResetProtection = z3;
            return new FactoryResetter(builder).factoryReset();
        }

        public final int settingsGlobalGetInt(String str) {
            return Settings.Global.getInt(this.mContext.getContentResolver(), str, 0);
        }

        public final void settingsGlobalPutInt(String str, int i) {
            Settings.Global.putInt(this.mContext.getContentResolver(), str, i);
        }
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    public final class Lifecycle extends SystemService {
        public final DevicePolicyManagerService mService;

        public Lifecycle(Context context) {
            super(context);
            String string = context.getResources().getString(R.string.display_manager_overlay_display_name);
            if (TextUtils.isEmpty(string)) {
                this.mService = new DevicePolicyManagerService(new Injector(context.createAttributionContext("DevicePolicyManagerService")), new AnonymousClass2());
                return;
            }
            try {
                this.mService = (DevicePolicyManagerService) Class.forName(string).getConstructor(Context.class).newInstance(context);
            } catch (Exception e) {
                throw new IllegalStateException(ConnectivityModuleConnector$$ExternalSyntheticOutline0.m("Failed to instantiate DevicePolicyManagerService with class name: ", string), e);
            }
        }

        @Override // com.android.server.SystemService
        public final void onBootPhase(int i) {
            this.mService.systemReady(i);
        }

        @Override // com.android.server.SystemService
        public final void onStart() {
            publishBinderService("device_policy", this.mService);
        }

        @Override // com.android.server.SystemService
        public final void onUserStarting(SystemService.TargetUser targetUser) {
            if (targetUser.isPreCreated()) {
                return;
            }
            this.mService.handleStartUser(targetUser.getUserIdentifier());
        }

        @Override // com.android.server.SystemService
        public final void onUserStopping(SystemService.TargetUser targetUser) {
            if (targetUser.isPreCreated()) {
                return;
            }
            int userIdentifier = targetUser.getUserIdentifier();
            DevicePolicyManagerService devicePolicyManagerService = this.mService;
            devicePolicyManagerService.getClass();
            devicePolicyManagerService.updateNetworkPreferenceForUser(userIdentifier, List.of(PreferentialNetworkServiceConfig.DEFAULT));
            devicePolicyManagerService.mDeviceAdminServiceController.stopServicesForUser(userIdentifier);
            devicePolicyManagerService.mDevicePolicyEngine.updateDeviceAdminsServicesForUser(userIdentifier, false);
        }

        @Override // com.android.server.SystemService
        public final void onUserUnlocked(SystemService.TargetUser targetUser) {
            boolean equals;
            if (targetUser.isPreCreated()) {
                return;
            }
            DevicePolicyManagerService devicePolicyManagerService = this.mService;
            int userIdentifier = targetUser.getUserIdentifier();
            synchronized (devicePolicyManagerService.getLockObject()) {
                equals = "needed".equals(devicePolicyManagerService.getUserData(userIdentifier).mNewUserDisclaimer);
            }
            if (equals) {
                Intent intent = new Intent("android.app.action.SHOW_NEW_USER_DISCLAIMER");
                Slogf.i("DevicePolicyManager", "Dispatching ACTION_SHOW_NEW_USER_DISCLAIMER intent");
                devicePolicyManagerService.mContext.sendBroadcastAsUser(intent, UserHandle.of(userIdentifier));
            }
        }

        @Override // com.android.server.SystemService
        public final void onUserUnlocking(SystemService.TargetUser targetUser) {
            if (targetUser.isPreCreated()) {
                return;
            }
            int userIdentifier = targetUser.getUserIdentifier();
            DevicePolicyManagerService devicePolicyManagerService = this.mService;
            devicePolicyManagerService.startOwnerService(userIdentifier);
            devicePolicyManagerService.mDevicePolicyEngine.updateDeviceAdminsServicesForUser(userIdentifier, true);
        }
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    final class LocalService extends DevicePolicyManagerInternal implements DevicePolicyManagerLiteInternal {
        public static final /* synthetic */ int $r8$clinit = 0;
        public List mWidgetProviderListeners;

        /* renamed from: -$$Nest$mnotifyCrossProfileProvidersChanged, reason: not valid java name */
        public static void m425$$Nest$mnotifyCrossProfileProvidersChanged(LocalService localService, int i, List list) {
            ArrayList arrayList;
            synchronized (DevicePolicyManagerService.this.getLockObject()) {
                arrayList = new ArrayList(localService.mWidgetProviderListeners);
            }
            int size = arrayList.size();
            for (int i2 = 0; i2 < size; i2++) {
                ((DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener) arrayList.get(i2)).onCrossProfileWidgetProvidersChanged(i, list);
            }
        }

        public LocalService() {
        }

        public final void addOnCrossProfileWidgetProvidersChangeListener(DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener onCrossProfileWidgetProvidersChangeListener) {
            synchronized (DevicePolicyManagerService.this.getLockObject()) {
                try {
                    if (this.mWidgetProviderListeners == null) {
                        this.mWidgetProviderListeners = new ArrayList();
                    }
                    if (!this.mWidgetProviderListeners.contains(onCrossProfileWidgetProvidersChangeListener)) {
                        this.mWidgetProviderListeners.add(onCrossProfileWidgetProvidersChangeListener);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
        }

        public final void broadcastIntentToManifestReceivers(Intent intent, UserHandle userHandle, boolean z) {
            Objects.requireNonNull(intent);
            Objects.requireNonNull(userHandle);
            Slogf.i("DevicePolicyManager", "Sending %s broadcast to manifest receivers.", intent.getAction());
            int identifier = userHandle.getIdentifier();
            try {
                for (ResolveInfo resolveInfo : DevicePolicyManagerService.this.mIPackageManager.queryIntentReceivers(intent, (String) null, 1024L, identifier).getList()) {
                    String str = resolveInfo.getComponentInfo().packageName;
                    if (!checkCrossProfilePackagePermissions(identifier, str, z) && !checkModifyQuietModePermission(identifier, str)) {
                    }
                    Slogf.i("DevicePolicyManager", "Sending %s broadcast to %s.", intent.getAction(), str);
                    DevicePolicyManagerService.this.mContext.sendBroadcastAsUser(new Intent(intent).setComponent(resolveInfo.getComponentInfo().getComponentName()).addFlags(16777216), userHandle);
                }
            } catch (RemoteException e) {
                Slogf.w("DevicePolicyManager", "Cannot get list of broadcast receivers for %s because: %s.", intent.getAction(), e);
            }
            DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
            String roleHolderPackageNameOnUser = devicePolicyManagerService.getRoleHolderPackageNameOnUser(devicePolicyManagerService.mContext, "android.app.role.DEVICE_POLICY_MANAGEMENT", userHandle);
            if (roleHolderPackageNameOnUser == null) {
                return;
            }
            devicePolicyManagerService.broadcastExplicitIntentToPackage(intent, userHandle, roleHolderPackageNameOnUser);
        }

        public final boolean canSilentlyInstallPackage(String str, int i) {
            if (str == null) {
                return false;
            }
            CallerIdentity callerIdentity = new CallerIdentity(null, i, null);
            return isUserAffiliatedWithDevice(UserHandle.getUserId(i)) && (isActiveProfileOwner(i) || DevicePolicyManagerService.this.isDefaultDeviceOwner(callerIdentity) || DevicePolicyManagerService.this.isFinancedDeviceOwner(callerIdentity));
        }

        /* JADX WARN: Code restructure failed: missing block: B:14:0x003c, code lost:
        
            if (r10.applicationInfo.enabled != false) goto L19;
         */
        /*
            Code decompiled incorrectly, please refer to instructions dump.
            To view partially-correct code enable 'Show inconsistent code' option in preferences
        */
        public final boolean checkCrossProfilePackagePermissions(int r11, java.lang.String r12, boolean r13) {
            /*
                r10 = this;
                java.lang.Class<android.content.pm.PackageManagerInternal> r0 = android.content.pm.PackageManagerInternal.class
                java.lang.Object r0 = com.android.server.LocalServices.getService(r0)
                android.content.pm.PackageManagerInternal r0 = (android.content.pm.PackageManagerInternal) r0
                com.android.server.pm.pkg.AndroidPackage r0 = r0.getPackage(r12)
                r1 = 0
                if (r0 == 0) goto L65
                boolean r0 = r0.isCrossProfile()
                if (r0 != 0) goto L16
                goto L65
            L16:
                r0 = 1
                if (r13 != 0) goto L1a
                return r0
            L1a:
                int r3 = android.os.Binder.getCallingUid()
                long r8 = android.os.Binder.clearCallingIdentity()
                com.android.server.devicepolicy.DevicePolicyManagerService r10 = com.android.server.devicepolicy.DevicePolicyManagerService.this     // Catch: java.lang.Throwable -> L3f
                com.android.server.devicepolicy.DevicePolicyManagerService$Injector r10 = r10.mInjector     // Catch: java.lang.Throwable -> L3f
                r10.getClass()     // Catch: java.lang.Throwable -> L3f
                android.content.pm.PackageManagerInternal r2 = com.android.server.devicepolicy.DevicePolicyManagerService.Injector.getPackageManagerInternal()     // Catch: java.lang.Throwable -> L3f
                r5 = 786432(0xc0000, double:3.88549E-318)
                r4 = r11
                r7 = r12
                android.content.pm.PackageInfo r10 = r2.getPackageInfo(r3, r4, r5, r7)     // Catch: java.lang.Throwable -> L3f
                if (r10 == 0) goto L41
                android.content.pm.ApplicationInfo r10 = r10.applicationInfo     // Catch: java.lang.Throwable -> L3f
                boolean r10 = r10.enabled     // Catch: java.lang.Throwable -> L3f
                if (r10 == 0) goto L41
                goto L42
            L3f:
                r10 = move-exception
                goto L61
            L41:
                r0 = r1
            L42:
                android.os.Binder.restoreCallingIdentity(r8)
                if (r0 != 0) goto L48
                return r1
            L48:
                java.lang.Class<android.content.pm.CrossProfileAppsInternal> r10 = android.content.pm.CrossProfileAppsInternal.class
                java.lang.Object r10 = com.android.server.LocalServices.getService(r10)     // Catch: android.content.pm.PackageManager.NameNotFoundException -> L55
                android.content.pm.CrossProfileAppsInternal r10 = (android.content.pm.CrossProfileAppsInternal) r10     // Catch: android.content.pm.PackageManager.NameNotFoundException -> L55
                boolean r10 = r10.verifyPackageHasInteractAcrossProfilePermission(r12, r11)     // Catch: android.content.pm.PackageManager.NameNotFoundException -> L55
                return r10
            L55:
                java.lang.Object[] r10 = new java.lang.Object[]{r12}
                java.lang.String r11 = "DevicePolicyManager"
                java.lang.String r12 = "Cannot find the package %s to check for permissions."
                com.android.server.utils.Slogf.w(r11, r12, r10)
                return r1
            L61:
                android.os.Binder.restoreCallingIdentity(r8)
                throw r10
            L65:
                return r1
            */
            throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.LocalService.checkCrossProfilePackagePermissions(int, java.lang.String, boolean):boolean");
        }

        public final boolean checkModifyQuietModePermission(int i, String str) {
            try {
                PackageManager packageManager = DevicePolicyManagerService.this.mInjector.mContext.getPackageManager();
                Objects.requireNonNull(str);
                ApplicationInfo applicationInfoAsUser = packageManager.getApplicationInfoAsUser(str, 0, i);
                Objects.requireNonNull(applicationInfoAsUser);
                ApplicationInfo applicationInfo = applicationInfoAsUser;
                return ActivityManager.checkComponentPermission("android.permission.MODIFY_QUIET_MODE", applicationInfoAsUser.uid, -1, true) == 0;
            } catch (PackageManager.NameNotFoundException unused) {
                Slogf.w("DevicePolicyManager", "Cannot find the package %s to check for permissions.", str);
                return false;
            }
        }

        public final Intent createShowAdminSupportIntent(int i, boolean z) {
            DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
            String[] strArr = DevicePolicyManagerService.DELEGATIONS;
            if (devicePolicyManagerService.getEnforcingAdminAndUserDetailsInternal(i, null) == null && !z) {
                return null;
            }
            DevicePolicyManagerService.this.getClass();
            return DevicePolicyManagerService.createShowAdminSupportIntent(i);
        }

        public final Intent createUserRestrictionSupportIntent(int i, String str) {
            DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
            String[] strArr = DevicePolicyManagerService.DELEGATIONS;
            if (devicePolicyManagerService.getEnforcingAdminAndUserDetailsInternal(i, str) == null) {
                return null;
            }
            DevicePolicyManagerService.this.getClass();
            Intent createShowAdminSupportIntent = DevicePolicyManagerService.createShowAdminSupportIntent(i);
            createShowAdminSupportIntent.putExtra("android.app.extra.RESTRICTION", str);
            return createShowAdminSupportIntent;
        }

        public final void enforceAuditLoggingPolicy(boolean z) {
            if (Flags.securityLogV2Enabled()) {
                DevicePolicyManagerService.m420$$Nest$menforceLoggingPolicy(DevicePolicyManagerService.this, Boolean.TRUE.equals((Boolean) DevicePolicyManagerService.this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.SECURITY_LOGGING, -1)), z);
            }
        }

        public final void enforcePermission(String str, String str2, int i) {
            DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
            String[] strArr = DevicePolicyManagerService.DELEGATIONS;
            devicePolicyManagerService.enforcePermission(str2, str, i);
        }

        public final void enforceSecurityLoggingPolicy(boolean z) {
            if (Flags.securityLogV2Enabled()) {
                DevicePolicyManagerService.m420$$Nest$menforceLoggingPolicy(DevicePolicyManagerService.this, z, Boolean.TRUE.equals((Boolean) DevicePolicyManagerService.this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.AUDIT_LOGGING, -1)));
            }
        }

        public final List getAllCrossProfilePackages(int i) {
            return DevicePolicyManagerService.this.getAllCrossProfilePackages(i);
        }

        /* JADX WARN: Code restructure failed: missing block: B:4:0x0025, code lost:
        
            if (android.os.UserHandle.isSameApp(r0, ((java.lang.Integer) android.os.Binder.withCleanCallingIdentity(r3)).intValue()) == false) goto L6;
         */
        /*
            Code decompiled incorrectly, please refer to instructions dump.
            To view partially-correct code enable 'Show inconsistent code' option in preferences
        */
        public final java.util.List getApplicationRestrictionsPerAdminForUser(java.lang.String r6, int r7) {
            /*
                r5 = this;
                int r0 = android.os.UserHandle.getCallingUserId()
                if (r0 != r7) goto L27
                int r0 = android.os.Binder.getCallingUid()
                com.android.server.devicepolicy.DevicePolicyManagerService r1 = com.android.server.devicepolicy.DevicePolicyManagerService.this
                com.android.server.devicepolicy.DevicePolicyManagerService$Injector r2 = r1.mInjector
                com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda20 r3 = new com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda20
                r4 = 2
                r3.<init>(r1, r6, r7, r4)
                r2.getClass()
                java.lang.Object r1 = android.os.Binder.withCleanCallingIdentity(r3)
                java.lang.Integer r1 = (java.lang.Integer) r1
                int r1 = r1.intValue()
                boolean r0 = android.os.UserHandle.isSameApp(r0, r1)
                if (r0 != 0) goto L42
            L27:
                int r0 = android.os.Binder.getCallingUid()
                r1 = 1000(0x3e8, float:1.401E-42)
                boolean r1 = android.os.UserHandle.isSameApp(r0, r1)
                if (r1 != 0) goto L42
                if (r0 != 0) goto L36
                goto L42
            L36:
                java.lang.SecurityException r5 = new java.lang.SecurityException
                java.lang.String r7 = "Only system may: get application restrictions for other user/app "
                java.lang.String r6 = android.net.ConnectivityModuleConnector$$ExternalSyntheticOutline0.m(r7, r6)
                r5.<init>(r6)
                throw r5
            L42:
                com.android.server.devicepolicy.DevicePolicyManagerService r0 = com.android.server.devicepolicy.DevicePolicyManagerService.this
                com.android.server.devicepolicy.DevicePolicyEngine r0 = r0.mDevicePolicyEngine
                com.android.server.devicepolicy.PolicyDefinition r1 = com.android.server.devicepolicy.PolicyDefinition.APPLICATION_RESTRICTIONS(r6)
                java.util.LinkedHashMap r0 = r0.getLocalPoliciesSetByAdmins(r1, r7)
                java.util.ArrayList r1 = new java.util.ArrayList
                r1.<init>()
                java.util.Collection r0 = r0.values()
                java.util.Iterator r0 = r0.iterator()
            L5b:
                boolean r2 = r0.hasNext()
                if (r2 == 0) goto L79
                java.lang.Object r2 = r0.next()
                android.app.admin.PolicyValue r2 = (android.app.admin.PolicyValue) r2
                java.lang.Object r2 = r2.getValue()
                android.os.Bundle r2 = (android.os.Bundle) r2
                if (r2 == 0) goto L5b
                boolean r3 = r2.isEmpty()
                if (r3 != 0) goto L5b
                r1.add(r2)
                goto L5b
            L79:
                com.android.server.devicepolicy.DevicePolicyManagerService r0 = com.android.server.devicepolicy.DevicePolicyManagerService.this
                com.android.server.devicepolicy.DevicePolicyManagerService$Injector r0 = r0.mInjector
                com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda177 r2 = new com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda177
                r2.<init>(r5, r6, r7, r1)
                r0.getClass()
                java.lang.Object r5 = android.os.Binder.withCleanCallingIdentity(r2)
                java.util.List r5 = (java.util.List) r5
                return r5
            */
            throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.LocalService.getApplicationRestrictionsPerAdminForUser(java.lang.String, int):java.util.List");
        }

        public final List getCrossProfileWidgetProviders(int i) {
            List list;
            synchronized (DevicePolicyManagerService.this.getLockObject()) {
                try {
                    Owners owners = DevicePolicyManagerService.this.mOwners;
                    if (owners == null) {
                        return Collections.emptyList();
                    }
                    ComponentName profileOwnerComponent = owners.getProfileOwnerComponent(i);
                    if (profileOwnerComponent == null) {
                        return Collections.emptyList();
                    }
                    ActiveAdmin activeAdmin = (ActiveAdmin) DevicePolicyManagerService.this.getUserDataUnchecked(i).mAdminMap.get(profileOwnerComponent);
                    if (activeAdmin != null && (list = activeAdmin.crossProfileWidgetProviders) != null && !list.isEmpty()) {
                        return activeAdmin.crossProfileWidgetProviders;
                    }
                    return Collections.emptyList();
                } catch (Throwable th) {
                    throw th;
                }
            }
        }

        public final List getDefaultCrossProfilePackages() {
            return DevicePolicyManagerService.this.getDefaultCrossProfilePackages();
        }

        public final ComponentName getDeviceOwnerComponent(boolean z) {
            return DevicePolicyManagerService.this.getDeviceOwnerComponent(z);
        }

        public final int getDeviceOwnerUserId() {
            return DevicePolicyManagerService.this.getDeviceOwnerUserId();
        }

        public final DevicePolicyCache getDevicePolicyCache() {
            return DevicePolicyManagerService.this.mPolicyCache;
        }

        public final DeviceStateCache getDeviceStateCache() {
            return DevicePolicyManagerService.this.mStateCache;
        }

        public final List getEnforcingUsers(Set set) {
            ArrayList arrayList = new ArrayList();
            ComponentName deviceOwnerComponent = DevicePolicyManagerService.this.mOwners.getDeviceOwnerComponent();
            Iterator it = set.iterator();
            while (it.hasNext()) {
                EnforcingAdmin enforcingAdmin = (EnforcingAdmin) it.next();
                if (deviceOwnerComponent == null || !deviceOwnerComponent.getPackageName().equals(enforcingAdmin.mPackageName)) {
                    arrayList.add(new UserManager.EnforcingUser(enforcingAdmin.mUserId, 4));
                } else {
                    arrayList.add(new UserManager.EnforcingUser(enforcingAdmin.mUserId, 2));
                }
            }
            return arrayList;
        }

        public final CharSequence getPrintingDisabledReasonForUser(int i) {
            synchronized (DevicePolicyManagerService.this.getLockObject()) {
                try {
                    if (!DevicePolicyManagerService.this.mUserManager.hasUserRestriction("no_printing", UserHandle.of(i))) {
                        Slogf.e("DevicePolicyManager", "printing is enabled for user %d", Integer.valueOf(i));
                        return null;
                    }
                    String profileOwnerPackage = DevicePolicyManagerService.this.mOwners.getProfileOwnerPackage(i);
                    if (profileOwnerPackage == null) {
                        profileOwnerPackage = DevicePolicyManagerService.this.mOwners.getDeviceOwnerPackageName();
                    }
                    PackageManager packageManager = DevicePolicyManagerService.this.mInjector.mContext.getPackageManager();
                    Injector injector = DevicePolicyManagerService.this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda34 devicePolicyManagerService$$ExternalSyntheticLambda34 = new DevicePolicyManagerService$$ExternalSyntheticLambda34(1, packageManager, profileOwnerPackage);
                    injector.getClass();
                    PackageInfo packageInfo = (PackageInfo) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda34);
                    if (packageInfo == null) {
                        Slogf.e("DevicePolicyManager", "packageInfo is inexplicably null");
                        return null;
                    }
                    ApplicationInfo applicationInfo = packageInfo.applicationInfo;
                    if (applicationInfo == null) {
                        Slogf.e("DevicePolicyManager", "appInfo is inexplicably null");
                        return null;
                    }
                    CharSequence applicationLabel = packageManager.getApplicationLabel(applicationInfo);
                    if (applicationLabel == null) {
                        Slogf.e("DevicePolicyManager", "appLabel is inexplicably null");
                        return null;
                    }
                    return DevicePolicyManagerService.this.getUpdatableString("Core.PRINTING_DISABLED_NAMED_ADMIN", 17042478, applicationLabel);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }

        public final ComponentName getProfileOwnerAsUser(int i) {
            return DevicePolicyManagerService.this.getProfileOwnerAsUser(i);
        }

        public final ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(UserHandle userHandle) {
            return DevicePolicyManagerService.this.getProfileOwnerOrDeviceOwnerSupervisionComponent(userHandle);
        }

        public final List getUserRestrictionSources(String str, int i) {
            PolicyDefinition policyDefinitionForUserRestriction = PolicyDefinition.getPolicyDefinitionForUserRestriction(str);
            Set keySet = DevicePolicyManagerService.this.mDevicePolicyEngine.getLocalPoliciesSetByAdmins(policyDefinitionForUserRestriction, i).keySet();
            Set keySet2 = DevicePolicyManagerService.this.mDevicePolicyEngine.getGlobalPoliciesSetByAdmins(policyDefinitionForUserRestriction).keySet();
            ArrayList arrayList = new ArrayList();
            arrayList.addAll(getEnforcingUsers(keySet));
            arrayList.addAll(getEnforcingUsers(keySet2));
            return arrayList;
        }

        public final boolean hasPermission(String str, String str2, int i) {
            DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
            String[] strArr = DevicePolicyManagerService.DELEGATIONS;
            return devicePolicyManagerService.hasPermission(str2, str, i);
        }

        public final boolean isActiveDeviceOwner(int i) {
            DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
            CallerIdentity callerIdentity = new CallerIdentity(null, i, null);
            String[] strArr = DevicePolicyManagerService.DELEGATIONS;
            return devicePolicyManagerService.isDefaultDeviceOwner(callerIdentity);
        }

        public final boolean isActiveProfileOwner(int i) {
            return DevicePolicyManagerService.this.isProfileOwner(new CallerIdentity(null, i, null));
        }

        public final boolean isActiveSupervisionApp(int i) {
            if (!DevicePolicyManagerService.this.isProfileOwner(new CallerIdentity(null, i, null))) {
                return false;
            }
            synchronized (DevicePolicyManagerService.this.getLockObject()) {
                try {
                    ActiveAdmin profileOwnerAdminLocked = DevicePolicyManagerService.this.getProfileOwnerAdminLocked(UserHandle.getUserId(i));
                    if (profileOwnerAdminLocked == null) {
                        return false;
                    }
                    return DevicePolicyManagerService.this.isSupervisionComponentLocked(profileOwnerAdminLocked.info.getComponent());
                } catch (Throwable th) {
                    throw th;
                }
            }
        }

        public final boolean isDeviceOrProfileOwnerInCallingUser(String str) {
            ComponentName deviceOwnerComponent = DevicePolicyManagerService.this.getDeviceOwnerComponent(true);
            if (deviceOwnerComponent != null && str.equals(deviceOwnerComponent.getPackageName())) {
                return true;
            }
            ComponentName profileOwnerAsUser = DevicePolicyManagerService.this.getProfileOwnerAsUser(UserHandle.getCallingUserId());
            return profileOwnerAsUser != null && str.equals(profileOwnerAsUser.getPackageName());
        }

        public final boolean isUserAffiliatedWithDevice(int i) {
            DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
            String[] strArr = DevicePolicyManagerService.DELEGATIONS;
            return devicePolicyManagerService.isUserAffiliatedWithDeviceLocked(i);
        }

        public final boolean isUserOrganizationManaged(int i) {
            return DevicePolicyManagerService.this.mStateCache.isUserOrganizationManaged(i);
        }

        public final void notifyChangesOnWifiPolicy() {
            DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
            String[] strArr = DevicePolicyManagerService.DELEGATIONS;
            devicePolicyManagerService.notifyMinimumRequiredWifiSecurityLevelChanged(devicePolicyManagerService.getStrictestMinimumRequiredWifiSecurityLevelLocked());
            DevicePolicyManagerService devicePolicyManagerService2 = DevicePolicyManagerService.this;
            devicePolicyManagerService2.notifyWifiSsidPolicyChanged(devicePolicyManagerService2.getCombinedWifiSsidPolicyLocked());
        }

        public final void notifyUnsafeOperationStateChanged(DevicePolicySafetyChecker devicePolicySafetyChecker, int i, boolean z) {
            DevicePolicySafetyChecker devicePolicySafetyChecker2 = DevicePolicyManagerService.this.mSafetyChecker;
            Preconditions.checkArgument(devicePolicySafetyChecker2 == devicePolicySafetyChecker, "invalid checker: should be %s, was %s", new Object[]{devicePolicySafetyChecker2, devicePolicySafetyChecker});
            Bundle bundle = new Bundle();
            bundle.putInt("android.app.extra.OPERATION_SAFETY_REASON", i);
            bundle.putBoolean("android.app.extra.OPERATION_SAFETY_STATE", z);
            if (DevicePolicyManagerService.this.mOwners.hasDeviceOwner()) {
                DevicePolicyManagerService.this.sendDeviceOwnerCommand(bundle, "android.app.action.OPERATION_SAFETY_STATE_CHANGED");
            }
            Iterator it = DevicePolicyManagerService.this.mOwners.getProfileOwnerKeys().iterator();
            while (it.hasNext()) {
                int intValue = ((Integer) it.next()).intValue();
                DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                devicePolicyManagerService.sendActiveAdminCommand("android.app.action.OPERATION_SAFETY_STATE_CHANGED", bundle, intValue, devicePolicyManagerService.mOwners.getProfileOwnerComponent(intValue), false);
            }
        }

        public final void reportSeparateProfileChallengeChanged(int i) {
            Injector injector = DevicePolicyManagerService.this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda29 devicePolicyManagerService$$ExternalSyntheticLambda29 = new DevicePolicyManagerService$$ExternalSyntheticLambda29(i, 7, this);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda29);
            DevicePolicyEventLogger.createEvent(110).setBoolean(DevicePolicyManagerService.this.isSeparateProfileChallengeEnabled(i)).write();
            DevicePolicyManager.invalidateBinderCaches();
        }

        public final void resetOp(int i, String str, int i2) {
            if (i != 93) {
                throw new IllegalArgumentException(VibrationParam$1$$ExternalSyntheticOutline0.m(i, "Unsupported op for DPM reset: "));
            }
            ((CrossProfileAppsInternal) LocalServices.getService(CrossProfileAppsInternal.class)).setInteractAcrossProfilesAppOp(str, ((ArrayList) DevicePolicyManagerService.this.getDefaultCrossProfilePackages()).contains(str) ? 0 : AppOpsManager.opToDefaultMode(93), i2);
        }

        public final void setMinimumRequiredWifiSecurityLevel(ComponentName componentName, int i, int i2) {
            synchronized (DevicePolicyManagerService.this.getLockObject()) {
                try {
                    ActiveAdmin activeAdminUncheckedLocked = DevicePolicyManagerService.this.getActiveAdminUncheckedLocked(i2, componentName);
                    if (activeAdminUncheckedLocked == null) {
                        Log.e("DevicePolicyManager", "setMinimumRequiredWifiSecurityLevel - admin is null!");
                        return;
                    }
                    DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                    devicePolicyManagerService.getClass();
                    if (activeAdminUncheckedLocked.mWifiMinimumSecurityLevel != i) {
                        activeAdminUncheckedLocked.mWifiMinimumSecurityLevel = i;
                        devicePolicyManagerService.saveSettingsLocked(activeAdminUncheckedLocked.getUserHandle().getIdentifier(), false, false, false);
                        DevicePolicyManagerService devicePolicyManagerService2 = DevicePolicyManagerService.this;
                        devicePolicyManagerService2.notifyMinimumRequiredWifiSecurityLevelChanged(devicePolicyManagerService2.getStrictestMinimumRequiredWifiSecurityLevelLocked());
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
        }

        public final void setWifiSsidPolicy(ComponentName componentName, WifiSsidPolicy wifiSsidPolicy, int i) {
            boolean z;
            synchronized (DevicePolicyManagerService.this.getLockObject()) {
                try {
                    ActiveAdmin activeAdminUncheckedLocked = DevicePolicyManagerService.this.getActiveAdminUncheckedLocked(i, componentName);
                    if (activeAdminUncheckedLocked == null) {
                        Log.e("DevicePolicyManager", "setWifiSsidPolicy - admin is null!");
                        return;
                    }
                    DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                    devicePolicyManagerService.getClass();
                    if (Objects.equals(wifiSsidPolicy, activeAdminUncheckedLocked.mWifiSsidPolicy)) {
                        z = false;
                    } else {
                        activeAdminUncheckedLocked.mWifiSsidPolicy = wifiSsidPolicy;
                        z = true;
                    }
                    if (z) {
                        devicePolicyManagerService.saveSettingsLocked(activeAdminUncheckedLocked.getUserHandle().getIdentifier(), false, false, false);
                    }
                    if (z) {
                        DevicePolicyManagerService devicePolicyManagerService2 = DevicePolicyManagerService.this;
                        devicePolicyManagerService2.notifyWifiSsidPolicyChanged(devicePolicyManagerService2.getCombinedWifiSsidPolicyLocked());
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
        }

        public final boolean supportsResetOp(int i) {
            return i == 93 && LocalServices.getService(CrossProfileAppsInternal.class) != null;
        }
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    public final class RestrictionsListener implements UserManagerInternal.UserRestrictionsListener {
        public final Context mContext;
        public final DevicePolicyManagerService mDpms;
        public final UserManagerInternal mUserManagerInternal;

        public RestrictionsListener(Context context, UserManagerInternal userManagerInternal, DevicePolicyManagerService devicePolicyManagerService) {
            this.mContext = context;
            this.mUserManagerInternal = userManagerInternal;
            this.mDpms = devicePolicyManagerService;
        }

        @Override // com.android.server.pm.UserManagerInternal.UserRestrictionsListener
        public final void onUserRestrictionsChanged(int i, Bundle bundle, Bundle bundle2) {
            int profileParentId;
            if (UserRestrictionsUtils.restrictionsChanged(bundle2, bundle, "no_sharing_into_profile") && (profileParentId = this.mUserManagerInternal.getProfileParentId(i)) != i) {
                Slogf.i("DevicePolicyManager", "Resetting cross-profile intent filters on restriction change");
                this.mDpms.resetDefaultCrossProfileIntentFilters(profileParentId);
                try {
                    this.mContext.sendBroadcastAsUser(new Intent("android.app.action.DATA_SHARING_RESTRICTION_APPLIED"), UserHandle.of(i));
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (!bundle2.getBoolean("no_config_vpn") && bundle.getBoolean("no_config_vpn")) {
                DevicePolicyManagerService devicePolicyManagerService = this.mDpms;
                synchronized (devicePolicyManagerService.getLockObject()) {
                    try {
                        ActiveAdmin deviceOrProfileOwnerAdminLocked = devicePolicyManagerService.getDeviceOrProfileOwnerAdminLocked(i);
                        if (deviceOrProfileOwnerAdminLocked == null) {
                            Slogf.wtf("DevicePolicyManager", "Admin not found");
                        } else {
                            String str = deviceOrProfileOwnerAdminLocked.mAlwaysOnVpnPackage;
                            if (str == null) {
                                ((VpnManager) devicePolicyManagerService.mInjector.mContext.getSystemService(VpnManager.class)).setAlwaysOnVpnPackageForUser(i, null, false, null);
                            }
                            List<AppOpsManager.PackageOps> packagesForOps = devicePolicyManagerService.mInjector.getAppOpsManager().getPackagesForOps(new int[]{47});
                            if (packagesForOps != null) {
                                for (AppOpsManager.PackageOps packageOps : packagesForOps) {
                                    if (UserHandle.getUserId(packageOps.getUid()) == i && !packageOps.getPackageName().equals(str)) {
                                        if (packageOps.getOps().size() != 1) {
                                            Slogf.wtf("DevicePolicyManager", "Unexpected number of ops returned");
                                        } else if (((AppOpsManager.OpEntry) packageOps.getOps().get(0)).getMode() == 0) {
                                            Slogf.i("DevicePolicyManager", String.format("Revoking VPN authorization for package %s uid %d", packageOps.getPackageName(), Integer.valueOf(packageOps.getUid())));
                                            devicePolicyManagerService.mInjector.getAppOpsManager().setMode(47, packageOps.getUid(), packageOps.getPackageName(), 3);
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                    }
                }
            }
            if (Flags.deletePrivateSpaceUnderRestriction() && !bundle2.getBoolean("no_add_private_profile") && bundle.getBoolean("no_add_private_profile")) {
                DevicePolicyManagerService devicePolicyManagerService2 = this.mDpms;
                if (devicePolicyManagerService2.mUserManager.isProfile(i)) {
                    return;
                }
                boolean z = false;
                for (int i2 : devicePolicyManagerService2.mUserManager.getProfileIdsWithDisabled(i)) {
                    if (i2 != i && devicePolicyManagerService2.mUserManager.getUserInfo(i2).isPrivateProfile()) {
                        Slogf.i("DevicePolicyManager", "Removing private space %d due to DISALLOW_ADD_PRIVATE_PROFILE", Integer.valueOf(i2));
                        z |= devicePolicyManagerService2.mUserManager.removeUserEvenWhenDisallowed(i2);
                    }
                }
                if (z) {
                    devicePolicyManagerService2.mHandler.post(new DevicePolicyManagerService$$ExternalSyntheticLambda0(devicePolicyManagerService2, i, 1));
                }
            }
        }
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    public final class SetupContentObserver extends ContentObserver {
        public final Uri mDefaultImeChanged;
        public final Uri mDeviceProvisioned;
        public final Uri mPaired;
        public final Set mUserIdsWithPendingChangesByOwner;
        public final Uri mUserSetupComplete;

        public SetupContentObserver(Handler handler) {
            super(handler);
            this.mUserSetupComplete = Settings.Secure.getUriFor("user_setup_complete");
            this.mDeviceProvisioned = Settings.Global.getUriFor("device_provisioned");
            this.mPaired = Settings.Secure.getUriFor("device_paired");
            this.mDefaultImeChanged = Settings.Secure.getUriFor("default_input_method");
            this.mUserIdsWithPendingChangesByOwner = new ArraySet();
        }

        @Override // android.database.ContentObserver
        public final void onChange(boolean z, Uri uri, int i) {
            if (this.mUserSetupComplete.equals(uri) || (DevicePolicyManagerService.this.mIsWatch && this.mPaired.equals(uri))) {
                DevicePolicyManagerService.this.updateUserSetupCompleteAndPaired();
                return;
            }
            if (this.mDeviceProvisioned.equals(uri)) {
                synchronized (DevicePolicyManagerService.this.getLockObject()) {
                    DevicePolicyManagerService.this.setDeviceOwnershipSystemPropertyLocked();
                }
            } else if (this.mDefaultImeChanged.equals(uri)) {
                synchronized (DevicePolicyManagerService.this.getLockObject()) {
                    try {
                        if (((ArraySet) this.mUserIdsWithPendingChangesByOwner).contains(Integer.valueOf(i))) {
                            ((ArraySet) this.mUserIdsWithPendingChangesByOwner).remove(Integer.valueOf(i));
                        } else {
                            DevicePolicyManagerService.this.getUserData(i).mCurrentInputMethodSet = false;
                            DevicePolicyManagerService.this.saveSettingsLocked(i, false, false, false);
                        }
                    } finally {
                    }
                }
            }
        }
    }

    /* compiled from: qb/89523975 b19e8d3036bb0bb04c0b123e55579fdc5d41bbd9c06260ba21f1b25f8ce00bef */
    public final class UserLifecycleListener implements UserManagerInternal.UserLifecycleListener {
        public UserLifecycleListener() {
        }

        @Override // com.android.server.pm.UserManagerInternal.UserLifecycleListener
        public final void onUserCreated(final UserInfo userInfo, final Object obj) {
            DevicePolicyManagerService.this.mHandler.post(new Runnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$UserLifecycleListener$$ExternalSyntheticLambda0
                @Override // java.lang.Runnable
                public final void run() {
                    DevicePolicyManagerService.UserLifecycleListener userLifecycleListener = DevicePolicyManagerService.UserLifecycleListener.this;
                    UserInfo userInfo2 = userInfo;
                    Object obj2 = obj;
                    DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                    DevicePolicyEngine devicePolicyEngine = devicePolicyManagerService.mDevicePolicyEngine;
                    devicePolicyEngine.getClass();
                    if (userInfo2.isProfile()) {
                        Binder.withCleanCallingIdentity(new DevicePolicyEngine$$ExternalSyntheticLambda3(devicePolicyEngine, userInfo2, 1));
                    }
                    int i = userInfo2.id;
                    if (obj2 != null) {
                        synchronized (devicePolicyManagerService.getLockObject()) {
                            try {
                                if (devicePolicyManagerService.mPendingUserCreatedCallbackTokens.contains(obj2)) {
                                    Slogf.d("DevicePolicyManager", "handleNewUserCreated(): ignoring for user " + i + " due to token " + obj2);
                                    devicePolicyManagerService.mPendingUserCreatedCallbackTokens.remove(obj2);
                                    return;
                                }
                            } finally {
                            }
                        }
                    }
                    if (!devicePolicyManagerService.mOwners.hasDeviceOwner() || !userInfo2.isFull() || userInfo2.isManagedProfile() || userInfo2.isGuest()) {
                        return;
                    }
                    devicePolicyManagerService.mInjector.getClass();
                    if (!UserManager.isHeadlessSystemUserMode()) {
                        Slogf.i("DevicePolicyManager", "User %d added on DO mode; setting ShowNewUserDisclaimer", Integer.valueOf(i));
                        devicePolicyManagerService.setShowNewUserDisclaimer(i, "needed");
                        return;
                    }
                    ComponentName deviceOwnerComponent = devicePolicyManagerService.mOwners.getDeviceOwnerComponent();
                    Slogf.i("DevicePolicyManager", "Automatically setting profile owner (" + deviceOwnerComponent + ") on new user " + i);
                    devicePolicyManagerService.manageUserUnchecked(deviceOwnerComponent, deviceOwnerComponent, i, null, true);
                }
            });
        }
    }

    /* renamed from: -$$Nest$mdiscardDeviceWideLogsLocked, reason: not valid java name */
    public static void m419$$Nest$mdiscardDeviceWideLogsLocked(DevicePolicyManagerService devicePolicyManagerService) {
        SecurityLogMonitor securityLogMonitor = devicePolicyManagerService.mSecurityLogMonitor;
        ((ReentrantLock) securityLogMonitor.mLock).lock();
        securityLogMonitor.mAllowedToRetrieve = false;
        securityLogMonitor.mPendingLogs = new ArrayList();
        securityLogMonitor.mCriticalLevelLogged = false;
        ((ReentrantLock) securityLogMonitor.mLock).unlock();
        Slog.i("SecurityLogMonitor", "Discarded all logs.");
        NetworkLogger networkLogger = devicePolicyManagerService.mNetworkLogger;
        if (networkLogger != null) {
            networkLogger.discardLogs();
        }
    }

    /* renamed from: -$$Nest$menforceLoggingPolicy, reason: not valid java name */
    public static void m420$$Nest$menforceLoggingPolicy(DevicePolicyManagerService devicePolicyManagerService, boolean z, boolean z2) {
        devicePolicyManagerService.getClass();
        Slogf.i("DevicePolicyManager", "Enforcing logging policy, security: %b audit: %b", Boolean.valueOf(z), Boolean.valueOf(z2));
        Injector injector = devicePolicyManagerService.mInjector;
        boolean z3 = z || z2;
        injector.getClass();
        SecurityLog.setLoggingEnabledProperty(z3);
        devicePolicyManagerService.setLoggingConfiguration(z, z2);
    }

    /* renamed from: -$$Nest$mhandlePackagesChanged, reason: not valid java name */
    public static void m421$$Nest$mhandlePackagesChanged(int i, DevicePolicyManagerService devicePolicyManagerService, String str) {
        boolean z;
        String packageName;
        DevicePolicyData userData = devicePolicyManagerService.getUserData(i);
        synchronized (devicePolicyManagerService.getLockObject()) {
            try {
                String str2 = null;
                z = false;
                for (int size = userData.mAdminList.size() - 1; size >= 0; size--) {
                    ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminList.get(size);
                    try {
                        packageName = activeAdmin.info.getPackageName();
                    } catch (RemoteException e) {
                        e = e;
                    }
                    if (str != null && !str.equals(packageName)) {
                    }
                    if (devicePolicyManagerService.mIPackageManager.getPackageInfo(packageName, 0L, i) == null || devicePolicyManagerService.mIPackageManager.getReceiverInfo(activeAdmin.info.getComponent(), 786432L, i) == null) {
                        Slogf.e("DevicePolicyManager", String.format("Admin package %s not found for user %d, removing active admin", str, Integer.valueOf(i)));
                        try {
                            userData.mAdminList.remove(size);
                            userData.mAdminMap.remove(activeAdmin.info.getComponent());
                            try {
                                UsageStatsService.this.mAppStandby.setActiveAdminApps(devicePolicyManagerService.getActiveAdminPackagesLocked(i), i);
                                devicePolicyManagerService.mInjector.getClass();
                                userData.validatePasswordOwner();
                                devicePolicyManagerService.saveSettingsLocked(userData.mUserId, false, false, false);
                                z = true;
                                str2 = packageName;
                            } catch (RemoteException e2) {
                                e = e2;
                                z = true;
                                str2 = packageName;
                                Slogf.wtf("DevicePolicyManager", "Error handling package changes", e);
                            }
                        } catch (RemoteException e3) {
                            e = e3;
                        }
                    }
                }
                if (z) {
                    userData.validatePasswordOwner();
                }
                boolean z2 = false;
                for (int size2 = userData.mDelegationMap.size() - 1; size2 >= 0; size2--) {
                    String str3 = (String) userData.mDelegationMap.keyAt(size2);
                    if (str3 != null) {
                        if (str != null) {
                            try {
                                if (str.equals(str3)) {
                                }
                            } catch (RemoteException e4) {
                                Slogf.wtf("DevicePolicyManager", "Error checking isRemovedPackage", e4);
                            }
                        }
                        if (devicePolicyManagerService.mIPackageManager.getPackageInfo(str3, 0L, i) == null) {
                            userData.mDelegationMap.removeAt(size2);
                            z2 = true;
                        }
                    }
                }
                ComponentName ownerComponent = devicePolicyManagerService.getOwnerComponent(i);
                if (str != null && ownerComponent != null && ownerComponent.getPackageName().equals(str)) {
                    devicePolicyManagerService.startOwnerService(i);
                }
                DevicePolicyEngine devicePolicyEngine = devicePolicyManagerService.mDevicePolicyEngine;
                devicePolicyEngine.getClass();
                Binder.withCleanCallingIdentity(new DevicePolicyEngine$$ExternalSyntheticLambda0(devicePolicyEngine, i, str2, str));
                if (z || z2) {
                    devicePolicyManagerService.saveSettingsLocked(userData.mUserId, false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        if (z) {
            devicePolicyManagerService.pushMeteredDisabledPackages(i);
        }
    }

    /* renamed from: -$$Nest$mmaybeSendAdminEnabledBroadcastLocked, reason: not valid java name */
    public static void m422$$Nest$mmaybeSendAdminEnabledBroadcastLocked(DevicePolicyManagerService devicePolicyManagerService, int i) {
        boolean z;
        DevicePolicyData userData = devicePolicyManagerService.getUserData(i);
        if (userData.mAdminBroadcastPending) {
            ActiveAdmin profileOwnerAdminLocked = devicePolicyManagerService.getProfileOwnerAdminLocked(i);
            if (profileOwnerAdminLocked != null) {
                PersistableBundle persistableBundle = userData.mInitBundle;
                z = devicePolicyManagerService.sendAdminCommandLocked(profileOwnerAdminLocked, "android.app.action.DEVICE_ADMIN_ENABLED", persistableBundle == null ? null : new Bundle(persistableBundle), null, true);
            } else {
                z = true;
            }
            if (z) {
                userData.mInitBundle = null;
                userData.mAdminBroadcastPending = false;
                devicePolicyManagerService.saveSettingsLocked(i, false, false, false);
            }
        }
    }

    /* renamed from: -$$Nest$mnotifyIfManagedSubscriptionsAreUnavailable, reason: not valid java name */
    public static void m423$$Nest$mnotifyIfManagedSubscriptionsAreUnavailable(DevicePolicyManagerService devicePolicyManagerService, UserHandle userHandle, boolean z) {
        devicePolicyManagerService.getClass();
        if (!devicePolicyManagerService.isManagedProfile(userHandle.getIdentifier())) {
            Slog.wtf("DevicePolicyManager", "Expected managed profile when notified of profile availability change.");
        }
        if (devicePolicyManagerService.getManagedSubscriptionsPolicy().getPolicyType() != 1) {
            return;
        }
        if (z) {
            devicePolicyManagerService.mInjector.getNotificationManager().cancel(1006);
            return;
        }
        Intent intent = new Intent(ACTION_TURN_PROFILE_ON_NOTIFICATION);
        intent.putExtra("android.intent.extra.user_handle", userHandle.getIdentifier());
        Injector injector = devicePolicyManagerService.mInjector;
        Context context = devicePolicyManagerService.mContext;
        injector.getClass();
        Notification.Action build = new Notification.Action.Builder((Icon) null, devicePolicyManagerService.getUpdatableString("Core.TURN_ON_WORK_PROFILE_BUTTON_TEXT", 17043643, new Object[0]), PendingIntent.getBroadcast(context, 0, intent, 201326592)).build();
        Bundle bundle = new Bundle();
        bundle.putString("android.substName", devicePolicyManagerService.getUpdatableString("Core.NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION", R.string.silent_mode_vibrate, new Object[0]));
        devicePolicyManagerService.mInjector.getNotificationManager().notifyAsUser(null, 1006, new Notification.Builder(devicePolicyManagerService.mContext, SystemNotificationChannels.DEVICE_ADMIN).setSmallIcon(R.drawable.ic_signal_cellular_3_4_bar).setContentTitle(devicePolicyManagerService.getUpdatableString("Core.WORK_PROFILE_TELEPHONY_UNAVAILABLE_TITLE", 17043642, new Object[0])).setContentText(devicePolicyManagerService.getUpdatableString("Core.WORK_PROFILE_TELEPHONY_UNAVAILABLE_BODY", 17043641, new Object[0])).setStyle(new Notification.BigTextStyle().bigText(devicePolicyManagerService.getUpdatableString("Core.WORK_PROFILE_TELEPHONY_UNAVAILABLE_BODY", 17043641, new Object[0]))).addAction(build).addExtras(bundle).setOngoing(false).setShowWhen(true).setAutoCancel(true).build(), UserHandle.of(devicePolicyManagerService.getProfileParentId(userHandle.getIdentifier())));
    }

    /* renamed from: -$$Nest$mtriggerPolicyComplianceCheckIfNeeded, reason: not valid java name */
    public static void m424$$Nest$mtriggerPolicyComplianceCheckIfNeeded(int i, DevicePolicyManagerService devicePolicyManagerService, boolean z) {
        synchronized (devicePolicyManagerService.getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = devicePolicyManagerService.getProfileOwnerAdminLocked(i);
                if (profileOwnerAdminLocked == null) {
                    Slogf.wtf("DevicePolicyManager", "Profile owner not found for compliance check");
                    return;
                }
                if (z) {
                    Intent intent = new Intent("android.app.action.CHECK_POLICY_COMPLIANCE");
                    intent.setPackage(profileOwnerAdminLocked.info.getPackageName());
                    devicePolicyManagerService.mContext.startActivityAsUser(intent, UserHandle.of(i));
                } else if (profileOwnerAdminLocked.mProfileOffDeadline > 0) {
                    devicePolicyManagerService.sendAdminCommandLocked(profileOwnerAdminLocked, "android.app.action.COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED", null, null, true);
                }
            } finally {
            }
        }
    }

    static {
        long millis = TimeUnit.DAYS.toMillis(1L);
        MS_PER_DAY = millis;
        EXPIRATION_GRACE_PERIOD_MS = 5 * millis;
        MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD = 3 * millis;
        MANAGED_PROFILE_OFF_WARNING_PERIOD = millis;
        DELEGATIONS = new String[]{"delegation-cert-install", "delegation-app-restrictions", "delegation-block-uninstall", "delegation-enable-system-app", "delegation-keep-uninstalled-packages", "delegation-package-access", "delegation-permission-grant", "delegation-install-existing-package", "delegation-keep-uninstalled-packages", "delegation-network-logging", "delegation-security-logging", "delegation-cert-selection"};
        DEVICE_OWNER_OR_MANAGED_PROFILE_OWNER_DELEGATIONS = Arrays.asList("delegation-network-logging");
        DEVICE_OWNER_OR_ORGANIZATION_OWNED_MANAGED_PROFILE_OWNER_DELEGATIONS = Arrays.asList("delegation-security-logging");
        EXCLUSIVE_DELEGATIONS = Arrays.asList("delegation-network-logging", "delegation-security-logging", "delegation-cert-selection");
        ArraySet arraySet = new ArraySet();
        SECURE_SETTINGS_ALLOWLIST = arraySet;
        arraySet.add("default_input_method");
        arraySet.add("skip_first_use_hints");
        arraySet.add("install_non_market_apps");
        ArraySet arraySet2 = new ArraySet();
        SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST = arraySet2;
        arraySet2.addAll((Collection) arraySet);
        arraySet2.add("location_mode");
        ArraySet arraySet3 = new ArraySet();
        GLOBAL_SETTINGS_ALLOWLIST = arraySet3;
        arraySet3.add("adb_enabled");
        arraySet3.add("adb_wifi_enabled");
        arraySet3.add("auto_time");
        arraySet3.add("auto_time_zone");
        arraySet3.add("data_roaming");
        arraySet3.add("usb_mass_storage_enabled");
        arraySet3.add("wifi_sleep_policy");
        arraySet3.add("stay_on_while_plugged_in");
        arraySet3.add("wifi_device_owner_configs_lockdown");
        arraySet3.add("private_dns_mode");
        arraySet3.add("private_dns_specifier");
        ArraySet arraySet4 = new ArraySet();
        GLOBAL_SETTINGS_DEPRECATED = arraySet4;
        arraySet4.add("bluetooth_on");
        arraySet4.add("development_settings_enabled");
        arraySet4.add("mode_ringer");
        arraySet4.add("network_preference");
        arraySet4.add("wifi_on");
        ArraySet arraySet5 = new ArraySet();
        SYSTEM_SETTINGS_ALLOWLIST = arraySet5;
        arraySet5.add("screen_brightness");
        arraySet5.add("screen_brightness_mode");
        arraySet5.add("screen_off_timeout");
        ArraySet arraySet6 = new ArraySet();
        DA_DISALLOWED_POLICIES = arraySet6;
        arraySet6.add(8);
        arraySet6.add(9);
        arraySet6.add(6);
        arraySet6.add(0);
        MINIMUM_STRONG_AUTH_TIMEOUT_MS = TimeUnit.HOURS.toMillis(1L);
        ArrayMap arrayMap = new ArrayMap();
        APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS = arrayMap;
        arrayMap.put(0, "android:system_exempt_from_suspension");
        arrayMap.put(1, "android:system_exempt_from_dismissible_notifications");
        arrayMap.put(2, "android:system_exempt_from_activity_bg_start_restriction");
        arrayMap.put(3, "android:system_exempt_from_hibernation");
        arrayMap.put(4, "android:system_exempt_from_power_restrictions");
        FRP_PROTECTED_PACKAGES = Arrays.asList("com.google.android.setupwizard", "com.sec.android.app.SecSetupWizard", "com.google.android.gms", "com.sec.android.app.setupwizard");
        USER_RESTRICTION_PERMISSIONS = new HashMap();
        SENSOR_PERMISSIONS = new ArrayList();
        DEFAULT_DEVICE_OWNER_PERMISSIONS = List.of((Object[]) new String[]{"android.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT", "android.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS", "android.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL", "android.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL", "android.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE", "android.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL", "android.permission.MANAGE_DEVICE_POLICY_APP_RESTRICTIONS", "android.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT", "android.permission.MANAGE_DEVICE_POLICY_AUTOFILL", "android.permission.MANAGE_DEVICE_POLICY_BLUETOOTH", "android.permission.MANAGE_DEVICE_POLICY_CALLS", "android.permission.MANAGE_DEVICE_POLICY_CAMERA", "android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES", "android.permission.MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE", "android.permission.MANAGE_DEVICE_POLICY_CONTENT_PROTECTION", "android.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES", "android.permission.MANAGE_DEVICE_POLICY_DEFAULT_SMS", "android.permission.MANAGE_DEVICE_POLICY_DISPLAY", "android.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET", "android.permission.MANAGE_DEVICE_POLICY_FUN", "android.permission.MANAGE_DEVICE_POLICY_INPUT_METHODS", "android.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES", "android.permission.MANAGE_DEVICE_POLICY_KEYGUARD", "android.permission.MANAGE_DEVICE_POLICY_LOCALE", "android.permission.MANAGE_DEVICE_POLICY_LOCATION", "android.permission.MANAGE_DEVICE_POLICY_LOCK", "android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", "android.permission.MANAGE_DEVICE_POLICY_LOCK_TASK", "android.permission.MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS", "android.permission.MANAGE_DEVICE_POLICY_MICROPHONE", "android.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK", "android.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS", "android.permission.MANAGE_DEVICE_POLICY_MTE", "android.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION", "android.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY", "android.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE", "android.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA", "android.permission.MANAGE_DEVICE_POLICY_PRINTING", "android.permission.MANAGE_DEVICE_POLICY_PROFILES", "android.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION", "android.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD", "android.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS", "android.permission.MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS", "android.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT", "android.permission.MANAGE_DEVICE_POLICY_SCREEN_CAPTURE", "android.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT", "android.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING", "android.permission.MANAGE_DEVICE_POLICY_SMS", "android.permission.MANAGE_DEVICE_POLICY_STATUS_BAR", "android.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE", "android.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS", "android.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES", "android.permission.MANAGE_DEVICE_POLICY_TIME", "android.permission.MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING", "android.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER", "android.permission.MANAGE_DEVICE_POLICY_VPN", "android.permission.MANAGE_DEVICE_POLICY_WALLPAPER", "android.permission.MANAGE_DEVICE_POLICY_WIFI", "android.permission.MANAGE_DEVICE_POLICY_WINDOWS", "android.permission.MANAGE_DEVICE_POLICY_WIPE_DATA", "android.permission.SET_TIME", "android.permission.SET_TIME_ZONE", "android.permission.MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES"});
        FINANCED_DEVICE_OWNER_PERMISSIONS = List.of((Object[]) new String[]{"android.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS", "android.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL", "android.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL", "android.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL", "android.permission.MANAGE_DEVICE_POLICY_CALLS", "android.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES", "android.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET", "android.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES", "android.permission.MANAGE_DEVICE_POLICY_KEYGUARD", "android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", "android.permission.MANAGE_DEVICE_POLICY_LOCK_TASK", "android.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS", "android.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY", "android.permission.MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS", "android.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT", "android.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE", "android.permission.MANAGE_DEVICE_POLICY_TIME", "android.permission.MANAGE_DEVICE_POLICY_WIPE_DATA"});
        PROFILE_OWNER_PERMISSIONS = List.of((Object[]) new String[]{"android.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT", "android.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL", "android.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL", "android.permission.MANAGE_DEVICE_POLICY_APP_RESTRICTIONS", "android.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT", "android.permission.MANAGE_DEVICE_POLICY_AUTOFILL", "android.permission.MANAGE_DEVICE_POLICY_BLUETOOTH", "android.permission.MANAGE_DEVICE_POLICY_CALLS", "android.permission.MANAGE_DEVICE_POLICY_CAMERA", "android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES", "android.permission.MANAGE_DEVICE_POLICY_CONTENT_PROTECTION", "android.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES", "android.permission.MANAGE_DEVICE_POLICY_DISPLAY", "android.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET", "android.permission.MANAGE_DEVICE_POLICY_INPUT_METHODS", "android.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES", "android.permission.MANAGE_DEVICE_POLICY_KEYGUARD", "android.permission.MANAGE_DEVICE_POLICY_LOCALE", "android.permission.MANAGE_DEVICE_POLICY_LOCATION", "android.permission.MANAGE_DEVICE_POLICY_LOCK", "android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", "android.permission.MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS", "android.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION", "android.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY", "android.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE", "android.permission.MANAGE_DEVICE_POLICY_PRINTING", "android.permission.MANAGE_DEVICE_POLICY_PROFILES", "android.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION", "android.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD", "android.permission.MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS", "android.permission.MANAGE_DEVICE_POLICY_SCREEN_CAPTURE", "android.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT", "android.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE", "android.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS", "android.permission.MANAGE_DEVICE_POLICY_TIME", "android.permission.MANAGE_DEVICE_POLICY_VPN", "android.permission.MANAGE_DEVICE_POLICY_WIPE_DATA", "android.permission.MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES"});
        ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS = List.of((Object[]) new String[]{"android.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS", "android.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE", "android.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL", "android.permission.MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE", "android.permission.MANAGE_DEVICE_POLICY_DEFAULT_SMS", "android.permission.MANAGE_DEVICE_POLICY_LOCALE", "android.permission.MANAGE_DEVICE_POLICY_MICROPHONE", "android.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK", "android.permission.MANAGE_DEVICE_POLICY_MTE", "android.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION", "android.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA", "android.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS", "android.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT", "android.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING", "android.permission.MANAGE_DEVICE_POLICY_SMS", "android.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES", "android.permission.MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING", "android.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER", "android.permission.MANAGE_DEVICE_POLICY_WIFI", "android.permission.SET_TIME", "android.permission.SET_TIME_ZONE"});
        ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS = List.of((Object[]) new String[]{"android.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE", "android.permission.MANAGE_DEVICE_POLICY_DISPLAY", "android.permission.MANAGE_DEVICE_POLICY_FUN", "android.permission.MANAGE_DEVICE_POLICY_LOCK_TASK", "android.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK", "android.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS", "android.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA", "android.permission.MANAGE_DEVICE_POLICY_PRINTING", "android.permission.MANAGE_DEVICE_POLICY_PROFILES", "android.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION", "android.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT", "android.permission.MANAGE_DEVICE_POLICY_SMS", "android.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS", "android.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER", "android.permission.MANAGE_DEVICE_POLICY_WINDOWS", "android.permission.SET_TIME", "android.permission.SET_TIME_ZONE"});
        ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS = List.of("android.permission.MANAGE_DEVICE_POLICY_LOCK_TASK");
        ADDITIONAL_AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS = List.of("android.permission.MANAGE_DEVICE_POLICY_STATUS_BAR");
        PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS = new ArrayList();
        PROFILE_OWNER_ON_USER_0_PERMISSIONS = new ArrayList();
        AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS = new ArrayList();
        PROFILE_OWNER_ON_USER_PERMISSIONS = new ArrayList();
        DPC_PERMISSIONS = new HashMap();
        DELEGATE_SCOPES = new HashMap();
        CROSS_USER_PERMISSIONS = new HashMap();
    }

    /* JADX WARN: Removed duplicated region for block: B:14:0x080a  */
    /* JADX WARN: Removed duplicated region for block: B:18:0x0b2a  */
    /* JADX WARN: Removed duplicated region for block: B:21:0x0b34  */
    /* JADX WARN: Removed duplicated region for block: B:45:0x0c47  */
    /* JADX WARN: Removed duplicated region for block: B:48:0x0c4a A[SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:68:0x0825  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public DevicePolicyManagerService(com.android.server.devicepolicy.DevicePolicyManagerService.Injector r32, com.android.server.devicepolicy.PolicyPathProvider r33) {
        /*
            Method dump skipped, instructions count: 3187
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.<init>(com.android.server.devicepolicy.DevicePolicyManagerService$Injector, com.android.server.devicepolicy.PolicyPathProvider):void");
    }

    public static void append(StringBuilder sb, ComponentName componentName) {
        sb.append(" (");
        sb.append(componentName.flattenToShortString());
        sb.append(')');
    }

    public static boolean canUsbDataSignalingBeDisabledInternal(Context context) {
        return ((Boolean) Binder.withCleanCallingIdentity(new DevicePolicyManagerService$$ExternalSyntheticLambda4(1, context))).booleanValue();
    }

    public static void checkActiveAdminPrecondition(ComponentName componentName, DeviceAdminInfo deviceAdminInfo, DevicePolicyData devicePolicyData) {
        if (deviceAdminInfo == null) {
            throw new IllegalArgumentException(AmbientContextManagerPerUserService$$ExternalSyntheticOutline0.m(componentName, "Bad admin: "));
        }
        if (!deviceAdminInfo.getActivityInfo().applicationInfo.isInternal()) {
            throw new IllegalArgumentException(AmbientContextManagerPerUserService$$ExternalSyntheticOutline0.m(componentName, "Only apps in internal storage can be active admin: "));
        }
        if (deviceAdminInfo.getActivityInfo().applicationInfo.isInstantApp()) {
            throw new IllegalArgumentException(AmbientContextManagerPerUserService$$ExternalSyntheticOutline0.m(componentName, "Instant apps cannot be device admins: "));
        }
        if (devicePolicyData.mRemovingAdmins.contains(componentName)) {
            throw new IllegalArgumentException("Trying to set an admin which is being removed");
        }
    }

    public static boolean containsAlias(AppUriAuthenticationPolicy appUriAuthenticationPolicy, String str) {
        Iterator<Map.Entry<String, Map<Uri, String>>> it = appUriAuthenticationPolicy.getAppAndUriMappings().entrySet().iterator();
        while (it.hasNext()) {
            Iterator<Map.Entry<Uri, String>> it2 = it.next().getValue().entrySet().iterator();
            while (it2.hasNext()) {
                if (it2.next().getValue().equals(str)) {
                    return true;
                }
            }
        }
        return false;
    }

    public static Intent createShowAdminSupportIntent(int i) {
        Intent intent = new Intent("android.settings.SHOW_ADMIN_SUPPORT_DETAILS");
        intent.putExtra("android.intent.extra.USER_ID", i);
        intent.setFlags(268435456);
        return intent;
    }

    public static void dumpApps(IndentingPrintWriter indentingPrintWriter, String str, List list) {
        if (list == null || list.isEmpty()) {
            indentingPrintWriter.printf("%s: empty\n", new Object[]{str});
            return;
        }
        int size = list.size();
        indentingPrintWriter.printf("%s: %d app%s\n", new Object[]{str, Integer.valueOf(size), size == 1 ? "" : "s"});
        indentingPrintWriter.increaseIndent();
        for (int i = 0; i < size; i++) {
            indentingPrintWriter.printf("%d: %s\n", new Object[]{Integer.valueOf(i), list.get(i)});
        }
        indentingPrintWriter.decreaseIndent();
    }

    public static void dumpApps(IndentingPrintWriter indentingPrintWriter, String str, String[] strArr) {
        dumpApps(indentingPrintWriter, str, Arrays.asList(strArr));
    }

    public static long getMaximumTimeToLockPolicyFromAdmins(List list) {
        Iterator it = ((ArrayList) list).iterator();
        long j = Long.MAX_VALUE;
        while (it.hasNext()) {
            long j2 = ((ActiveAdmin) it.next()).maximumTimeToUnlock;
            if (j2 > 0 && j2 < j) {
                j = j2;
            }
        }
        return j;
    }

    public static boolean isAdb(CallerIdentity callerIdentity) {
        return UserHandle.isSameApp(callerIdentity.mUid, 2000) || UserHandle.isSameApp(callerIdentity.mUid, 0);
    }

    public static boolean isPermissionCheckFlagEnabled() {
        return DeviceConfig.getBoolean("device_policy_manager", "enable_permission_based_access", false);
    }

    public static boolean isSystemApp(IPackageManager iPackageManager, String str, int i) {
        ApplicationInfo applicationInfo = iPackageManager.getApplicationInfo(str, 8192L, i);
        if (applicationInfo != null) {
            return (applicationInfo.flags & 1) != 0;
        }
        throw new IllegalArgumentException(XmlUtils$$ExternalSyntheticOutline0.m("The application ", str, " is not present on this device"));
    }

    public static boolean isSystemUid(CallerIdentity callerIdentity) {
        return UserHandle.isSameApp(callerIdentity.mUid, 1000);
    }

    public static List listPolicyExemptAppsUnchecked(Context context) {
        String[] stringArray = context.getResources().getStringArray(17236462);
        String[] stringArray2 = context.getResources().getStringArray(17236483);
        ArraySet arraySet = new ArraySet(stringArray.length + stringArray2.length);
        for (String str : stringArray) {
            arraySet.add(str);
        }
        for (String str2 : stringArray2) {
            arraySet.add(str2);
        }
        return new ArrayList(arraySet);
    }

    public static void logCopyAccountStatus(int i, String str) {
        DevicePolicyEventLogger.createEvent(193).setInt(i).setStrings(new String[]{str}).write();
    }

    public static void logEventDuration(int i, String str, long j) {
        DevicePolicyEventLogger.createEvent(i).setTimePeriod(SystemClock.elapsedRealtime() - j).setStrings(new String[]{str}).write();
    }

    public static void logGenerateKeyPairFailure(CallerIdentity callerIdentity, boolean z) {
        if (z) {
            Bundle bundle = new Bundle();
            bundle.putInt("userId", UserHandle.getUserId(callerIdentity.mUid));
            DevicePolicyEventLogger.createEvent(185).setStrings(new String[]{callerIdentity.mPackageName}).setKnoxBundleValue(bundle).write();
        }
    }

    public static void logInstallKeyPairFailure(CallerIdentity callerIdentity, boolean z) {
        if (z) {
            Bundle bundle = new Bundle();
            bundle.putInt("userId", UserHandle.getUserId(callerIdentity.mUid));
            DevicePolicyEventLogger.createEvent(184).setStrings(new String[]{callerIdentity.mPackageName}).setKnoxBundleValue(bundle).write();
        }
    }

    public static void logMissingFeatureAction(String str) {
        Slogf.w("DevicePolicyManager", str + " because device does not have the android.software.device_admin feature.");
    }

    public static void logStackTrace(String str) {
        try {
            StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
            StringBuilder sb = new StringBuilder();
            for (StackTraceElement stackTraceElement : stackTrace) {
                String methodName = stackTraceElement.getMethodName();
                if (methodName != null && !methodName.equals("getThreadStackTrace") && !methodName.equals("getStackTrace") && !methodName.equals("logStackTrace")) {
                    sb.append(stackTraceElement.getMethodName() + ":" + stackTraceElement.getLineNumber() + "\n");
                }
            }
            Slogf.d("DevicePolicyManager", "StackTrace for " + str + ": \n" + ((Object) sb));
        } catch (Exception unused) {
            Slogf.d("DevicePolicyManager", "Unable to get stacktrace");
        }
    }

    public static void logUserRestrictionCall(String str, boolean z, boolean z2, CallerIdentity callerIdentity) {
        DevicePolicyEventLogger.createEvent(z ? 12 : 13).setAdmin(callerIdentity.mComponentName).setStrings(new String[]{str, z2 ? "calledFromParent" : "notCalledFromParent"}).write();
        if (SecurityLog.isLoggingEnabled()) {
            SecurityLog.writeEvent(z ? 210027 : 210028, new Object[]{callerIdentity.mPackageName, Integer.valueOf(UserHandle.getUserId(callerIdentity.mUid)), str});
        }
        Slogf.i("DevicePolicyManager", "Changing user restriction %s to: %b caller: %s", str, Boolean.valueOf(z), callerIdentity.toString());
    }

    public static int[] translateIdAttestationFlags(int i) {
        HashMap hashMap = new HashMap();
        hashMap.put(2, 1);
        hashMap.put(4, 2);
        hashMap.put(8, 3);
        hashMap.put(16, 4);
        int bitCount = Integer.bitCount(i);
        if (bitCount == 0) {
            return null;
        }
        if ((i & 1) != 0) {
            bitCount--;
            i &= -2;
        }
        int[] iArr = new int[bitCount];
        int i2 = 0;
        for (Integer num : hashMap.keySet()) {
            if ((num.intValue() & i) != 0) {
                iArr[i2] = ((Integer) hashMap.get(num)).intValue();
                i2++;
            }
        }
        return iArr;
    }

    public static void updateUsbDataSignal(Context context, boolean z) {
        if (canUsbDataSignalingBeDisabledInternal(context) && !((Boolean) Binder.withCleanCallingIdentity(new DevicePolicyManagerService$$ExternalSyntheticLambda12(context, 1, z))).booleanValue()) {
            Slogf.w("DevicePolicyManager", "Failed to set usb data signaling state");
        }
    }

    public static void validateQualityConstant(int i) {
        if (i != 0 && i != 32768 && i != 65536 && i != 131072 && i != 196608 && i != 262144 && i != 327680 && i != 393216 && i != 524288) {
            throw new IllegalArgumentException(AudioChannelMask$$ExternalSyntheticOutline0.m(new StringBuilder("Invalid quality constant: 0x"), i));
        }
    }

    public final void acknowledgeDeviceCompliant() {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        enforceUserUnlocked(UserHandle.getUserId(callerIdentity.mUid));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                if (profileOwnerLocked.mProfileOffDeadline > 0) {
                    profileOwnerLocked.mProfileOffDeadline = 0L;
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void acknowledgeNewUserDisclaimer(int i) {
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS"));
        setShowNewUserDisclaimer(i, "acked");
    }

    public final void addCrossProfileIntentFilter(ComponentName componentName, String str, IntentFilter intentFilter, int i) {
        String[] strArr;
        UserInfo profileParent;
        UserInfo userInfo;
        CallerIdentity callerIdentity = isPermissionCheckFlagEnabled() ? getCallerIdentity(componentName, str) : getCallerIdentity(componentName);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        if (isPermissionCheckFlagEnabled()) {
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION", callerIdentity.mPackageName, userId);
        } else {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        }
        synchronized (getLockObject()) {
            this.mInjector.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                try {
                    profileParent = this.mUserManager.getProfileParent(userId);
                } catch (RemoteException e) {
                    Slogf.wtf("DevicePolicyManager", "Error adding cross profile intent filter", e);
                    this.mInjector.getClass();
                }
                if (profileParent == null) {
                    Slogf.e("DevicePolicyManager", "Cannot call addCrossProfileIntentFilter if there is no parent");
                    return;
                }
                if ((i & 1) != 0) {
                    userInfo = profileParent;
                    this.mIPackageManager.addCrossProfileIntentFilter(intentFilter, componentName.getPackageName(), userId, profileParent.id, 0);
                } else {
                    userInfo = profileParent;
                }
                if ((i & 2) != 0) {
                    this.mIPackageManager.addCrossProfileIntentFilter(intentFilter, componentName.getPackageName(), userInfo.id, userId, 0);
                }
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                DevicePolicyEventLogger admin = DevicePolicyEventLogger.createEvent(48).setAdmin(callerIdentity.mPackageName);
                if (intentFilter == null) {
                    strArr = null;
                } else {
                    int countActions = intentFilter.countActions();
                    String[] strArr2 = new String[countActions];
                    for (int i2 = 0; i2 < countActions; i2++) {
                        strArr2[i2] = intentFilter.getAction(i2);
                    }
                    strArr = strArr2;
                }
                admin.setStrings(strArr).setInt(i).write();
            } finally {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
            }
        }
    }

    public final boolean addCrossProfileWidgetProvider(ComponentName componentName, String str, String str2) {
        ActiveAdmin profileOwnerLocked;
        ActiveAdmin activeAdmin;
        ArrayList arrayList;
        CallerIdentity callerIdentity = isPermissionCheckFlagEnabled() ? getCallerIdentity(componentName, str) : getCallerIdentity(componentName);
        if (isPermissionCheckFlagEnabled()) {
            activeAdmin = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION", callerIdentity.mPackageName).mActiveAdmin;
        } else {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
            }
            activeAdmin = profileOwnerLocked;
        }
        synchronized (getLockObject()) {
            try {
                if (activeAdmin.crossProfileWidgetProviders == null) {
                    activeAdmin.crossProfileWidgetProviders = new ArrayList();
                }
                ArrayList arrayList2 = (ArrayList) activeAdmin.crossProfileWidgetProviders;
                if (arrayList2.contains(str2)) {
                    arrayList = null;
                } else {
                    arrayList2.add(str2);
                    arrayList = new ArrayList(arrayList2);
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger.createEvent(49).setAdmin(callerIdentity.mPackageName).write();
        if (arrayList == null) {
            return false;
        }
        LocalService.m425$$Nest$mnotifyCrossProfileProvidersChanged(this.mLocalService, UserHandle.getUserId(callerIdentity.mUid), arrayList);
        return true;
    }

    public final int addOverrideApn(ComponentName componentName, ApnSetting apnSetting) {
        if (this.mHasFeature && (this.mHasTelephonyFeature || this.mHasTelephonyDataFeature)) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Objects.requireNonNull(apnSetting, "ApnSetting is null in addOverrideApn");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            if (apnSetting.getApnTypeBitmask() == 16384) {
                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isManagedProfileOwner(callerIdentity));
            } else {
                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
            }
            TelephonyManager telephonyManager = (TelephonyManager) this.mContext.getSystemService(TelephonyManager.class);
            if (telephonyManager != null) {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda153 devicePolicyManagerService$$ExternalSyntheticLambda153 = new DevicePolicyManagerService$$ExternalSyntheticLambda153(this, telephonyManager, apnSetting, 3);
                injector.getClass();
                return ((Integer) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda153)).intValue();
            }
            Slogf.w("DevicePolicyManager", "TelephonyManager is null when trying to add override apn");
        }
        return -1;
    }

    public final void addPersistentPreferredActivity(ComponentName componentName, String str, IntentFilter intentFilter, ComponentName componentName2) {
        EnforcingAdmin enforcingAdminForCaller;
        String[] strArr;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        String str2 = callerIdentity.mPackageName;
        if (componentName == null) {
            enforcingAdminForCaller = enforcePermissionAndGetEnforcingAdmin(userId, componentName, "android.permission.MANAGE_DEVICE_POLICY_LOCK_TASK", str2);
        } else {
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity) || isFinancedDeviceOwner(callerIdentity));
            enforcingAdminForCaller = getEnforcingAdminForCaller(componentName, str);
        }
        EnforcingAdmin enforcingAdmin = enforcingAdminForCaller;
        if (isPackageInstalledForUser(userId, componentName2.getPackageName())) {
            this.mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(intentFilter), enforcingAdmin, new ComponentNamePolicyValue(componentName2), userId, false);
            String packageName = componentName2.getPackageName();
            DevicePolicyEventLogger admin = DevicePolicyEventLogger.createEvent(52).setAdmin(str2);
            if (intentFilter == null) {
                strArr = null;
            } else {
                int countActions = intentFilter.countActions();
                String[] strArr2 = new String[countActions];
                for (int i = 0; i < countActions; i++) {
                    strArr2[i] = intentFilter.getAction(i);
                }
                strArr = strArr2;
            }
            admin.setStrings(packageName, strArr).write();
        }
    }

    /* JADX WARN: Type inference failed for: r3v1, types: [com.android.server.devicepolicy.DevicePolicyManagerService$8] */
    public final void applyManagedSubscriptionsPolicyIfRequired() {
        final int organizationOwnedProfileUserId = getOrganizationOwnedProfileUserId();
        if (organizationOwnedProfileUserId != -10000) {
            unregisterOnSubscriptionsChangedListener();
            int policyType = getManagedSubscriptionsPolicy().getPolicyType();
            if (policyType == 0) {
                clearManagedSubscriptionsPolicy();
                return;
            }
            if (policyType == 1) {
                synchronized (this.mSubscriptionsChangedListenerLock) {
                    try {
                        if (this.mSubscriptionsChangedListener != null) {
                            return;
                        }
                        final SubscriptionManager subscriptionManager = (SubscriptionManager) this.mContext.getSystemService(SubscriptionManager.class);
                        this.mSubscriptionsChangedListener = new SubscriptionManager.OnSubscriptionsChangedListener(this.mHandler.getLooper()) { // from class: com.android.server.devicepolicy.DevicePolicyManagerService.8
                            @Override // android.telephony.SubscriptionManager.OnSubscriptionsChangedListener
                            public final void onSubscriptionsChanged() {
                                int i;
                                DevicePolicyManagerService.this.mInjector.getClass();
                                long clearCallingIdentity = Binder.clearCallingIdentity();
                                try {
                                    int[] activeSubscriptionIdList = subscriptionManager.getActiveSubscriptionIdList(false);
                                    int length = activeSubscriptionIdList.length;
                                    while (i < length) {
                                        int i2 = activeSubscriptionIdList[i];
                                        UserHandle subscriptionUserHandle = subscriptionManager.getSubscriptionUserHandle(i2);
                                        i = (subscriptionUserHandle != null && subscriptionUserHandle.getIdentifier() == organizationOwnedProfileUserId) ? i + 1 : 0;
                                        subscriptionManager.setSubscriptionUserHandle(i2, UserHandle.of(organizationOwnedProfileUserId));
                                    }
                                    DevicePolicyManagerService.this.mInjector.getClass();
                                    Binder.restoreCallingIdentity(clearCallingIdentity);
                                } catch (Throwable th) {
                                    DevicePolicyManagerService.this.mInjector.getClass();
                                    Binder.restoreCallingIdentity(clearCallingIdentity);
                                    throw th;
                                }
                            }
                        };
                        this.mInjector.getClass();
                        long clearCallingIdentity = Binder.clearCallingIdentity();
                        try {
                            Handler handler = this.mHandler;
                            Objects.requireNonNull(handler);
                            subscriptionManager.addOnSubscriptionsChangedListener(new ExtendedEthernetServiceImpl$1$$ExternalSyntheticLambda1(handler), this.mSubscriptionsChangedListener);
                        } finally {
                            this.mInjector.getClass();
                            Binder.restoreCallingIdentity(clearCallingIdentity);
                        }
                    } finally {
                    }
                }
            }
        }
    }

    public final void applyProfileRestrictionsIfDeviceOwnerLocked() {
        if (this.mOwners.getDeviceOwnerUserId() == -10000) {
            return;
        }
        Iterator it = this.mUserManager.getUsers().iterator();
        while (it.hasNext()) {
            UserHandle userHandle = ((UserInfo) it.next()).getUserHandle();
            if (!this.mUserManager.hasUserRestriction("no_add_clone_profile", userHandle)) {
                this.mUserManager.setUserRestriction("no_add_clone_profile", true, userHandle);
            }
            if (!this.mUserManager.hasUserRestriction("no_add_private_profile", userHandle)) {
                this.mUserManager.setUserRestriction("no_add_private_profile", true, userHandle);
            }
            if (!this.mUserManager.hasUserRestriction("no_add_managed_profile", userHandle)) {
                this.mUserManager.setUserRestriction("no_add_managed_profile", true, userHandle);
            }
        }
    }

    public final boolean approveCaCert(String str, int i, boolean z) {
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        synchronized (getLockObject()) {
            try {
                ArraySet arraySet = getUserData(i).mAcceptedCaCertificates;
                if (!(z ? arraySet.add(str) : arraySet.remove(str))) {
                    return false;
                }
                saveSettingsLocked(i, false, false, false);
                CertificateMonitor certificateMonitor = this.mCertificateMonitor;
                certificateMonitor.getClass();
                certificateMonitor.mHandler.post(new CertificateMonitor$$ExternalSyntheticLambda0(certificateMonitor, i));
                return true;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean areAllUsersAffiliatedWithDeviceLocked() {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 8);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33)).booleanValue();
    }

    public final boolean bindDeviceAdminServiceAsUser(ComponentName componentName, IApplicationThread iApplicationThread, IBinder iBinder, Intent intent, IServiceConnection iServiceConnection, long j, int i) {
        String deviceOwnerPackageName;
        if (!this.mHasFeature) {
            return false;
        }
        Objects.requireNonNull(componentName);
        Objects.requireNonNull(iApplicationThread);
        Objects.requireNonNull(intent);
        Preconditions.checkArgument((intent.getComponent() == null && intent.getPackage() == null) ? false : true, "Service intent must be explicit (with a package name or component): " + intent);
        Objects.requireNonNull(iServiceConnection);
        this.mInjector.getClass();
        Preconditions.checkArgument(Injector.userHandleGetCallingUserId() != i, "target user id must be different from the calling user id");
        if (!getBindDeviceAdminTargetUsers(componentName).contains(UserHandle.of(i))) {
            throw new SecurityException("Not allowed to bind to target user id");
        }
        synchronized (getLockObject()) {
            deviceOwnerPackageName = this.mOwners.getDeviceOwnerUserId() == i ? this.mOwners.getDeviceOwnerPackageName() : this.mOwners.getProfileOwnerPackage(i);
        }
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            if (createCrossUserServiceIntent(intent, deviceOwnerPackageName, i) == null) {
                return false;
            }
            this.mInjector.getClass();
            return ActivityManager.getService().bindService(iApplicationThread, iBinder, intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), iServiceConnection, j, this.mContext.getOpPackageName(), i) != 0;
        } catch (RemoteException unused) {
            return false;
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final void broadcastExplicitIntentToPackage(Intent intent, UserHandle userHandle, String str) {
        int identifier = userHandle.getIdentifier();
        if (str == null) {
            return;
        }
        Intent intent2 = new Intent(intent).setPackage(str);
        List queryBroadcastReceiversAsUser = this.mContext.getPackageManager().queryBroadcastReceiversAsUser(intent2, PackageManager.ResolveInfoFlags.of(2L), identifier);
        if (queryBroadcastReceiversAsUser.isEmpty()) {
            Slog.i("DevicePolicyManager", "Found no receivers to handle intent " + intent + " in package " + str);
            return;
        }
        Iterator it = queryBroadcastReceiversAsUser.iterator();
        while (it.hasNext()) {
            this.mContext.sendBroadcastAsUser(new Intent(intent2).setComponent(((ResolveInfo) it.next()).getComponentInfo().getComponentName()).addFlags(16777216), userHandle);
        }
    }

    public final void calculateHasIncompatibleAccounts() {
        if (this.calculateHasIncompatibleAccountsExecutor.getQueue().size() > 1) {
            return;
        }
        new CalculateHasIncompatibleAccountsTask().executeOnExecutor(this.calculateHasIncompatibleAccountsExecutor, new Void[0]);
    }

    public final boolean canAdminGrantSensorsPermissions() {
        if (this.mHasFeature) {
            return this.mPolicyCache.mCanGrantSensorsPermissions;
        }
        return false;
    }

    public final boolean canChooseCertificates(CallerIdentity callerIdentity) {
        return isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity) || isCallerDelegate(callerIdentity, "delegation-cert-selection");
    }

    public final boolean canDPCManagedUserUseLockTaskLocked(int i) {
        if (isUserAffiliatedWithDeviceLocked(i)) {
            return true;
        }
        return (this.mOwners.hasDeviceOwner() || getProfileOwnerAsUser(i) == null || isManagedProfile(i)) ? false : true;
    }

    public final boolean canManageCaCerts(CallerIdentity callerIdentity) {
        return (callerIdentity.hasAdminComponent() && (isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity))) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-cert-install")) || hasCallingOrSelfPermission("android.permission.MANAGE_CA_CERTIFICATES");
    }

    public final boolean canProfileOwnerResetPasswordWhenLocked(int i) {
        boolean z;
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can call canProfileOwnerResetPasswordWhenLocked");
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                DevicePolicyData userData = getUserData(i);
                if (profileOwnerAdminLocked != null && getEncryptionStatus() == 5) {
                    long j = userData.mPasswordTokenHandle;
                    if (j != 0) {
                        Injector injector = this.mInjector;
                        DevicePolicyManagerService$$ExternalSyntheticLambda23 devicePolicyManagerService$$ExternalSyntheticLambda23 = new DevicePolicyManagerService$$ExternalSyntheticLambda23(this, j, i, 0);
                        injector.getClass();
                        z = ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda23)).booleanValue();
                    } else {
                        z = false;
                    }
                    if (z) {
                        try {
                            ApplicationInfo applicationInfo = this.mIPackageManager.getApplicationInfo(profileOwnerAdminLocked.info.getPackageName(), 0L, i);
                            if (applicationInfo == null) {
                                Slogf.wtf("DevicePolicyManager", "Cannot find AppInfo for profile owner");
                                return false;
                            }
                            if (!applicationInfo.isEncryptionAware()) {
                                return false;
                            }
                            Slogf.d("DevicePolicyManager", "PO should be able to reset password from direct boot");
                            return true;
                        } catch (RemoteException e) {
                            Slogf.e("DevicePolicyManager", "Failed to query PO app info", e);
                            return false;
                        }
                    }
                }
                return false;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean canUsbDataSignalingBeDisabled() {
        return canUsbDataSignalingBeDisabledInternal(this.mContext);
    }

    public final boolean canUserBindToDeviceOwnerLocked(int i) {
        if (this.mOwners.hasDeviceOwner() && i != this.mOwners.getDeviceOwnerUserId() && this.mOwners.hasProfileOwner(i) && TextUtils.equals(this.mOwners.getDeviceOwnerPackageName(), this.mOwners.getProfileOwnerPackage(i))) {
            return isUserAffiliatedWithDeviceLocked(i);
        }
        return false;
    }

    public final boolean canWriteCredentialManagerPolicy(CallerIdentity callerIdentity) {
        return (isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid))) || isDefaultDeviceOwner(callerIdentity) || hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS");
    }

    public final void checkCanExecuteOrThrowUnsafe(int i) {
        DevicePolicySafetyChecker devicePolicySafetyChecker = this.mSafetyChecker;
        int unsafeOperationReason = devicePolicySafetyChecker == null ? -1 : devicePolicySafetyChecker.getUnsafeOperationReason(i);
        if (unsafeOperationReason == -1) {
            return;
        }
        DevicePolicySafetyChecker devicePolicySafetyChecker2 = this.mSafetyChecker;
        if (devicePolicySafetyChecker2 != null) {
            throw devicePolicySafetyChecker2.newUnsafeStateException(i, unsafeOperationReason);
        }
        throw new UnsafeStateException(i, unsafeOperationReason);
    }

    public final boolean checkDeviceIdentifierAccess(String str, int i, int i2) {
        ApplicationInfo applicationInfo;
        int i3 = getCallerIdentity(null, null).mUid;
        this.mInjector.getClass();
        int callingPid = Binder.getCallingPid();
        if (UserHandle.getAppId(i3) >= 10000 && (i3 != i2 || callingPid != i)) {
            String format = String.format("Calling uid %d, pid %d cannot check device identifier access for package %s (uid=%d, pid=%d)", Integer.valueOf(i3), Integer.valueOf(callingPid), str, Integer.valueOf(i2), Integer.valueOf(i));
            Slogf.w("DevicePolicyManager", format);
            throw new SecurityException(format);
        }
        try {
            applicationInfo = this.mIPackageManager.getApplicationInfo(str, 0L, UserHandle.getUserId(i2));
        } catch (RemoteException e) {
            Slogf.e("DevicePolicyManager", e, "Exception caught obtaining appInfo for package %s", str);
        }
        if (applicationInfo == null) {
            Slogf.w("DevicePolicyManager", "appInfo could not be found for package %s", str);
            return false;
        }
        int i4 = applicationInfo.uid;
        if (i2 == i4) {
            if (this.mContext.checkPermission("android.permission.READ_PHONE_STATE", i, i2) == 0) {
                return hasDeviceIdAccessUnchecked(str, i2);
            }
            return false;
        }
        String format2 = String.format("Package %s (uid=%d) does not match provided uid %d", str, Integer.valueOf(i4), Integer.valueOf(i2));
        Slogf.w("DevicePolicyManager", format2);
        throw new SecurityException(format2);
    }

    public final int checkDeviceOwnerProvisioningPreConditionLocked(ComponentName componentName, int i, int i2, boolean z, boolean z2) {
        int i3;
        boolean z3;
        if (this.mOwners.hasDeviceOwner()) {
            return 1;
        }
        if (this.mOwners.hasProfileOwner(i)) {
            return 2;
        }
        if (!this.mUserManager.isUserRunning(new UserHandle(i))) {
            return 3;
        }
        this.mInjector.getClass();
        boolean isHeadlessSystemUserMode = UserManager.isHeadlessSystemUserMode();
        if (isHeadlessSystemUserMode) {
            if (componentName != null) {
                int headlessDeviceOwnerModeForDeviceAdmin = getHeadlessDeviceOwnerModeForDeviceAdmin(i, componentName);
                z3 = headlessDeviceOwnerModeForDeviceAdmin == 1;
                boolean z4 = headlessDeviceOwnerModeForDeviceAdmin == 2;
                if (!z3 && !z4) {
                    return 16;
                }
                if (Flags.headlessDeviceOwnerSingleUserEnabled() && z4) {
                    i3 = this.mUserManagerInternal.getMainUserId();
                    if (i3 == -10000) {
                        return 17;
                    }
                } else {
                    i3 = 0;
                }
            } else {
                i3 = 0;
                z3 = false;
            }
            if (z3 && i != 0) {
                Slogf.e("DevicePolicyManager", "In headless system user mode, device owner can only be set on headless system user.");
                return 7;
            }
        } else {
            i3 = 0;
            z3 = false;
        }
        if (!z) {
            if ((!isHeadlessSystemUserMode || z3) && i != 0) {
                return 7;
            }
            return hasUserSetupCompleted(i3) ? 4 : 0;
        }
        if (hasUserSetupCompleted(i3)) {
            if (nonTestNonPrecreatedUsersExist()) {
                return 5;
            }
            int currentForegroundUserId = getCurrentForegroundUserId();
            if (i2 != currentForegroundUserId) {
                this.mInjector.getClass();
                if (UserManager.isHeadlessSystemUserMode() && currentForegroundUserId == 0) {
                    Slogf.wtf("DevicePolicyManager", "In headless system user mode, current user cannot be system user when setting device owner");
                    return 10;
                }
            }
            if (z2) {
                return 6;
            }
        }
        return 0;
    }

    public final boolean checkPackagesInPermittedListOrSystem(int i, List list, List list2) {
        ApplicationInfo applicationInfo;
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = getUserInfo(i);
            if (userInfo.isManagedProfile()) {
                i = userInfo.profileGroupId;
            }
            Iterator it = list.iterator();
            while (it.hasNext()) {
                String str = (String) it.next();
                try {
                    applicationInfo = this.mIPackageManager.getApplicationInfo(str, 8192L, i);
                } catch (RemoteException e) {
                    Slogf.i("DevicePolicyManager", "Can't talk to package managed", e);
                }
                if (applicationInfo == null) {
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    return false;
                }
                if ((1 & applicationInfo.flags) != 0) {
                    continue;
                } else if (!list2.contains(str)) {
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    return false;
                }
            }
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            return true;
        } catch (Throwable th) {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            throw th;
        }
    }

    public final int checkProvisioningPrecondition(String str, String str2) {
        Objects.requireNonNull(str2, "packageName is null");
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            return checkProvisioningPreconditionSkipPermission(UserHandle.getUserId(callerIdentity.mUid), null, str, str2);
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    /* JADX WARN: Code restructure failed: missing block: B:65:0x01d4, code lost:
    
        if (getHeadlessDeviceOwnerModeForDeviceAdmin(r10, r11) == 1) goto L104;
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final int checkProvisioningPreconditionSkipPermission(int r10, android.content.ComponentName r11, java.lang.String r12, java.lang.String r13) {
        /*
            Method dump skipped, instructions count: 612
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.checkProvisioningPreconditionSkipPermission(int, android.content.ComponentName, java.lang.String, java.lang.String):int");
    }

    public final void choosePrivateKeyAlias(int i, Uri uri, String str, final IBinder iBinder) {
        final boolean z;
        final CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isSystemUid(callerIdentity), "Only the system can choose private key alias");
        ComponentName profileOwnerAsUser = getProfileOwnerAsUser(UserHandle.getUserId(callerIdentity.mUid));
        boolean isSystem = Flags.headlessSingleUserFixes() ? UserHandle.getUserId(callerIdentity.mUid) == getDeviceOwnerUserId() : UserHandle.getUserHandleForUid(callerIdentity.mUid).isSystem();
        if (profileOwnerAsUser == null && isSystem) {
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
                    if (deviceOwnerAdminLocked != null) {
                        profileOwnerAsUser = deviceOwnerAdminLocked.info.getComponent();
                    }
                } finally {
                }
            }
        }
        if (profileOwnerAsUser == null) {
            try {
                IKeyChainAliasCallback.Stub.asInterface(iBinder).alias((String) null);
                return;
            } catch (Exception e) {
                Slogf.e("DevicePolicyManager", "error while responding to callback", e);
                return;
            }
        }
        final Intent intent = new Intent("android.app.action.CHOOSE_PRIVATE_KEY_ALIAS");
        intent.putExtra("android.app.extra.CHOOSE_PRIVATE_KEY_SENDER_UID", i);
        intent.putExtra("android.app.extra.CHOOSE_PRIVATE_KEY_URI", uri);
        intent.putExtra("android.app.extra.CHOOSE_PRIVATE_KEY_ALIAS", str);
        intent.putExtra("android.app.extra.CHOOSE_PRIVATE_KEY_RESPONSE", iBinder);
        intent.addFlags(268435456);
        ComponentName resolveDelegateReceiver = resolveDelegateReceiver(UserHandle.getUserId(callerIdentity.mUid), "delegation-cert-selection", "android.app.action.CHOOSE_PRIVATE_KEY_ALIAS");
        if (resolveDelegateReceiver != null) {
            intent.setComponent(resolveDelegateReceiver);
            z = true;
        } else {
            intent.setComponent(profileOwnerAsUser);
            z = false;
        }
        Injector injector = this.mInjector;
        FunctionalUtils.ThrowingRunnable throwingRunnable = new FunctionalUtils.ThrowingRunnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda2
            public final void runOrThrow() {
                final DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                Intent intent2 = intent;
                CallerIdentity callerIdentity2 = callerIdentity;
                final IBinder iBinder2 = iBinder;
                boolean z2 = z;
                devicePolicyManagerService.mContext.sendOrderedBroadcastAsUser(intent2, UserHandle.getUserHandleForUid(callerIdentity2.mUid), null, new BroadcastReceiver() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService.5
                    @Override // android.content.BroadcastReceiver
                    public final void onReceive(Context context, Intent intent3) {
                        String resultData = getResultData();
                        DevicePolicyManagerService devicePolicyManagerService2 = DevicePolicyManagerService.this;
                        IBinder iBinder3 = iBinder2;
                        devicePolicyManagerService2.getClass();
                        try {
                            IKeyChainAliasCallback.Stub.asInterface(iBinder3).alias(resultData);
                        } catch (Exception e2) {
                            Slogf.e("DevicePolicyManager", "error while responding to callback", e2);
                        }
                    }
                }, null, -1, null, null);
                DevicePolicyEventLogger.createEvent(22).setAdmin(intent2.getComponent()).setBoolean(z2).write();
            }
        };
        injector.getClass();
        Binder.withCleanCallingIdentity(throwingRunnable);
    }

    public final void clearApplicationUserData(ComponentName componentName, String str, IPackageDataObserver iPackageDataObserver) {
        Injector injector;
        Objects.requireNonNull(componentName, "ComponentName is null");
        Objects.requireNonNull(str, "packageName is null");
        Objects.requireNonNull(iPackageDataObserver, "callback is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        checkCanExecuteOrThrowUnsafe(23);
        if (this.mInjector.settingsGlobalGetInt("device_provisioned") == 0 && FRP_PROTECTED_PACKAGES.contains(str)) {
            Log.i("DevicePolicyManager", "clearApplicationUserData blocked : SVE-2022-1517");
            return;
        }
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                ActivityManager.getService().clearApplicationUserData(str, false, iPackageDataObserver, UserHandle.getUserId(callerIdentity.mUid));
                injector = this.mInjector;
            } catch (RemoteException unused) {
                injector = this.mInjector;
            } catch (SecurityException e) {
                Slogf.w("DevicePolicyManager", "Not allowed to clear application user data for package ".concat(str), e);
                try {
                    iPackageDataObserver.onRemoveCompleted(str, false);
                } catch (RemoteException unused2) {
                }
                injector = this.mInjector;
            }
            injector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        } catch (Throwable th) {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            throw th;
        }
    }

    public final void clearCrossProfileIntentFilters(ComponentName componentName, String str) {
        UserInfo profileParent;
        CallerIdentity callerIdentity = isPermissionCheckFlagEnabled() ? getCallerIdentity(componentName, str) : getCallerIdentity(componentName);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        if (isPermissionCheckFlagEnabled()) {
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION", callerIdentity.mPackageName, userId);
        } else {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        }
        synchronized (getLockObject()) {
            this.mInjector.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                try {
                    profileParent = this.mUserManager.getProfileParent(userId);
                } catch (RemoteException e) {
                    Slogf.wtf("DevicePolicyManager", "Error clearing cross profile intent filters", e);
                    this.mInjector.getClass();
                }
                if (profileParent == null) {
                    Slogf.e("DevicePolicyManager", "Cannot call clearCrossProfileIntentFilter if there is no parent");
                    return;
                }
                this.mIPackageManager.clearCrossProfileIntentFilters(userId, componentName.getPackageName());
                this.mIPackageManager.clearCrossProfileIntentFilters(profileParent.id, componentName.getPackageName());
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
            } finally {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
            }
        }
    }

    public final void clearDeviceOwner(String str) {
        Objects.requireNonNull(str, "packageName is null");
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        synchronized (getLockObject()) {
            try {
                ComponentName deviceOwnerComponent = this.mOwners.getDeviceOwnerComponent();
                int deviceOwnerUserId = this.mOwners.getDeviceOwnerUserId();
                if (!this.mOwners.hasDeviceOwner() || !deviceOwnerComponent.getPackageName().equals(str) || deviceOwnerUserId != UserHandle.getUserId(callerIdentity.mUid)) {
                    throw new SecurityException("clearDeviceOwner can only be called by the device owner");
                }
                enforceUserUnlocked(deviceOwnerUserId);
                ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda42 devicePolicyManagerService$$ExternalSyntheticLambda42 = new DevicePolicyManagerService$$ExternalSyntheticLambda42(this, deviceOwnerAdminLocked, deviceOwnerUserId, deviceOwnerComponent, 0);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda42);
                Slogf.i("DevicePolicyManager", "Device owner removed: " + deviceOwnerComponent);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void clearDeviceOwnerLocked(int i, ActiveAdmin activeAdmin) {
        String deviceOwnerPackageName = this.mOwners.getDeviceOwnerPackageName();
        if (deviceOwnerPackageName != null) {
            this.mDeviceAdminServiceController.stopServiceForAdmin(i, deviceOwnerPackageName);
        }
        int i2 = 0;
        if (activeAdmin != null) {
            activeAdmin.disableCamera = false;
            activeAdmin.userRestrictions = null;
            ((ArraySet) activeAdmin.defaultEnabledRestrictionsAlreadySet).clear();
            activeAdmin.forceEphemeralUsers = false;
            activeAdmin.isNetworkLoggingEnabled = false;
            activeAdmin.requireAutoTime = false;
            this.mUserManagerInternal.setForceEphemeralUsers(false);
        }
        DevicePolicyData userData = getUserData(i);
        userData.mCurrentInputMethodSet = false;
        long j = userData.mPasswordTokenHandle;
        if (j != 0) {
            this.mLockPatternUtils.removeEscrowToken(j, i);
            userData.mPasswordTokenHandle = 0L;
        }
        saveSettingsLocked(i, false, false, false);
        this.mPolicyCache.onUserRemoved(i);
        DevicePolicyData userData2 = getUserData(0);
        userData2.mLastSecurityLogRetrievalTime = -1L;
        userData2.mLastBugReportRequestTime = -1L;
        userData2.mLastNetworkLogsRetrievalTime = -1L;
        saveSettingsLocked(0, false, false, false);
        clearUserPoliciesLocked(i);
        if (this.mHasTelephonyFeature || this.mHasTelephonyDataFeature) {
            ContentValues contentValues = new ContentValues();
            contentValues.put("enforced", Boolean.FALSE);
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda34 devicePolicyManagerService$$ExternalSyntheticLambda34 = new DevicePolicyManagerService$$ExternalSyntheticLambda34(0, this, contentValues);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda34);
            List overrideApnsUnchecked = getOverrideApnsUnchecked();
            for (int i3 = 0; i3 < overrideApnsUnchecked.size(); i3++) {
                removeOverrideApnUnchecked(((ApnSetting) overrideApnsUnchecked.get(i3)).getId());
            }
        }
        this.mBackgroundHandler.post(new DevicePolicyManagerService$$ExternalSyntheticLambda0(this, i, 0));
        Owners owners = this.mOwners;
        synchronized (owners.mData) {
            try {
                OwnersData ownersData = owners.mData;
                ownersData.mDeviceOwnerTypes.remove(ownersData.mDeviceOwner.packageName);
                OwnersData ownersData2 = owners.mData;
                ownersData2.mDeviceOwner = null;
                ownersData2.mDeviceOwnerUserId = -10000;
                if (DeviceConfig.getBoolean("device_policy_manager", "deprecate_usermanagerinternal_devicepolicy", true)) {
                    owners.mDeviceStateCache.mDeviceOwnerType.set(-1);
                } else {
                    owners.mUserManagerInternal.setDeviceManaged(false);
                }
                owners.notifyChangeLocked();
                owners.pushDeviceOwnerUidToActivityTaskManagerLocked();
            } catch (Throwable th) {
                throw th;
            }
        }
        this.mOwners.writeDeviceOwner();
        updateAdminCanGrantSensorsPermissionCache(i);
        UserHandle.of(i);
        for (int i4 : this.mUserManagerInternal.getUserIds()) {
            UserHandle of = UserHandle.of(i4);
            if (this.mUserManager.hasUserRestriction("no_add_user", of)) {
                this.mUserManager.setUserRestriction("no_add_user", false, of);
            }
            if (this.mUserManager.hasUserRestriction("no_add_managed_profile", of)) {
                this.mUserManager.setUserRestriction("no_add_managed_profile", false, of);
            }
            if (this.mUserManager.hasUserRestriction("no_add_clone_profile", of)) {
                this.mUserManager.setUserRestriction("no_add_clone_profile", false, of);
            }
            if (this.mUserManager.hasUserRestriction("no_add_private_profile", of)) {
                this.mUserManager.setUserRestriction("no_add_private_profile", false, of);
            }
        }
        this.mInjector.getClass();
        SecurityLog.setLoggingEnabledProperty(false);
        this.mSecurityLogMonitor.stop();
        setNetworkLoggingActiveInternal(false);
        deleteTransferOwnershipBundleLocked(i);
        toggleBackupServiceActive(0, true);
        Injector injector2 = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda29 devicePolicyManagerService$$ExternalSyntheticLambda29 = new DevicePolicyManagerService$$ExternalSyntheticLambda29(i2, 2, this);
        injector2.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda29);
        this.mDevicePolicyEngine.removePoliciesForAdmin(EnforcingAdmin.createEnterpriseEnforcingAdmin(activeAdmin.info.getComponent(), i, activeAdmin));
        this.mInjector.getClass();
    }

    public final void clearManagedProfileApnUnchecked() {
        if (this.mHasTelephonyFeature || this.mHasTelephonyDataFeature) {
            if (!((SystemServiceManager) LocalServices.getService(SystemServiceManager.class)).isBootCompleted()) {
                Slogf.i("DevicePolicyManager", "Skip clearing managed profile Apn before boot completed");
                return;
            }
            for (ApnSetting apnSetting : getOverrideApnsUnchecked()) {
                if (apnSetting.getApnTypeBitmask() == 16384) {
                    removeOverrideApnUnchecked(apnSetting.getId());
                }
            }
        }
    }

    public final void clearManagedSubscriptionsPolicy() {
        unregisterOnSubscriptionsChangedListener();
        SubscriptionManager subscriptionManager = (SubscriptionManager) this.mContext.getSystemService(SubscriptionManager.class);
        for (int i : subscriptionManager.getActiveSubscriptionIdList(false)) {
            subscriptionManager.setSubscriptionUserHandle(i, null);
        }
    }

    public final void clearOrgOwnedProfileOwnerDeviceWidePolicies(int i) {
        boolean z;
        Slogf.i("DevicePolicyManager", "Cleaning up device-wide policies left over from org-owned profile...");
        this.mLockPatternUtils.setDeviceOwnerInfo((String) null);
        this.mInjector.settingsGlobalPutInt("wifi_device_owner_configs_lockdown", 0);
        this.mInjector.getClass();
        if (SecurityLog.getLoggingEnabledProperty()) {
            this.mSecurityLogMonitor.stop();
            this.mInjector.getClass();
            SecurityLog.setLoggingEnabledProperty(false);
        }
        setNetworkLoggingActiveInternal(false);
        synchronized (getLockObject()) {
            z = this.mOwners.getSystemUpdatePolicy() != null;
            if (z) {
                Owners owners = this.mOwners;
                synchronized (owners.mData) {
                    owners.mData.mSystemUpdatePolicy = null;
                }
                this.mOwners.writeDeviceOwner();
            }
        }
        if (z) {
            this.mContext.sendBroadcastAsUser(new Intent("android.app.action.SYSTEM_UPDATE_POLICY_CHANGED"), UserHandle.SYSTEM);
        }
        suspendPersonalAppsInternal(i, getManagedUserId(i), false);
        int frpManagementAgentUid = getFrpManagementAgentUid();
        if (frpManagementAgentUid > 0) {
            this.mContext.sendBroadcastAsUser(new Intent("android.app.action.RESET_PROTECTION_POLICY_CHANGED").addFlags(285212672), UserHandle.getUserHandleForUid(frpManagementAgentUid), "android.permission.MANAGE_FACTORY_RESET_PROTECTION");
        }
        this.mLockSettingsInternal.refreshStrongAuthTimeout(i);
        clearManagedSubscriptionsPolicy();
        DevicePolicyCacheImpl devicePolicyCacheImpl = this.mPolicyCache;
        ArrayMap arrayMap = new ArrayMap();
        synchronized (devicePolicyCacheImpl.mLock) {
            devicePolicyCacheImpl.mLauncherShortcutOverrides = new ArrayMap(arrayMap);
        }
        updateTelephonyCrossProfileIntentFilters(i, -10000, false);
        Slogf.i("DevicePolicyManager", "Cleaning up device-wide policies done.");
    }

    public final void clearOrganizationIdForUser(int i) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        synchronized (getLockObject()) {
            ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(i);
            deviceOrProfileOwnerAdminLocked.mOrganizationId = null;
            deviceOrProfileOwnerAdminLocked.mEnrollmentSpecificId = null;
            saveSettingsLocked(i, false, false, false);
        }
    }

    public final void clearPackagePersistentPreferredActivities(ComponentName componentName, String str, String str2) {
        EnforcingAdmin enforcingAdminForCaller;
        Set<IntentFilterPolicyKey> set;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        if (componentName == null) {
            enforcingAdminForCaller = enforcePermissionAndGetEnforcingAdmin(userId, componentName, "android.permission.MANAGE_DEVICE_POLICY_LOCK_TASK", callerIdentity.mPackageName);
        } else {
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity) || isFinancedDeviceOwner(callerIdentity));
            enforcingAdminForCaller = getEnforcingAdminForCaller(componentName, str);
        }
        DevicePolicyEngine devicePolicyEngine = this.mDevicePolicyEngine;
        PolicyDefinition policyDefinition = PolicyDefinition.GENERIC_PERSISTENT_PREFERRED_ACTIVITY;
        devicePolicyEngine.getClass();
        Objects.requireNonNull(policyDefinition);
        synchronized (devicePolicyEngine.mLock) {
            try {
                if (!policyDefinition.isGlobalOnlyPolicy() && devicePolicyEngine.mLocalPolicies.contains(userId)) {
                    HashSet hashSet = new HashSet();
                    for (PolicyKey policyKey : ((Map) devicePolicyEngine.mLocalPolicies.get(userId)).keySet()) {
                        if (policyKey.hasSameIdentifierAs(policyDefinition.mPolicyKey) && ((PolicyState) ((Map) devicePolicyEngine.mLocalPolicies.get(userId)).get(policyKey)).getPoliciesSetByAdmins().containsKey(enforcingAdminForCaller)) {
                            hashSet.add(policyKey);
                        }
                    }
                }
                set = Set.of();
            } finally {
            }
        }
        for (IntentFilterPolicyKey intentFilterPolicyKey : set) {
            if (!(intentFilterPolicyKey instanceof IntentFilterPolicyKey)) {
                throw new IllegalStateException("PolicyKey for PERSISTENT_PREFERRED_ACTIVITY is notof type IntentFilterPolicyKey");
            }
            IntentFilter intentFilter = intentFilterPolicyKey.getIntentFilter();
            Objects.requireNonNull(intentFilter);
            ComponentName componentName2 = (ComponentName) this.mDevicePolicyEngine.getLocalPolicySetByAdmin(PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(intentFilter), enforcingAdminForCaller, userId);
            if (componentName2 != null && componentName2.getPackageName().equals(str2)) {
                this.mDevicePolicyEngine.removeLocalPolicy(PolicyDefinition.PERSISTENT_PREFERRED_ACTIVITY(intentFilter), enforcingAdminForCaller, userId);
            }
        }
    }

    public final void clearProfileOwner(ComponentName componentName) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            Preconditions.checkCallingUser(!isManagedProfile(userId));
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
            enforceUserUnlocked(userId);
            synchronized (getLockObject()) {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda42 devicePolicyManagerService$$ExternalSyntheticLambda42 = new DevicePolicyManagerService$$ExternalSyntheticLambda42(this, profileOwnerLocked, userId, componentName, 1);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda42);
                Slogf.i("DevicePolicyManager", "Profile owner " + componentName + " removed from user " + userId);
            }
        }
    }

    public final void clearProfileOwnerLocked(int i, ActiveAdmin activeAdmin) {
        String profileOwnerPackage = this.mOwners.getProfileOwnerPackage(i);
        if (profileOwnerPackage != null) {
            this.mDeviceAdminServiceController.stopServiceForAdmin(i, profileOwnerPackage);
        }
        if (activeAdmin != null) {
            activeAdmin.disableCamera = false;
            activeAdmin.userRestrictions = null;
            ((ArraySet) activeAdmin.defaultEnabledRestrictionsAlreadySet).clear();
        }
        DevicePolicyData userData = getUserData(i);
        userData.mCurrentInputMethodSet = false;
        ((ArraySet) userData.mOwnerInstalledCaCerts).clear();
        saveSettingsLocked(i, false, false, false);
        clearUserPoliciesLocked(i);
        this.mBackgroundHandler.post(new DevicePolicyManagerService$$ExternalSyntheticLambda0(this, i, 0));
        this.mOwners.removeProfileOwner(i);
        this.mOwners.writeProfileOwner(i);
        deleteTransferOwnershipBundleLocked(i);
        toggleBackupServiceActive(i, true);
        applyProfileRestrictionsIfDeviceOwnerLocked();
        setNetworkLoggingActiveInternal(false);
        this.mDevicePolicyEngine.removePoliciesForAdmin(EnforcingAdmin.createEnterpriseEnforcingAdmin(activeAdmin.info.getComponent(), i, activeAdmin));
    }

    public final boolean clearResetPasswordToken(ComponentName componentName, String str) {
        boolean z = false;
        if (!this.mHasFeature || !this.mLockPatternUtils.hasSecureLockScreen()) {
            return false;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userData = getUserData(userId);
                long j = userData.mPasswordTokenHandle;
                if (j != 0) {
                    Injector injector = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda23 devicePolicyManagerService$$ExternalSyntheticLambda23 = new DevicePolicyManagerService$$ExternalSyntheticLambda23(this, j, userId, 1);
                    injector.getClass();
                    boolean booleanValue = ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda23)).booleanValue();
                    userData.mPasswordTokenHandle = 0L;
                    saveSettingsLocked(userId, false, false, false);
                    z = booleanValue;
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        return z;
    }

    public final boolean clearResetPasswordTokenMDM(ComponentName componentName, int i) {
        if (!this.mHasFeature) {
            return false;
        }
        synchronized (getLockObject()) {
            try {
                getActiveAdminForCallerLockedMDM(2, i, componentName);
                DevicePolicyData userData = getUserData(i);
                if (userData.mPasswordTokenHandle == 0) {
                    return false;
                }
                this.mInjector.getClass();
                long clearCallingIdentity = Binder.clearCallingIdentity();
                try {
                    boolean removeEscrowToken = this.mLockPatternUtils.removeEscrowToken(userData.mPasswordTokenHandle, i);
                    userData.mPasswordTokenHandle = 0L;
                    saveSettingsLocked(i, false, false, false);
                    return removeEscrowToken;
                } finally {
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void clearSystemUpdatePolicyFreezePeriodRecord() {
        String systemUpdateFreezePeriodRecordAsString;
        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity(null, null)) || hasCallingOrSelfPermission("android.permission.CLEAR_FREEZE_PERIOD"), "Caller must be shell, or hold CLEAR_FREEZE_PERIOD permission to call clearSystemUpdatePolicyFreezePeriodRecord");
        synchronized (getLockObject()) {
            try {
                StringBuilder sb = new StringBuilder("Clear freeze period record: ");
                Owners owners = this.mOwners;
                synchronized (owners.mData) {
                    systemUpdateFreezePeriodRecordAsString = owners.mData.getSystemUpdateFreezePeriodRecordAsString();
                }
                sb.append(systemUpdateFreezePeriodRecordAsString);
                Slogf.i("DevicePolicyManager", sb.toString());
                if (this.mOwners.setSystemUpdateFreezePeriodRecord(null, null)) {
                    this.mOwners.writeDeviceOwner();
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void clearUserPoliciesLocked(int i) {
        DevicePolicyData userData = getUserData(i);
        userData.mPermissionPolicy = 0;
        userData.mDelegationMap.clear();
        userData.mStatusBarDisabled = false;
        userData.mSecondaryLockscreenEnabled = false;
        userData.mUserProvisioningState = 0;
        ((ArraySet) userData.mAffiliationIds).clear();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda57 devicePolicyManagerService$$ExternalSyntheticLambda57 = new DevicePolicyManagerService$$ExternalSyntheticLambda57(6, this);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda57);
        ((ArrayList) userData.mLockTaskPackages).clear();
        userData.mLockTaskFeatures = 0;
        saveSettingsLocked(i, false, false, false);
        try {
            this.mIPermissionManager.updatePermissionFlagsForAllApps(4, 0, i);
        } catch (RemoteException e) {
            Slogf.wtf("DevicePolicyManager", "Failing in updatePermissionFlagsForAllApps", e);
        }
    }

    public final String computeProvisioningErrorStringLocked(ComponentName componentName, int i, int i2, boolean z) {
        if (i == 16) {
            return "Cannot provision an unsupported DPC into DO on a headless device";
        }
        switch (i) {
            case 0:
                return "OK";
            case 1:
                StringBuilder sb = new StringBuilder("Trying to set the device owner");
                if (z && componentName != null) {
                    append(sb, componentName);
                }
                sb.append(", but device owner");
                if (z) {
                    ComponentName deviceOwnerComponent = getDeviceOwnerComponent(false);
                    if (deviceOwnerComponent == null) {
                        Slogf.wtf("DevicePolicyManager", "appendDeviceOwnerLocked(): device has no DO set");
                    } else {
                        append(sb, deviceOwnerComponent);
                    }
                }
                sb.append(" is already set.");
                return sb.toString();
            case 2:
                StringBuilder sb2 = new StringBuilder("Trying to set the device owner");
                if (z && componentName != null) {
                    append(sb2, componentName);
                }
                sb2.append(", but the user already has a profile owner");
                if (z) {
                    ComponentName profileOwnerComponent = this.mOwners.getProfileOwnerComponent(i2);
                    if (profileOwnerComponent == null) {
                        Slogf.wtf("DevicePolicyManager", "profileOwner(%d): PO not set", Integer.valueOf(i2));
                    } else {
                        append(sb2, profileOwnerComponent);
                    }
                }
                sb2.append(".");
                return sb2.toString();
            case 3:
                return BinaryTransparencyService$$ExternalSyntheticOutline0.m(i2, "User ", " not running.");
            case 4:
                return "Cannot set the device owner if the device is already set-up.";
            case 5:
                return "Not allowed to set the device owner because there are already several users on the device.";
            case 6:
                return "Not allowed to set the device owner because there are already some accounts on the device.";
            case 7:
                return BinaryTransparencyService$$ExternalSyntheticOutline0.m(i2, "User ", " is not system user.");
            case 8:
                return "Not allowed to set the device owner because this device has already paired.";
            default:
                return VibrationParam$1$$ExternalSyntheticOutline0.m(i, "Unexpected @ProvisioningPreCondition: ");
        }
    }

    public final boolean copyAccount(UserHandle userHandle, UserHandle userHandle2, Account account, String str) {
        long elapsedRealtime = SystemClock.elapsedRealtime();
        try {
            if (!((Boolean) ((AccountManager) this.mContext.getSystemService(AccountManager.class)).copyAccountToUser(account, userHandle2, userHandle, null, null).getResult(180L, TimeUnit.SECONDS)).booleanValue()) {
                logCopyAccountStatus(2, str);
                Slogf.e("DevicePolicyManager", "Failed to copy account to " + userHandle);
                return false;
            }
            logCopyAccountStatus(1, str);
            logEventDuration(190, str, elapsedRealtime);
            Slogf.i("DevicePolicyManager", "Copy account successful to " + userHandle);
            return true;
        } catch (AuthenticatorException | IOException e) {
            logCopyAccountStatus(4, str);
            Slogf.e("DevicePolicyManager", "Exception copying account to " + userHandle, e);
            return false;
        } catch (OperationCanceledException e2) {
            logCopyAccountStatus(3, str);
            Slogf.e("DevicePolicyManager", "Exception copying account to " + userHandle, e2);
            return false;
        }
    }

    public final Intent createAdminSupportIntent(String str) {
        Objects.requireNonNull(str);
        int userId = UserHandle.getUserId(getCallerIdentity(null, null).mUid);
        if (getEnforcingAdminAndUserDetailsInternal(userId, str) == null) {
            return null;
        }
        Intent createShowAdminSupportIntent = createShowAdminSupportIntent(userId);
        createShowAdminSupportIntent.putExtra("android.app.extra.RESTRICTION", str);
        return createShowAdminSupportIntent;
    }

    /* JADX WARN: Removed duplicated region for block: B:60:0x015b  */
    /* JADX WARN: Removed duplicated region for block: B:64:0x0167  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final android.os.UserHandle createAndManageUser(android.content.ComponentName r24, java.lang.String r25, android.content.ComponentName r26, android.os.PersistableBundle r27, int r28) {
        /*
            Method dump skipped, instructions count: 502
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.createAndManageUser(android.content.ComponentName, java.lang.String, android.content.ComponentName, android.os.PersistableBundle, int):android.os.UserHandle");
    }

    /* JADX WARN: Removed duplicated region for block: B:47:0x0235 A[Catch: all -> 0x0067, TryCatch #1 {all -> 0x0067, blocks: (B:3:0x0043, B:5:0x0055, B:59:0x0062, B:8:0x007b, B:10:0x0081, B:11:0x00ba, B:13:0x00d0, B:17:0x00e9, B:20:0x0105, B:22:0x0161, B:24:0x0192, B:25:0x0196, B:33:0x01a1, B:35:0x01a5, B:38:0x01f9, B:39:0x0201, B:40:0x0202, B:41:0x020a, B:45:0x0220, B:47:0x0235, B:48:0x023c, B:53:0x0089, B:54:0x008d, B:56:0x0093, B:7:0x006d, B:60:0x020b, B:61:0x021d), top: B:2:0x0043 }] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final android.os.UserHandle createAndProvisionManagedProfile(android.app.admin.ManagedProfileProvisioningParams r23, java.lang.String r24) {
        /*
            Method dump skipped, instructions count: 577
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.createAndProvisionManagedProfile(android.app.admin.ManagedProfileProvisioningParams, java.lang.String):android.os.UserHandle");
    }

    public final Intent createCrossUserServiceIntent(Intent intent, String str, int i) {
        ServiceInfo serviceInfo;
        ResolveInfo resolveService = this.mIPackageManager.resolveService(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 0L, i);
        if (resolveService == null || (serviceInfo = resolveService.serviceInfo) == null) {
            Slogf.e("DevicePolicyManager", "Fail to look up the service: %s or user %d is not running", intent, Integer.valueOf(i));
            return null;
        }
        if (!str.equals(serviceInfo.packageName)) {
            throw new SecurityException("Only allow to bind service in ".concat(str));
        }
        ServiceInfo serviceInfo2 = resolveService.serviceInfo;
        if (serviceInfo2.exported && !"android.permission.BIND_DEVICE_ADMIN".equals(serviceInfo2.permission)) {
            throw new SecurityException("Service must be protected by BIND_DEVICE_ADMIN permission");
        }
        intent.setComponent(resolveService.serviceInfo.getComponentName());
        return intent;
    }

    public final void deleteTransferOwnershipBundleLocked(int i) {
        this.mPathProvider.getClass();
        new File(Environment.getUserSystemDirectory(i), "transfer-ownership-parameters.xml").delete();
    }

    public final void deleteTransferOwnershipMetadataFileLocked() {
        TransferOwnershipMetadataManager transferOwnershipMetadataManager = this.mTransferOwnershipMetadataManager;
        transferOwnershipMetadataManager.getClass();
        transferOwnershipMetadataManager.mInjector.getClass();
        new File(Environment.getDataSystemDirectory(), "owner-transfer-metadata.xml").delete();
    }

    public final void disallowAddUser() {
        if (this.mIsAutomotive) {
            this.mInjector.getClass();
            if (UserManager.isHeadlessSystemUserMode()) {
                Slogf.i("DevicePolicyManager", "Not setting DISALLOW_ADD_USER on headless system user mode.");
                return;
            }
        }
        Iterator it = this.mUserManager.getUsers().iterator();
        while (it.hasNext()) {
            UserHandle userHandle = ((UserInfo) it.next()).getUserHandle();
            if (!this.mUserManager.hasUserRestriction("no_add_user", userHandle)) {
                this.mUserManager.setUserRestriction("no_add_user", true, userHandle);
            }
        }
    }

    public final boolean doesCallerHoldRole(CallerIdentity callerIdentity, String str) {
        int i = callerIdentity.mUid;
        String roleHolderPackageNameOnUser = getRoleHolderPackageNameOnUser(UserHandle.getUserId(i), str);
        this.mInjector.getClass();
        return i == Injector.getPackageManagerInternal().getPackageUid(roleHolderPackageNameOnUser, 0L, UserHandle.getUserId(callerIdentity.mUid));
    }

    public final void dump(FileDescriptor fileDescriptor, PrintWriter printWriter, String[] strArr) {
        if (DumpUtils.checkDumpPermission(this.mContext, "DevicePolicyManager", printWriter)) {
            IndentingPrintWriter indentingPrintWriter = new IndentingPrintWriter(printWriter, "  ");
            try {
                indentingPrintWriter.println("Current Device Policy Manager state:");
                indentingPrintWriter.increaseIndent();
                dumpImmutableState(indentingPrintWriter);
                synchronized (getLockObject()) {
                    try {
                        Owners owners = this.mOwners;
                        synchronized (owners.mData) {
                            owners.mData.dump(indentingPrintWriter);
                        }
                        indentingPrintWriter.println();
                        this.mDeviceAdminServiceController.dump(indentingPrintWriter);
                        indentingPrintWriter.println();
                        dumpPerUserPolicyData(indentingPrintWriter);
                        indentingPrintWriter.println();
                        this.mConstants.dump(indentingPrintWriter);
                        indentingPrintWriter.println();
                        this.mStatLogger.dump(indentingPrintWriter);
                        indentingPrintWriter.println();
                        if (Flags.dumpsysPolicyEngineMigrationEnabled()) {
                            this.mDevicePolicyEngine.dump(indentingPrintWriter);
                            indentingPrintWriter.println();
                        }
                        int encryptionStatus = getEncryptionStatus();
                        indentingPrintWriter.println("Encryption Status: ".concat(encryptionStatus != 0 ? encryptionStatus != 5 ? "unknown" : "per-user" : "unsupported"));
                        indentingPrintWriter.println("Logout user: " + getLogoutUserIdUnchecked());
                        indentingPrintWriter.println();
                        if (this.mPendingUserCreatedCallbackTokens.isEmpty()) {
                            indentingPrintWriter.println("no pending user created callback tokens");
                        } else {
                            int size = this.mPendingUserCreatedCallbackTokens.size();
                            indentingPrintWriter.printf("%d pending user created callback token%s\n", new Object[]{Integer.valueOf(size), size == 1 ? "" : "s"});
                        }
                        indentingPrintWriter.println();
                        this.mPolicyCache.dump(indentingPrintWriter);
                        indentingPrintWriter.println();
                        this.mStateCache.dump(indentingPrintWriter);
                        indentingPrintWriter.println();
                    } catch (Throwable th) {
                        throw th;
                    }
                }
                dumpPersonalAppInfoForSystemUserNoLock(indentingPrintWriter);
                synchronized (this.mSubscriptionsChangedListenerLock) {
                    indentingPrintWriter.println("Subscription changed listener : " + this.mSubscriptionsChangedListener);
                }
                indentingPrintWriter.println("DPM Engine (Permission Based Check) Flag : " + isPermissionCheckFlagEnabled());
                indentingPrintWriter.println("DPM Engine (For Finance) Flag : " + DeviceConfig.getBoolean("device_policy_manager", "enable_device_policy_engine", true));
                indentingPrintWriter.println("DPM global setting ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS : " + Settings.Global.getString(this.mInjector.mContext.getContentResolver(), "allow_work_profile_telephony_for_non_dpm_role_holders"));
                this.mHandler.post(new DevicePolicyManagerService$$ExternalSyntheticLambda27(this, indentingPrintWriter, 3));
                dumpResources(indentingPrintWriter);
                indentingPrintWriter.close();
            } catch (Throwable th2) {
                try {
                    indentingPrintWriter.close();
                } catch (Throwable th3) {
                    th2.addSuppressed(th3);
                }
                throw th2;
            }
        }
    }

    public final void dumpImmutableState(IndentingPrintWriter indentingPrintWriter) {
        indentingPrintWriter.println("Immutable state:");
        indentingPrintWriter.increaseIndent();
        indentingPrintWriter.printf("mHasFeature=%b\n", new Object[]{Boolean.valueOf(this.mHasFeature)});
        indentingPrintWriter.printf("mIsWatch=%b\n", new Object[]{Boolean.valueOf(this.mIsWatch)});
        indentingPrintWriter.printf("mIsAutomotive=%b\n", new Object[]{Boolean.valueOf(this.mIsAutomotive)});
        indentingPrintWriter.printf("mHasTelephonyFeature=%b\n", new Object[]{Boolean.valueOf(this.mHasTelephonyFeature)});
        indentingPrintWriter.printf("mSafetyChecker=%s\n", new Object[]{this.mSafetyChecker});
        indentingPrintWriter.decreaseIndent();
    }

    public final void dumpPerUserPolicyData(IndentingPrintWriter indentingPrintWriter) {
        int size = this.mUserData.size();
        for (int i = 0; i < size; i++) {
            DevicePolicyData userData = getUserData(this.mUserData.keyAt(i));
            indentingPrintWriter.println();
            StringBuilder sb = new StringBuilder("Enabled Device Admins (User ");
            int i2 = userData.mUserId;
            sb.append(i2);
            sb.append(", provisioningState: ");
            sb.append(userData.mUserProvisioningState);
            sb.append("):");
            indentingPrintWriter.println(sb.toString());
            int size2 = userData.mAdminList.size();
            for (int i3 = 0; i3 < size2; i3++) {
                ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminList.get(i3);
                if (activeAdmin != null) {
                    indentingPrintWriter.increaseIndent();
                    indentingPrintWriter.print(activeAdmin.info.getComponent().flattenToShortString());
                    indentingPrintWriter.println(":");
                    indentingPrintWriter.increaseIndent();
                    activeAdmin.dump(indentingPrintWriter);
                    indentingPrintWriter.decreaseIndent();
                    indentingPrintWriter.decreaseIndent();
                }
            }
            if (!userData.mRemovingAdmins.isEmpty()) {
                indentingPrintWriter.increaseIndent();
                indentingPrintWriter.println("Removing Device Admins (User " + i2 + "): " + userData.mRemovingAdmins);
                indentingPrintWriter.decreaseIndent();
            }
            indentingPrintWriter.println();
            indentingPrintWriter.increaseIndent();
            indentingPrintWriter.print("mPasswordOwner=");
            indentingPrintWriter.println(userData.mPasswordOwner);
            indentingPrintWriter.print("mPasswordTokenHandle=");
            indentingPrintWriter.println(Long.toHexString(userData.mPasswordTokenHandle));
            indentingPrintWriter.print("mAppsSuspended=");
            indentingPrintWriter.println(userData.mAppsSuspended);
            indentingPrintWriter.print("mUserSetupComplete=");
            indentingPrintWriter.println(userData.mUserSetupComplete);
            indentingPrintWriter.print("mAffiliationIds=");
            indentingPrintWriter.println(userData.mAffiliationIds);
            indentingPrintWriter.print("mNewUserDisclaimer=");
            indentingPrintWriter.println(userData.mNewUserDisclaimer);
            indentingPrintWriter.print("mLastResetPasswordByAdmin=");
            indentingPrintWriter.println(userData.mLastResetPassword);
            if (userData.mFactoryResetFlags != 0) {
                indentingPrintWriter.print("mFactoryResetFlags=");
                indentingPrintWriter.print(userData.mFactoryResetFlags);
                indentingPrintWriter.print(" (");
                indentingPrintWriter.print(DebugUtils.flagsToString(DevicePolicyData.class, "FACTORY_RESET_FLAG_", userData.mFactoryResetFlags));
                indentingPrintWriter.println(')');
            }
            if (userData.mFactoryResetReason != null) {
                indentingPrintWriter.print("mFactoryResetReason=");
                indentingPrintWriter.println(userData.mFactoryResetReason);
            }
            if (userData.mDelegationMap.size() != 0) {
                indentingPrintWriter.println("mDelegationMap=");
                indentingPrintWriter.increaseIndent();
                for (int i4 = 0; i4 < userData.mDelegationMap.size(); i4++) {
                    List list = (List) userData.mDelegationMap.valueAt(i4);
                    indentingPrintWriter.println(((String) userData.mDelegationMap.keyAt(i4)) + "[size=" + list.size() + "]");
                    indentingPrintWriter.increaseIndent();
                    for (int i5 = 0; i5 < list.size(); i5++) {
                        indentingPrintWriter.println(i5 + ": " + ((String) list.get(i5)));
                    }
                    indentingPrintWriter.decreaseIndent();
                }
                indentingPrintWriter.decreaseIndent();
            }
            indentingPrintWriter.decreaseIndent();
            indentingPrintWriter.println();
        }
    }

    public final void dumpPersonalAppInfoForSystemUserNoLock(IndentingPrintWriter indentingPrintWriter) {
        String defaultSmsPackage;
        wtfIfInLock();
        Context createContextAsUser = this.mContext.createContextAsUser(UserHandle.of(0), 0);
        PersonalAppsSuspensionHelper personalAppsSuspensionHelper = new PersonalAppsSuspensionHelper(createContextAsUser);
        indentingPrintWriter.println("PersonalAppsSuspensionHelper");
        indentingPrintWriter.increaseIndent();
        dumpApps(indentingPrintWriter, "critical packages", Arrays.asList(createContextAsUser.getResources().getStringArray(17236281)));
        dumpApps(indentingPrintWriter, "launcher packages", personalAppsSuspensionHelper.getSystemLauncherPackages());
        dumpApps(indentingPrintWriter, "accessibility services", personalAppsSuspensionHelper.getAccessibilityServices());
        dumpApps(indentingPrintWriter, "input method packages", personalAppsSuspensionHelper.getInputMethodPackages());
        if (Flags.defaultSmsPersonalAppSuspensionFixEnabled()) {
            ComponentName defaultSmsApplicationAsUser = SmsApplication.getDefaultSmsApplicationAsUser(createContextAsUser, false, createContextAsUser.getUser());
            defaultSmsPackage = defaultSmsApplicationAsUser != null ? defaultSmsApplicationAsUser.getPackageName() : null;
        } else {
            defaultSmsPackage = Telephony.Sms.getDefaultSmsPackage(createContextAsUser);
        }
        indentingPrintWriter.printf("SMS package: %s\n", new Object[]{defaultSmsPackage});
        Intent intent = new Intent("android.settings.SETTINGS");
        intent.addCategory("android.intent.category.DEFAULT");
        ResolveInfo resolveActivity = personalAppsSuspensionHelper.mPackageManager.resolveActivity(intent, 786432);
        indentingPrintWriter.printf("Settings package: %s\n", new Object[]{resolveActivity != null ? resolveActivity.activityInfo.packageName : null});
        dumpApps(indentingPrintWriter, "Packages subject to suspension", personalAppsSuspensionHelper.getPersonalAppsForSuspension());
        indentingPrintWriter.decreaseIndent();
    }

    public final void dumpResources(IndentingPrintWriter indentingPrintWriter) {
        OverlayPackagesProvider overlayPackagesProvider = this.mOverlayPackagesProvider;
        overlayPackagesProvider.getClass();
        indentingPrintWriter.println("OverlayPackagesProvider");
        indentingPrintWriter.increaseIndent();
        final int i = 0;
        dumpApps(indentingPrintWriter, "required_apps_managed_device", (String[]) overlayPackagesProvider.resolveStringArray(17236466).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i2) {
                switch (i) {
                    case 0:
                        return new String[i2];
                    case 1:
                        return new String[i2];
                    case 2:
                        return new String[i2];
                    case 3:
                        return new String[i2];
                    case 4:
                        return new String[i2];
                    case 5:
                        return new String[i2];
                    case 6:
                        return new String[i2];
                    case 7:
                        return new String[i2];
                    case 8:
                        return new String[i2];
                    case 9:
                        return new String[i2];
                    case 10:
                        return new String[i2];
                    default:
                        return new String[i2];
                }
            }
        }));
        final int i2 = 5;
        dumpApps(indentingPrintWriter, "required_apps_managed_user", (String[]) overlayPackagesProvider.resolveStringArray(17236468).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i2) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        final int i3 = 6;
        dumpApps(indentingPrintWriter, "required_apps_managed_profile", (String[]) overlayPackagesProvider.resolveStringArray(17236467).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i3) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        final int i4 = 7;
        dumpApps(indentingPrintWriter, "disallowed_apps_managed_device", (String[]) overlayPackagesProvider.resolveStringArray(17236445).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i4) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        final int i5 = 8;
        dumpApps(indentingPrintWriter, "disallowed_apps_managed_user", (String[]) overlayPackagesProvider.resolveStringArray(17236447).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i5) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        final int i6 = 9;
        dumpApps(indentingPrintWriter, "disallowed_apps_managed_device", (String[]) overlayPackagesProvider.resolveStringArray(17236445).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i6) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        final int i7 = 10;
        dumpApps(indentingPrintWriter, "vendor_required_apps_managed_device", (String[]) overlayPackagesProvider.resolveStringArray(17236484).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i7) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        final int i8 = 11;
        dumpApps(indentingPrintWriter, "vendor_required_apps_managed_user", (String[]) overlayPackagesProvider.resolveStringArray(17236486).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i8) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        final int i9 = 1;
        dumpApps(indentingPrintWriter, "vendor_required_apps_managed_profile", (String[]) overlayPackagesProvider.resolveStringArray(17236485).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i9) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        final int i10 = 2;
        dumpApps(indentingPrintWriter, "vendor_disallowed_apps_managed_user", (String[]) overlayPackagesProvider.resolveStringArray(17236482).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i10) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        final int i11 = 3;
        dumpApps(indentingPrintWriter, "vendor_disallowed_apps_managed_device", (String[]) overlayPackagesProvider.resolveStringArray(17236480).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i11) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        final int i12 = 4;
        dumpApps(indentingPrintWriter, "vendor_disallowed_apps_managed_profile", (String[]) overlayPackagesProvider.resolveStringArray(17236481).toArray(new IntFunction() { // from class: com.android.server.devicepolicy.OverlayPackagesProvider$$ExternalSyntheticLambda0
            @Override // java.util.function.IntFunction
            public final Object apply(int i22) {
                switch (i12) {
                    case 0:
                        return new String[i22];
                    case 1:
                        return new String[i22];
                    case 2:
                        return new String[i22];
                    case 3:
                        return new String[i22];
                    case 4:
                        return new String[i22];
                    case 5:
                        return new String[i22];
                    case 6:
                        return new String[i22];
                    case 7:
                        return new String[i22];
                    case 8:
                        return new String[i22];
                    case 9:
                        return new String[i22];
                    case 10:
                        return new String[i22];
                    default:
                        return new String[i22];
                }
            }
        }));
        indentingPrintWriter.decreaseIndent();
        indentingPrintWriter.println();
        indentingPrintWriter.println("Other overlayable app resources");
        indentingPrintWriter.increaseIndent();
        dumpApps(indentingPrintWriter, "cross_profile_apps", this.mContext.getResources().getStringArray(17236433));
        dumpApps(indentingPrintWriter, "vendor_cross_profile_apps", this.mContext.getResources().getStringArray(17236479));
        dumpApps(indentingPrintWriter, "config_packagesExemptFromSuspension", this.mContext.getResources().getStringArray(17236281));
        dumpApps(indentingPrintWriter, "policy_exempt_apps", this.mContext.getResources().getStringArray(17236462));
        dumpApps(indentingPrintWriter, "vendor_policy_exempt_apps", this.mContext.getResources().getStringArray(17236483));
        indentingPrintWriter.decreaseIndent();
        indentingPrintWriter.println();
    }

    public final void enableAndSetActiveAdmin(int i, int i2, ComponentName componentName) {
        String packageName = componentName.getPackageName();
        try {
            int applicationEnabledSetting = this.mIPackageManager.getApplicationEnabledSetting(packageName, i2);
            if (applicationEnabledSetting != 0 && applicationEnabledSetting != 1) {
                this.mIPackageManager.setApplicationEnabledSetting(packageName, 0, 1, i2, this.mContext.getOpPackageName());
            }
        } catch (RemoteException e) {
            Slogf.wtf("DevicePolicyManager", "Error setting application enabled", e);
        }
        setActiveAdmin(componentName, true, i);
    }

    /* JADX WARN: Removed duplicated region for block: B:14:0x006f A[Catch: all -> 0x0057, RemoteException -> 0x0059, TRY_LEAVE, TryCatch #1 {RemoteException -> 0x0059, blocks: (B:29:0x0048, B:12:0x005c, B:14:0x006f), top: B:28:0x0048, outer: #0 }] */
    /* JADX WARN: Removed duplicated region for block: B:23:0x00a9  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void enableSystemApp(android.content.ComponentName r17, java.lang.String r18, java.lang.String r19) {
        /*
            r16 = this;
            r1 = r16
            r8 = r19
            java.lang.String r9 = "Failed to install "
            com.android.server.devicepolicy.CallerIdentity r10 = r16.getCallerIdentity(r17, r18)
            boolean r0 = r10.hasAdminComponent()
            r11 = 0
            r12 = 1
            if (r0 == 0) goto L1e
            boolean r0 = r1.isProfileOwner(r10)
            if (r0 != 0) goto L2d
            boolean r0 = r1.isDefaultDeviceOwner(r10)
            if (r0 != 0) goto L2d
        L1e:
            boolean r0 = r10.hasPackage()
            if (r0 == 0) goto L2f
            java.lang.String r0 = "delegation-enable-system-app"
            boolean r0 = r1.isCallerDelegate(r10, r0)
            if (r0 == 0) goto L2f
        L2d:
            r0 = r12
            goto L30
        L2f:
            r0 = r11
        L30:
            com.android.internal.util.Preconditions.checkCallAuthorization(r0)
            boolean r0 = r16.isCurrentUserDemo()
            int r2 = r10.mUid
            int r13 = android.os.UserHandle.getUserId(r2)
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r2 = r1.mInjector
            r2.getClass()
            long r14 = android.os.Binder.clearCallingIdentity()
            if (r0 != 0) goto L5b
            android.content.pm.IPackageManager r2 = r1.mIPackageManager     // Catch: java.lang.Throwable -> L57 android.os.RemoteException -> L59
            int r3 = r1.getProfileParentId(r13)     // Catch: java.lang.Throwable -> L57 android.os.RemoteException -> L59
            boolean r2 = isSystemApp(r2, r8, r3)     // Catch: java.lang.Throwable -> L57 android.os.RemoteException -> L59
            if (r2 == 0) goto L55
            goto L5b
        L55:
            r2 = r11
            goto L5c
        L57:
            r0 = move-exception
            goto Lba
        L59:
            r0 = move-exception
            goto L84
        L5b:
            r2 = r12
        L5c:
            java.lang.String r3 = "Only system apps can be enabled this way"
            com.android.internal.util.Preconditions.checkArgument(r2, r3)     // Catch: java.lang.Throwable -> L57 android.os.RemoteException -> L59
            android.content.pm.IPackageManager r2 = r1.mIPackageManager     // Catch: java.lang.Throwable -> L57 android.os.RemoteException -> L59
            r7 = 0
            r5 = 4194304(0x400000, float:5.877472E-39)
            r6 = 1
            r3 = r19
            r4 = r13
            r2.installExistingPackageAsUser(r3, r4, r5, r6, r7)     // Catch: java.lang.Throwable -> L57 android.os.RemoteException -> L59
            if (r0 == 0) goto L7b
            android.content.pm.IPackageManager r2 = r1.mIPackageManager     // Catch: java.lang.Throwable -> L57 android.os.RemoteException -> L59
            java.lang.String r7 = "DevicePolicyManager"
            r4 = 1
            r5 = 1
            r3 = r19
            r6 = r13
            r2.setApplicationEnabledSetting(r3, r4, r5, r6, r7)     // Catch: java.lang.Throwable -> L57 android.os.RemoteException -> L59
        L7b:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r0 = r1.mInjector
        L7d:
            r0.getClass()
            android.os.Binder.restoreCallingIdentity(r14)
            goto L98
        L84:
            java.lang.String r2 = "DevicePolicyManager"
            java.lang.StringBuilder r3 = new java.lang.StringBuilder     // Catch: java.lang.Throwable -> L57
            r3.<init>(r9)     // Catch: java.lang.Throwable -> L57
            r3.append(r8)     // Catch: java.lang.Throwable -> L57
            java.lang.String r3 = r3.toString()     // Catch: java.lang.Throwable -> L57
            com.android.server.utils.Slogf.wtf(r2, r3, r0)     // Catch: java.lang.Throwable -> L57
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r0 = r1.mInjector
            goto L7d
        L98:
            r1.setCrossProfileAppToIgnored(r8, r13)
            r0 = 64
            android.app.admin.DevicePolicyEventLogger r0 = android.app.admin.DevicePolicyEventLogger.createEvent(r0)
            java.lang.String r1 = r10.mPackageName
            android.app.admin.DevicePolicyEventLogger r0 = r0.setAdmin(r1)
            if (r17 != 0) goto Laa
            r11 = r12
        Laa:
            android.app.admin.DevicePolicyEventLogger r0 = r0.setBoolean(r11)
            java.lang.String[] r1 = new java.lang.String[]{r19}
            android.app.admin.DevicePolicyEventLogger r0 = r0.setStrings(r1)
            r0.write()
            return
        Lba:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r1 = r1.mInjector
            r1.getClass()
            android.os.Binder.restoreCallingIdentity(r14)
            throw r0
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.enableSystemApp(android.content.ComponentName, java.lang.String, java.lang.String):void");
    }

    public final int enableSystemAppWithIntent(ComponentName componentName, String str, Intent intent) {
        int i;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        boolean hasAdminComponent = callerIdentity.hasAdminComponent();
        int i2 = callerIdentity.mUid;
        Preconditions.checkCallAuthorization((hasAdminComponent && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-enable-system-app")));
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                int profileParentId = getProfileParentId(UserHandle.getUserId(i2));
                List list = this.mIPackageManager.queryIntentActivities(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 786432L, profileParentId).getList();
                if (list != null) {
                    Iterator it = list.iterator();
                    i = 0;
                    while (it.hasNext()) {
                        ActivityInfo activityInfo = ((ResolveInfo) it.next()).activityInfo;
                        if (activityInfo != null) {
                            String str2 = activityInfo.packageName;
                            if (isSystemApp(this.mIPackageManager, str2, profileParentId)) {
                                i++;
                                this.mIPackageManager.installExistingPackageAsUser(str2, UserHandle.getUserId(i2), 4194304, 1, (List) null);
                            } else {
                                Slogf.d("DevicePolicyManager", "Not enabling " + str2 + " since is not a system app");
                            }
                        }
                    }
                } else {
                    i = 0;
                }
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                DevicePolicyEventLogger.createEvent(65).setAdmin(callerIdentity.mPackageName).setBoolean(componentName == null).setStrings(new String[]{intent.getAction()}).write();
                return i;
            } catch (RemoteException e) {
                Slogf.wtf("DevicePolicyManager", "Failed to resolve intent for: " + intent, e);
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                return 0;
            }
        } catch (Throwable th) {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            throw th;
        }
    }

    public final EnforcingAdmin enforceCanCallLockTaskLocked(ComponentName componentName, String str) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = enforcePermissionAndGetEnforcingAdmin(userId, componentName, "android.permission.MANAGE_DEVICE_POLICY_LOCK_TASK", callerIdentity.mPackageName);
        if ((isDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity)) && !canDPCManagedUserUseLockTaskLocked(userId)) {
            throw new SecurityException(BinaryTransparencyService$$ExternalSyntheticOutline0.m(userId, "User ", " is not allowed to use lock task"));
        }
        return enforcePermissionAndGetEnforcingAdmin;
    }

    public final void enforceCanManageCaCerts(ComponentName componentName, String str) {
        Preconditions.checkCallAuthorization(canManageCaCerts(getCallerIdentity(componentName, str)));
    }

    public final void enforceCanQuery(int i, String str, String str2) {
        if (hasPermission("android.permission.QUERY_ADMIN_POLICY", str2)) {
            return;
        }
        enforcePermission(str, str2, i);
    }

    public final void enforceCanQueryLockTaskLocked(ComponentName componentName, String str) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        enforceCanQuery(userId, "android.permission.MANAGE_DEVICE_POLICY_LOCK_TASK", callerIdentity.mPackageName);
        if ((isDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity)) && !canDPCManagedUserUseLockTaskLocked(userId)) {
            throw new SecurityException(BinaryTransparencyService$$ExternalSyntheticOutline0.m(userId, "User ", " is not allowed to use lock task"));
        }
    }

    public final void enforceCanSetDeviceOwnerLocked(CallerIdentity callerIdentity, ComponentName componentName, int i, boolean z) {
        boolean z2;
        if (isAdb(callerIdentity)) {
            z2 = true;
        } else {
            Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
            z2 = false;
        }
        int checkDeviceOwnerProvisioningPreConditionLocked = checkDeviceOwnerProvisioningPreConditionLocked(componentName, i, UserHandle.getUserId(callerIdentity.mUid), isAdb(callerIdentity), z);
        if (checkDeviceOwnerProvisioningPreConditionLocked != 0) {
            String computeProvisioningErrorStringLocked = computeProvisioningErrorStringLocked(componentName, checkDeviceOwnerProvisioningPreConditionLocked, i, z2);
            if (checkDeviceOwnerProvisioningPreConditionLocked != 16) {
                throw new IllegalStateException(computeProvisioningErrorStringLocked);
            }
            throw new ServiceSpecificException(checkDeviceOwnerProvisioningPreConditionLocked, computeProvisioningErrorStringLocked);
        }
    }

    public final void enforceCanSetProfileOwnerLocked(CallerIdentity callerIdentity, ComponentName componentName, int i, boolean z) {
        UserInfo userInfo = getUserInfo(i);
        if (userInfo == null) {
            throw new IllegalArgumentException(VibrationParam$1$$ExternalSyntheticOutline0.m(i, "Attempted to set profile owner for invalid userId: "));
        }
        if (userInfo.isGuest()) {
            throw new IllegalStateException("Cannot set a profile owner on a guest");
        }
        if (this.mOwners.hasProfileOwner(i)) {
            StringBuilder sb = new StringBuilder("Trying to set the profile owner");
            if (!z) {
                append(sb, componentName);
                sb.append(" on user ");
                sb.append(i);
            }
            sb.append(", but profile owner");
            if (!z) {
                ComponentName profileOwnerComponent = this.mOwners.getProfileOwnerComponent(i);
                if (profileOwnerComponent == null) {
                    Slogf.wtf("DevicePolicyManager", "profileOwner(%d): PO not set", Integer.valueOf(i));
                } else {
                    append(sb, profileOwnerComponent);
                }
            }
            sb.append(" is already set.");
            throw new IllegalStateException(sb.toString());
        }
        if (this.mOwners.hasDeviceOwner() && this.mOwners.getDeviceOwnerUserId() == i) {
            StringBuilder sb2 = new StringBuilder("Trying to set the profile owner");
            if (!z) {
                append(sb2, componentName);
                sb2.append(" on user ");
                sb2.append(i);
            }
            sb2.append(", but the user already has a device owner");
            if (!z) {
                ComponentName deviceOwnerComponent = getDeviceOwnerComponent(false);
                if (deviceOwnerComponent == null) {
                    Slogf.wtf("DevicePolicyManager", "appendDeviceOwnerLocked(): device has no DO set");
                } else {
                    append(sb2, deviceOwnerComponent);
                }
            }
            sb2.append('.');
            throw new IllegalStateException(sb2.toString());
        }
        if (!isAdb(callerIdentity)) {
            Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
            if (this.mIsWatch || hasUserSetupCompleted(i)) {
                Preconditions.checkState(UserHandle.isSameApp(callerIdentity.mUid, 1000), "Cannot set the profile owner on a user which is already set-up");
                if (!this.mIsWatch && !isSupervisionComponentLocked(componentName)) {
                    throw new IllegalStateException(AmbientContextManagerPerUserService$$ExternalSyntheticOutline0.m(componentName, "Unable to set non-default profile owner post-setup "));
                }
                return;
            }
            return;
        }
        if ((this.mIsWatch || hasUserSetupCompleted(i)) && z) {
            StringBuilder sb3 = new StringBuilder("Not allowed to set the profile owner");
            if (!z) {
                append(sb3, componentName);
                sb3.append(" on user ");
                sb3.append(i);
                sb3.append(' ');
            }
            sb3.append(" because there are already some accounts on the profile.");
            throw new IllegalStateException(sb3.toString());
        }
    }

    public final void enforcePackageIsSystemPackage(int i, String str) {
        boolean z;
        try {
            z = isSystemApp(this.mIPackageManager, str, i);
        } catch (IllegalArgumentException unused) {
            z = false;
        }
        if (!z) {
            throw new IllegalArgumentException("The provided package is not a system package");
        }
    }

    public final void enforcePermission(String str, String str2) {
        if (!hasPermission(str, str2)) {
            throw new SecurityException(XmlUtils$$ExternalSyntheticOutline0.m("Caller does not have the required permissions for this user. Permission required: ", str, "."));
        }
    }

    public final void enforcePermission(String str, String str2, int i) {
        enforcePermission(str, str2);
        if (i != UserHandle.getUserId(getCallerIdentity(null, str2).mUid)) {
            enforcePermission((String) CROSS_USER_PERMISSIONS.get(str), str2);
        }
    }

    public final EnforcingAdmin enforcePermissionAndGetEnforcingAdmin(int i, ComponentName componentName, String str, String str2) {
        enforcePermission(str, str2, i);
        return getEnforcingAdminForCaller(componentName, str2);
    }

    public final EnforcingAdmin enforcePermissionForUserRestriction(int i, ComponentName componentName, String str, String str2) {
        String[] strArr = (String[]) USER_RESTRICTION_PERMISSIONS.get(str);
        if (strArr.length <= 0) {
            throw new SecurityException(ConnectivityModuleConnector$$ExternalSyntheticOutline0.m("Admins are not permitted to set User Restriction: ", str));
        }
        try {
            enforcePermissions(str2, i, strArr);
            return getEnforcingAdminForCaller(componentName, str2);
        } catch (SecurityException e) {
            StringBuilder m = DumpUtils$$ExternalSyntheticOutline0.m("Caller does not hold the required permission for this user restriction: ", str, ".\n");
            m.append(e.getMessage());
            throw new SecurityException(m.toString());
        }
    }

    public final void enforcePermissionGrantStateOnFinancedDevice(String str, String str2) {
        if (!"android.permission.READ_PHONE_STATE".equals(str2)) {
            throw new SecurityException(ConnectivityModuleConnector$$ExternalSyntheticOutline0.m$1(str2, " cannot be used when managing a financed device for permission grant state"));
        }
        if (!this.mOwners.getDeviceOwnerPackageName().equals(str)) {
            throw new SecurityException("Device owner package is the only package that can be used for permission grant state when managing a financed device");
        }
    }

    public final void enforcePermissions(String str, int i, String[] strArr) {
        String str2;
        int length = strArr.length;
        int i2 = 0;
        while (true) {
            if (i2 >= length) {
                str2 = "";
                break;
            }
            str2 = strArr[i2];
            if (hasPermission(str2, str)) {
                break;
            } else {
                i2++;
            }
        }
        if (!str2.isEmpty()) {
            enforcePermission(str2, str, i);
        } else {
            throw new SecurityException("Caller does not have the required permissions for this user. One of the following permission required: " + Arrays.toString(strArr));
        }
    }

    public final void enforceUserUnlocked(int i) {
        Preconditions.checkState(this.mUserManager.isUserUnlocked(i), "User must be running and unlocked");
    }

    public final void ensureLocked() {
        if (Thread.holdsLock(this.mLockDoNoUseDirectly)) {
            return;
        }
        Slogf.wtfStack("DevicePolicyManager", "Not holding DPMS lock.");
    }

    public final void ensureMinimumQuality(final int i, final ActiveAdmin activeAdmin, final int i2, final String str) {
        Injector injector = this.mInjector;
        FunctionalUtils.ThrowingRunnable throwingRunnable = new FunctionalUtils.ThrowingRunnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda148
            public final void runOrThrow() {
                DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                ActiveAdmin activeAdmin2 = activeAdmin;
                int i3 = i2;
                int i4 = i;
                String str2 = str;
                devicePolicyManagerService.getClass();
                if (activeAdmin2.mPasswordPolicy.quality < i3) {
                    String packageName = activeAdmin2.info.getPackageName();
                    devicePolicyManagerService.mInjector.getClass();
                    if (DevicePolicyManagerService.Injector.isChangeEnabled(i4, packageName, 123562444L)) {
                        throw new IllegalStateException(String.format("password quality should be at least %d for %s", Integer.valueOf(i3), str2));
                    }
                }
            }
        };
        injector.getClass();
        Binder.withCleanCallingIdentity(throwingRunnable);
    }

    public final void ensureUnknownSourcesRestrictionForProfileOwnerLocked(int i, ActiveAdmin activeAdmin, boolean z) {
        if (z || Settings.Secure.getIntForUser(this.mInjector.mContext.getContentResolver(), "unknown_sources_default_reversed", 0, i) != 0) {
            this.mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.getPolicyDefinitionForUserRestriction("no_install_unknown_sources"), EnforcingAdmin.createEnterpriseEnforcingAdmin(activeAdmin.getUserHandle().getIdentifier(), activeAdmin.info.getComponent()), new BooleanPolicyValue(true), i, false);
            Settings.Secure.putIntForUser(this.mInjector.mContext.getContentResolver(), "unknown_sources_default_reversed", 0, i);
        }
    }

    public final void finalizeWorkProfileProvisioning(UserHandle userHandle, Account account) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        if (!isManagedProfile(userHandle.getIdentifier())) {
            throw new IllegalStateException("Given user is not a managed profile");
        }
        ComponentName profileOwnerComponent = this.mOwners.getProfileOwnerComponent(userHandle.getIdentifier());
        if (profileOwnerComponent == null) {
            throw new IllegalStateException("There is no profile owner on the given profile");
        }
        Intent intent = new Intent("android.app.action.MANAGED_PROFILE_PROVISIONED");
        intent.setPackage(profileOwnerComponent.getPackageName());
        intent.addFlags(268435488);
        intent.putExtra("android.intent.extra.USER", userHandle);
        if (account != null) {
            intent.putExtra("android.app.extra.PROVISIONING_ACCOUNT_TO_MIGRATE", account);
        }
        this.mContext.sendBroadcastAsUser(intent, UserHandle.of(getProfileParentId(userHandle.getIdentifier())));
    }

    public final DeviceAdminInfo findAdmin(int i, ComponentName componentName, boolean z) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda64 devicePolicyManagerService$$ExternalSyntheticLambda64 = new DevicePolicyManagerService$$ExternalSyntheticLambda64(this, componentName, i, 0);
        injector.getClass();
        ActivityInfo activityInfo = (ActivityInfo) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda64);
        if (activityInfo == null) {
            throw new IllegalArgumentException(AmbientContextManagerPerUserService$$ExternalSyntheticOutline0.m(componentName, "Unknown admin: "));
        }
        if (!"android.permission.BIND_DEVICE_ADMIN".equals(activityInfo.permission)) {
            String str = "DeviceAdminReceiver " + componentName + " must be protected with android.permission.BIND_DEVICE_ADMIN";
            Slogf.w("DevicePolicyManager", str);
            if (z && activityInfo.applicationInfo.targetSdkVersion > 23) {
                throw new IllegalArgumentException(str);
            }
        }
        try {
            return new DeviceAdminInfo(this.mContext, activityInfo);
        } catch (IOException | XmlPullParserException e) {
            Slogf.w("DevicePolicyManager", "Bad device admin requested for user=" + i + ": " + componentName, e);
            return null;
        }
    }

    public final void fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration() {
        ActiveAdmin activeAdmin;
        Iterator it = this.mUserManager.getUsers().iterator();
        while (it.hasNext()) {
            int i = ((UserInfo) it.next()).id;
            if (isProfileOwnerOfOrganizationOwnedDevice(i) && (activeAdmin = getProfileOwnerAdminLocked(i).parentAdmin) != null && activeAdmin.requireAutoTime) {
                activeAdmin.requireAutoTime = false;
                saveSettingsLocked(i, false, false, false);
                this.mUserManagerInternal.setDevicePolicyUserRestrictions(new Bundle(), new RestrictionsSet());
                activeAdmin.ensureUserRestrictions().putBoolean("no_config_date_time", true);
            }
        }
    }

    public final long forceNetworkLogs() {
        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity(null, null)) || hasCallingOrSelfPermission("android.permission.FORCE_DEVICE_POLICY_MANAGER_LOGS"), "Caller must be shell or hold FORCE_DEVICE_POLICY_MANAGER_LOGS to call forceNetworkLogs");
        synchronized (getLockObject()) {
            try {
                if (!isNetworkLoggingEnabledInternalLocked()) {
                    throw new IllegalStateException("logging is not available");
                }
                if (this.mNetworkLogger == null) {
                    return 0L;
                }
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 13);
                injector.getClass();
                return ((Long) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33)).longValue();
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void forceRemoveActiveAdmin(ComponentName componentName, int i) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isAdb(getCallerIdentity(null, null)) || hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"), "Caller must be shell or hold MANAGE_PROFILE_AND_DEVICE_OWNERS to call forceRemoveActiveAdmin");
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda30 devicePolicyManagerService$$ExternalSyntheticLambda30 = new DevicePolicyManagerService$$ExternalSyntheticLambda30(this, componentName, i, 3);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda30);
        }
    }

    public final long forceSecurityLogs() {
        long j;
        Preconditions.checkCallAuthorization(isAdb(getCallerIdentity(null, null)) || hasCallingOrSelfPermission("android.permission.FORCE_DEVICE_POLICY_MANAGER_LOGS"), "Caller must be shell or hold FORCE_DEVICE_POLICY_MANAGER_LOGS to call forceSecurityLogs");
        this.mInjector.getClass();
        if (!SecurityLog.getLoggingEnabledProperty()) {
            throw new IllegalStateException("logging is not available");
        }
        SecurityLogMonitor securityLogMonitor = this.mSecurityLogMonitor;
        securityLogMonitor.getClass();
        long nanoTime = System.nanoTime();
        synchronized (securityLogMonitor.mForceSemaphore) {
            try {
                long j2 = (securityLogMonitor.mLastForceNanos + SecurityLogMonitor.FORCE_FETCH_THROTTLE_NS) - nanoTime;
                j = 0;
                if (j2 > 0) {
                    j = TimeUnit.NANOSECONDS.toMillis(j2) + 1;
                } else {
                    securityLogMonitor.mLastForceNanos = nanoTime;
                    if (securityLogMonitor.mForceSemaphore.availablePermits() == 0) {
                        securityLogMonitor.mForceSemaphore.release();
                    }
                }
            } finally {
            }
        }
        return j;
    }

    public final void forceSetMaxPolicyStorageLimit(String str, int i) {
        if (Flags.devicePolicySizeTrackingInternalBugFixEnabled()) {
            CallerIdentity callerIdentity = getCallerIdentity(null, str);
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_STORAGE_LIMIT", callerIdentity.mPackageName, UserHandle.getUserId(callerIdentity.mUid));
            this.mDevicePolicyEngine.mPolicySizeLimit = i;
        }
    }

    public final void forceUpdateUserSetupComplete(int i) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        boolean z = Settings.Secure.getIntForUser(this.mInjector.mContext.getContentResolver(), "user_setup_complete", 0, i) != 0;
        getUserData(i).mUserSetupComplete = z;
        DeviceStateCacheImpl deviceStateCacheImpl = this.mStateCache;
        synchronized (deviceStateCacheImpl.mLock) {
            deviceStateCacheImpl.mIsDeviceProvisioned = z;
        }
        synchronized (getLockObject()) {
            saveSettingsLocked(i, false, false, false);
        }
    }

    public final boolean generateKeyPair(ComponentName componentName, String str, String str2, ParcelableKeyGenParameterSpec parcelableKeyGenParameterSpec, int i, KeymasterCertificateChain keymasterCertificateChain) {
        Injector injector;
        int[] translateIdAttestationFlags = translateIdAttestationFlags(i);
        boolean z = translateIdAttestationFlags != null;
        KeyGenParameterSpec spec = parcelableKeyGenParameterSpec.getSpec();
        String keystoreAlias = spec.getKeystoreAlias();
        Preconditions.checkStringNotEmpty(keystoreAlias, "Empty alias provided");
        Preconditions.checkArgument((z && spec.getAttestationChallenge() == null) ? false : true, "Requested Device ID attestation but challenge is empty");
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        boolean isCallerDelegate = isCallerDelegate(callerIdentity, "delegation-cert-install");
        boolean isCredentialManagementApp = isCredentialManagementApp(callerIdentity);
        String str3 = callerIdentity.mPackageName;
        int i2 = callerIdentity.mUid;
        if (!z || translateIdAttestationFlags.length <= 0) {
            if (isPermissionCheckFlagEnabled()) {
                Preconditions.checkCallAuthorization(hasPermission("android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES", str3, UserHandle.getUserId(i2)) || isCredentialManagementApp);
            } else {
                Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));
            }
            if (isCredentialManagementApp) {
                Preconditions.checkCallAuthorization(isAliasInCredentialManagementAppPolicy(callerIdentity, keystoreAlias), "The alias provided must be contained in the aliases specified in the credential management app's authentication policy");
            }
        } else {
            Preconditions.checkCallAuthorization(hasDeviceIdAccessUnchecked(str3, i2));
            for (int i3 : translateIdAttestationFlags) {
                if (i3 == 4 && !this.mInjector.mContext.getPackageManager().hasSystemFeature("android.hardware.device_unique_attestation")) {
                    throw new UnsupportedOperationException("Device Individual attestation is not supported on this device.");
                }
            }
        }
        if (TextUtils.isEmpty(keystoreAlias)) {
            throw new IllegalArgumentException("Empty alias provided.");
        }
        if (spec.getUid() != -1) {
            Slogf.e("DevicePolicyManager", "Only the caller can be granted access to the generated keypair.");
            logGenerateKeyPairFailure(callerIdentity, isCredentialManagementApp);
            return false;
        }
        if (z) {
            if (spec.getAttestationChallenge() == null) {
                throw new IllegalArgumentException("Requested Device ID attestation but challenge is empty.");
            }
            KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(spec);
            builder.setAttestationIds(translateIdAttestationFlags);
            builder.setDevicePropertiesAttestationIncluded(true);
            spec = builder.build();
        }
        Bundle bundle = new Bundle();
        bundle.putInt("userId", UserHandle.getUserId(i2));
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                try {
                    KeyChain.KeyChainConnection bindAsUser = KeyChain.bindAsUser(this.mContext, UserHandle.getUserHandleForUid(i2));
                    try {
                        IKeyChainService service = bindAsUser.getService();
                        int generateKeyPair = service.generateKeyPair(str2, new ParcelableKeyGenParameterSpec(spec));
                        if (generateKeyPair != 0) {
                            Slogf.e("DevicePolicyManager", "KeyChain failed to generate a keypair, error %d.", Integer.valueOf(generateKeyPair));
                            logGenerateKeyPairFailure(callerIdentity, isCredentialManagementApp);
                            if (generateKeyPair == 3) {
                                throw new UnsupportedOperationException("Device does not support Device ID attestation.");
                            }
                            if (generateKeyPair == 6) {
                                throw new ServiceSpecificException(1, String.format("KeyChain error: %d", Integer.valueOf(generateKeyPair)));
                            }
                            bindAsUser.close();
                            this.mInjector.getClass();
                            Binder.restoreCallingIdentity(clearCallingIdentity);
                            return false;
                        }
                        service.setGrant(i2, keystoreAlias, true);
                        try {
                            ArrayList arrayList = new ArrayList();
                            CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                            byte[] caCertificates = service.getCaCertificates(keystoreAlias);
                            arrayList.add(service.getCertificate(keystoreAlias));
                            if (caCertificates != null) {
                                Iterator<? extends Certificate> it = certificateFactory.generateCertificates(new ByteArrayInputStream(caCertificates)).iterator();
                                while (it.hasNext()) {
                                    arrayList.add(((X509Certificate) it.next()).getEncoded());
                                }
                            }
                            keymasterCertificateChain.shallowCopyFrom(new KeymasterCertificateChain(arrayList));
                            DevicePolicyEventLogger.createEvent(59).setAdmin(str3).setBoolean(isCallerDelegate).setInt(i).setStrings(new String[]{str2, isCredentialManagementApp ? "credentialManagementApp" : "notCredentialManagementApp"}).setKnoxBundleValue(bundle).write();
                            bindAsUser.close();
                            this.mInjector.getClass();
                            Binder.restoreCallingIdentity(clearCallingIdentity);
                            return true;
                        } catch (CertificateException e) {
                            logGenerateKeyPairFailure(callerIdentity, isCredentialManagementApp);
                            Slogf.e("DevicePolicyManager", "While retrieving certificate chain.", e);
                            bindAsUser.close();
                            this.mInjector.getClass();
                            Binder.restoreCallingIdentity(clearCallingIdentity);
                            return false;
                        }
                    } finally {
                    }
                } catch (InterruptedException e2) {
                    Slogf.w("DevicePolicyManager", "Interrupted while generating keypair", e2);
                    Thread.currentThread().interrupt();
                    injector = this.mInjector;
                    injector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    logGenerateKeyPairFailure(callerIdentity, isCredentialManagementApp);
                    return false;
                }
            } catch (RemoteException | AssertionError e3) {
                Slogf.e("DevicePolicyManager", "KeyChain error while generating a keypair", e3);
                injector = this.mInjector;
                injector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                logGenerateKeyPairFailure(callerIdentity, isCredentialManagementApp);
                return false;
            }
        } catch (Throwable th) {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            throw th;
        }
    }

    public final String[] getAccountTypesWithManagementDisabled(String str) {
        return getAccountTypesWithManagementDisabledAsUser(UserHandle.getCallingUserId(), str, false);
    }

    public final String[] getAccountTypesWithManagementDisabledAsUser(int i, String str, boolean z) {
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        ArraySet arraySet = new ArraySet();
        int profileParentId = z ? getProfileParentId(i) : i;
        if (!hasPermission("android.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT", str, profileParentId) && !hasFullCrossUsersPermission(callerIdentity, i)) {
            throw new SecurityException(VibrationParam$1$$ExternalSyntheticOutline0.m(profileParentId, "Caller does not have permission to call this on user: "));
        }
        for (AccountTypePolicyKey accountTypePolicyKey : this.mDevicePolicyEngine.getLocalPolicyKeysSetByAllAdmins(PolicyDefinition.GENERIC_ACCOUNT_MANAGEMENT_DISABLED, profileParentId)) {
            if (!(accountTypePolicyKey instanceof AccountTypePolicyKey)) {
                throw new IllegalStateException("PolicyKey for MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT is not of type AccountTypePolicyKey");
            }
            String accountType = accountTypePolicyKey.getAccountType();
            Objects.requireNonNull(accountType);
            Boolean bool = (Boolean) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(accountType), profileParentId);
            if (bool != null && bool.booleanValue()) {
                arraySet.add(accountType);
            }
        }
        return (String[]) arraySet.toArray(new String[arraySet.size()]);
    }

    public final ActiveAdmin getActiveAdminForCallerLocked(int i, ComponentName componentName) {
        return getActiveAdminOrCheckPermissionsForCallerLocked(componentName, i, Set.of());
    }

    public final ActiveAdmin getActiveAdminForCallerLockedMDM(int i, int i2, ComponentName componentName) {
        ensureLocked();
        ActiveAdmin activeAdminWithPolicyLockedMDM = getActiveAdminWithPolicyLockedMDM(i, i2, componentName);
        if (activeAdminWithPolicyLockedMDM != null) {
            return activeAdminWithPolicyLockedMDM;
        }
        if (componentName != null) {
            ActiveAdmin activeAdmin = (ActiveAdmin) getUserData(i2).mAdminMap.get(componentName);
            throw new SecurityException("Admin " + activeAdmin.info.getComponent() + " did not specify uses-policy for: " + activeAdmin.info.getTagForPolicy(i));
        }
        StringBuilder sb = new StringBuilder("No active admin owned by uid ");
        this.mInjector.getClass();
        sb.append(Binder.getCallingUid());
        sb.append(" for policy #");
        sb.append(i);
        throw new SecurityException(sb.toString());
    }

    public final ActiveAdmin getActiveAdminForCallerLockedMDM(int i, ComponentName componentName, boolean z) {
        ensureLocked();
        ActiveAdmin activeAdminWithPolicyLockedMDM = getActiveAdminWithPolicyLockedMDM(20, i, componentName);
        if (activeAdminWithPolicyLockedMDM != null) {
            return z ? activeAdminWithPolicyLockedMDM.getParentActiveAdmin() : activeAdminWithPolicyLockedMDM;
        }
        if (componentName == null) {
            StringBuilder sb = new StringBuilder("No active admin owned by uid ");
            this.mInjector.getClass();
            sb.append(Binder.getCallingUid());
            sb.append(" for policy #20");
            throw new SecurityException(sb.toString());
        }
        ActiveAdmin activeAdmin = (ActiveAdmin) getUserData(i).mAdminMap.get(componentName);
        throw new SecurityException("Admin " + activeAdmin.info.getComponent() + " did not specify uses-policy for: " + activeAdmin.info.getTagForPolicy(20));
    }

    public final ActiveAdmin getActiveAdminForUidLocked(int i, ComponentName componentName) {
        ensureLocked();
        ActiveAdmin activeAdmin = (ActiveAdmin) getUserData(UserHandle.getUserId(i)).mAdminMap.get(componentName);
        if (activeAdmin == null) {
            throw new SecurityException("No active admin " + componentName + " for UID " + i);
        }
        if (activeAdmin.getUid() == i) {
            return activeAdmin;
        }
        throw new SecurityException("Admin " + componentName + " is not owned by uid " + i);
    }

    public final ActiveAdmin getActiveAdminOrCheckPermissionForCallerLocked(ComponentName componentName, String str, int i, boolean z) {
        Set of = str == null ? Set.of() : Set.of(str);
        ensureLocked();
        if (z) {
            Preconditions.checkCallingUser(isManagedProfile(UserHandle.getUserId(getCallerIdentity(null, null).mUid)));
        }
        ActiveAdmin activeAdminOrCheckPermissionsForCallerLocked = getActiveAdminOrCheckPermissionsForCallerLocked(componentName, i, of);
        return z ? activeAdminOrCheckPermissionsForCallerLocked.getParentActiveAdmin() : activeAdminOrCheckPermissionsForCallerLocked;
    }

    public final ActiveAdmin getActiveAdminOrCheckPermissionsForCallerLocked(ComponentName componentName, int i, Set set) {
        String str;
        ensureLocked();
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        ActiveAdmin activeAdminWithPolicyForUidLocked = getActiveAdminWithPolicyForUidLocked(i, callerIdentity.mUid, componentName);
        if (activeAdminWithPolicyForUidLocked != null) {
            return activeAdminWithPolicyForUidLocked;
        }
        Iterator it = set.iterator();
        while (it.hasNext()) {
            if (hasCallingPermission((String) it.next())) {
                return null;
            }
        }
        int i2 = callerIdentity.mUid;
        if (componentName == null) {
            StringBuilder sb = new StringBuilder("No active admin owned by uid ");
            sb.append(i2);
            sb.append(" for policy #");
            sb.append(i);
            if (set.isEmpty()) {
                str = "";
            } else {
                str = ", which doesn't have " + set;
            }
            sb.append(str);
            throw new SecurityException(sb.toString());
        }
        ActiveAdmin activeAdmin = (ActiveAdmin) getUserData(UserHandle.getUserId(i2)).mAdminMap.get(componentName);
        boolean isDeviceOwner = isDeviceOwner(UserHandle.getUserId(i2), activeAdmin.info.getComponent());
        boolean isProfileOwner = isProfileOwner(UserHandle.getUserId(i2), activeAdmin.info.getComponent());
        if (!((ArraySet) DA_DISALLOWED_POLICIES).contains(Integer.valueOf(i)) || isDeviceOwner || isProfileOwner) {
            throw new SecurityException("Admin " + activeAdmin.info.getComponent() + " did not specify uses-policy for: " + activeAdmin.info.getTagForPolicy(i));
        }
        throw new SecurityException("Admin " + activeAdmin.info.getComponent() + " is not a device owner or profile owner, so may not use policy: " + activeAdmin.info.getTagForPolicy(i));
    }

    public final Set getActiveAdminPackagesLocked(int i) {
        DevicePolicyData userData = getUserData(i);
        ArraySet arraySet = null;
        for (int size = userData.mAdminList.size() - 1; size >= 0; size--) {
            String packageName = ((ActiveAdmin) userData.mAdminList.get(size)).info.getPackageName();
            if (arraySet == null) {
                arraySet = new ArraySet();
            }
            arraySet.add(packageName);
        }
        return arraySet;
    }

    public final ActiveAdmin getActiveAdminUncheckedLocked(int i, ComponentName componentName) {
        ensureLocked();
        ActiveAdmin activeAdmin = (ActiveAdmin) getUserData(i).mAdminMap.get(componentName);
        if (activeAdmin != null && componentName.getPackageName().equals(activeAdmin.info.getActivityInfo().packageName) && componentName.getClassName().equals(activeAdmin.info.getActivityInfo().name)) {
            return activeAdmin;
        }
        return null;
    }

    public final ActiveAdmin getActiveAdminUncheckedLocked(int i, ComponentName componentName, boolean z) {
        ensureLocked();
        if (z) {
            Preconditions.checkCallAuthorization(isManagedProfile(i), "You can not call APIs on the parent profile outside a managed profile, userId = %d", new Object[]{Integer.valueOf(i)});
        }
        ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
        return (activeAdminUncheckedLocked == null || !z) ? activeAdminUncheckedLocked : activeAdminUncheckedLocked.getParentActiveAdmin();
    }

    public final ActiveAdmin getActiveAdminWithPolicyForUidLocked(int i, int i2, ComponentName componentName) {
        ensureLocked();
        int userId = UserHandle.getUserId(i2);
        DevicePolicyData userData = getUserData(userId);
        if (componentName == null) {
            Iterator it = userData.mAdminList.iterator();
            while (it.hasNext()) {
                ActiveAdmin activeAdmin = (ActiveAdmin) it.next();
                if (activeAdmin.getUid() == i2 && isActiveAdminWithPolicyForUserLocked(activeAdmin, i, userId)) {
                    return activeAdmin;
                }
            }
            return null;
        }
        ActiveAdmin activeAdmin2 = (ActiveAdmin) userData.mAdminMap.get(componentName);
        if (activeAdmin2 != null && activeAdmin2.getUid() == i2) {
            if (SemPersonaManager.isContainerServicebyUID(Binder.getCallingUid()) || isActiveAdminWithPolicyForUserLocked(activeAdmin2, i, userId)) {
                return activeAdmin2;
            }
            return null;
        }
        throw new SecurityException("Admin " + componentName + " is not active or not owned by uid " + i2);
    }

    public final ActiveAdmin getActiveAdminWithPolicyLockedMDM(int i, int i2, ComponentName componentName) {
        ensureLocked();
        DevicePolicyData userData = getUserData(i2);
        if (componentName != null) {
            ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminMap.get(componentName);
            if (activeAdmin == null) {
                throw new SecurityException(AmbientContextManagerPerUserService$$ExternalSyntheticOutline0.m(componentName, "No active admin "));
            }
            this.mInjector.getClass();
            if (Binder.getCallingPid() == Process.myPid() && isActiveAdminWithPolicyForUserLockedMDM(activeAdmin, i, i2)) {
                return activeAdmin;
            }
            return null;
        }
        Iterator it = userData.mAdminList.iterator();
        while (it.hasNext()) {
            ActiveAdmin activeAdmin2 = (ActiveAdmin) it.next();
            this.mInjector.getClass();
            if (Binder.getCallingPid() == Process.myPid() && isActiveAdminWithPolicyForUserLockedMDM(activeAdmin2, i, i2)) {
                return activeAdmin2;
            }
        }
        return null;
    }

    public final List getActiveAdmins(int i) {
        if (!this.mHasFeature) {
            return Collections.EMPTY_LIST;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userData = getUserData(i);
                int size = userData.mAdminList.size();
                if (size <= 0) {
                    return null;
                }
                ArrayList arrayList = new ArrayList(size);
                for (int i2 = 0; i2 < size; i2++) {
                    arrayList.add(((ActiveAdmin) userData.mAdminList.get(i2)).info.getComponent());
                }
                return arrayList;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final List getActiveAdminsForLockscreenPoliciesLocked(int i) {
        if (!isSeparateProfileChallengeEnabled(i)) {
            if (!isPermissionCheckFlagEnabled()) {
                return getActiveAdminsForUserAndItsManagedProfilesLocked(getProfileParentId(i), new DevicePolicyManagerService$$ExternalSyntheticLambda123(this, 1));
            }
            int profileParentId = getProfileParentId(i);
            DevicePolicyManagerService$$ExternalSyntheticLambda123 devicePolicyManagerService$$ExternalSyntheticLambda123 = new DevicePolicyManagerService$$ExternalSyntheticLambda123(this, 0);
            ArrayList arrayList = new ArrayList();
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda218 devicePolicyManagerService$$ExternalSyntheticLambda218 = new DevicePolicyManagerService$$ExternalSyntheticLambda218(this, profileParentId, arrayList, devicePolicyManagerService$$ExternalSyntheticLambda123, 1);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda218);
            return arrayList;
        }
        if (!isPermissionCheckFlagEnabled()) {
            return getUserDataUnchecked(i).mAdminList;
        }
        if (isManagedProfile(i)) {
            ArrayList arrayList2 = getUserDataUnchecked(i).mAdminList;
        }
        DevicePolicyManagerService$$ExternalSyntheticLambda9 devicePolicyManagerService$$ExternalSyntheticLambda9 = new DevicePolicyManagerService$$ExternalSyntheticLambda9(0);
        ArrayList arrayList3 = new ArrayList();
        Injector injector2 = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda218 devicePolicyManagerService$$ExternalSyntheticLambda2182 = new DevicePolicyManagerService$$ExternalSyntheticLambda218(this, i, arrayList3, devicePolicyManagerService$$ExternalSyntheticLambda9, 1);
        injector2.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda2182);
        if (getUserData(i).mPermissionBasedAdmin != null) {
            arrayList3.add(getUserData(i).mPermissionBasedAdmin);
        }
        return arrayList3;
    }

    public final List getActiveAdminsForUserAndItsManagedProfilesLocked(int i, Predicate predicate) {
        ArrayList arrayList = new ArrayList();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda218 devicePolicyManagerService$$ExternalSyntheticLambda218 = new DevicePolicyManagerService$$ExternalSyntheticLambda218(this, i, arrayList, predicate, 0);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda218);
        return arrayList;
    }

    public final ActiveAdmin getAdminWithMinimumFailedPasswordsForWipeLocked(int i, boolean z) {
        int i2;
        ArrayList arrayList = (ArrayList) getActiveAdminsForLockscreenPoliciesLocked(getProfileParentUserIfRequested(i, z));
        int size = arrayList.size();
        ActiveAdmin activeAdmin = null;
        int i3 = 0;
        for (int i4 = 0; i4 < size; i4++) {
            ActiveAdmin activeAdmin2 = (ActiveAdmin) arrayList.get(i4);
            if (activeAdmin2.maximumFailedPasswordsForWipe != 0) {
                int userIdToWipeForFailedPasswords = getUserIdToWipeForFailedPasswords(activeAdmin2);
                if (i3 == 0 || i3 > (i2 = activeAdmin2.maximumFailedPasswordsForWipe) || (i3 == i2 && getUserInfo(userIdToWipeForFailedPasswords).isPrimary())) {
                    i3 = activeAdmin2.maximumFailedPasswordsForWipe;
                    activeAdmin = activeAdmin2;
                }
            }
        }
        return activeAdmin;
    }

    public final int getAffectedUser(boolean z) {
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        return z ? getProfileParentId(userHandleGetCallingUserId) : userHandleGetCallingUserId;
    }

    public final List getAffiliationIds(ComponentName componentName) {
        ArrayList arrayList;
        if (!this.mHasFeature) {
            return Collections.emptyList();
        }
        Objects.requireNonNull(componentName);
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            arrayList = new ArrayList(getUserData(UserHandle.getUserId(callerIdentity.mUid)).mAffiliationIds);
        }
        return arrayList;
    }

    public final int getAggregatedPasswordComplexityForUser(int i, boolean z) {
        int aggregatedPasswordComplexityLocked;
        if (!this.mHasFeature) {
            return 0;
        }
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            aggregatedPasswordComplexityLocked = getAggregatedPasswordComplexityLocked(i, z);
        }
        return aggregatedPasswordComplexityLocked;
    }

    public final int getAggregatedPasswordComplexityLocked(int i, boolean z) {
        Integer num;
        int i2 = 0;
        if (!Flags.unmanagedModeMigration()) {
            ensureLocked();
            Iterator it = (z ? getActiveAdminsForUserAndItsManagedProfilesLocked(i, new DevicePolicyManagerService$$ExternalSyntheticLambda9(0)) : getActiveAdminsForLockscreenPoliciesLocked(i)).iterator();
            while (it.hasNext()) {
                i2 = Math.max(i2, ((ActiveAdmin) it.next()).mPasswordComplexity);
            }
            return i2;
        }
        ensureLocked();
        if (z) {
            num = (Integer) getResolvedPolicyForUserAndItsManagedProfiles(PolicyDefinition.PASSWORD_COMPLEXITY, i, new DevicePolicyManagerService$$ExternalSyntheticLambda9(0));
        } else {
            PolicyDefinition policyDefinition = PolicyDefinition.PASSWORD_COMPLEXITY;
            num = (Integer) (isSeparateProfileChallengeEnabled(i) ? this.mDevicePolicyEngine.getResolvedPolicy(policyDefinition, i) : getResolvedPolicyForUserAndItsManagedProfiles(policyDefinition, getProfileParentId(i), new DevicePolicyManagerService$$ExternalSyntheticLambda123(this, 2)));
        }
        if (num != null) {
            return num.intValue();
        }
        return 0;
    }

    /* JADX WARN: Removed duplicated region for block: B:19:0x0054 A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final java.util.List getAllCrossProfilePackages(int r7) {
        /*
            r6 = this;
            boolean r0 = r6.mHasFeature
            if (r0 != 0) goto L9
            java.util.List r6 = java.util.Collections.emptyList()
            return r6
        L9:
            r0 = 0
            com.android.server.devicepolicy.CallerIdentity r0 = r6.getCallerIdentity(r0, r0)
            boolean r1 = isSystemUid(r0)
            r2 = 0
            if (r1 != 0) goto L4b
            int r1 = r0.mUid
            boolean r1 = android.os.UserHandle.isSameApp(r1, r2)
            if (r1 != 0) goto L4b
            java.lang.String r1 = "android.permission.INTERACT_ACROSS_USERS"
            boolean r1 = r6.hasCallingPermission(r1)
            if (r1 != 0) goto L4b
            java.lang.String r1 = "android.permission.INTERACT_ACROSS_USERS_FULL"
            boolean r1 = r6.hasCallingPermission(r1)
            if (r1 != 0) goto L4b
            java.lang.String r1 = "android.permission.INTERACT_ACROSS_PROFILES"
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r3 = r6.mInjector
            r3.getClass()
            int r3 = android.os.Binder.getCallingPid()
            android.content.Context r4 = r6.mContext
            java.lang.String r4 = r4.getPackageName()
            android.content.Context r5 = r6.mContext
            int r0 = r0.mUid
            int r0 = android.content.PermissionChecker.checkPermissionForPreflight(r5, r1, r3, r0, r4)
            if (r0 != 0) goto L49
            goto L4b
        L49:
            r0 = r2
            goto L4c
        L4b:
            r0 = 1
        L4c:
            com.android.internal.util.Preconditions.checkCallAuthorization(r0)
            java.lang.Object r0 = r6.getLockObject()
            monitor-enter(r0)
            java.util.List r7 = r6.getProfileOwnerAdminsForProfileGroup(r7)     // Catch: java.lang.Throwable -> L7d
            java.util.ArrayList r1 = new java.util.ArrayList     // Catch: java.lang.Throwable -> L7d
            r1.<init>()     // Catch: java.lang.Throwable -> L7d
        L5d:
            r3 = r7
            java.util.ArrayList r3 = (java.util.ArrayList) r3     // Catch: java.lang.Throwable -> L7d
            int r4 = r3.size()     // Catch: java.lang.Throwable -> L7d
            if (r2 >= r4) goto L74
            java.lang.Object r3 = r3.get(r2)     // Catch: java.lang.Throwable -> L7d
            com.android.server.devicepolicy.ActiveAdmin r3 = (com.android.server.devicepolicy.ActiveAdmin) r3     // Catch: java.lang.Throwable -> L7d
            java.util.List r3 = r3.mCrossProfilePackages     // Catch: java.lang.Throwable -> L7d
            r1.addAll(r3)     // Catch: java.lang.Throwable -> L7d
            int r2 = r2 + 1
            goto L5d
        L74:
            java.util.List r6 = r6.getDefaultCrossProfilePackages()     // Catch: java.lang.Throwable -> L7d
            r1.addAll(r6)     // Catch: java.lang.Throwable -> L7d
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L7d
            return r1
        L7d:
            r6 = move-exception
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L7d
            throw r6
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.getAllCrossProfilePackages(int):java.util.List");
    }

    public final List getAlwaysOnVpnLockdownAllowlist(ComponentName componentName) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 4);
        injector.getClass();
        return (List) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7);
    }

    public final String getAlwaysOnVpnPackage(ComponentName componentName) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 5);
        injector.getClass();
        return (String) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7);
    }

    public final String getAlwaysOnVpnPackageForUser(int i) {
        String str;
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can call getAlwaysOnVpnPackageForUser");
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(i);
                str = deviceOrProfileOwnerAdminLocked != null ? deviceOrProfileOwnerAdminLocked.mAlwaysOnVpnPackage : null;
            } catch (Throwable th) {
                throw th;
            }
        }
        return str;
    }

    public final ApnSetting getApnSetting(int i) {
        ApnSetting apnSetting = null;
        if (i < 0) {
            return null;
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, i, 5);
        injector.getClass();
        Cursor cursor = (Cursor) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6);
        if (cursor != null) {
            while (cursor.moveToNext() && (apnSetting = ApnSetting.makeApnSetting(cursor)) == null) {
            }
            cursor.close();
        }
        return apnSetting;
    }

    public final int[] getApplicationExemptions(String str) {
        if (!this.mHasFeature) {
            return new int[0];
        }
        Preconditions.checkStringNotEmpty(str, "Package name cannot be empty.");
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_DEVICE_POLICY_APP_EXEMPTIONS"));
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        this.mInjector.getClass();
        PackageManagerInternal packageManagerInternal = Injector.getPackageManagerInternal();
        int i = callerIdentity.mUid;
        ApplicationInfo applicationInfo = packageManagerInternal.getApplicationInfo(i, UserHandle.getUserId(i), 0L, str);
        if (applicationInfo == null) {
            throw new ServiceSpecificException(1, "Package name not found.");
        }
        IntArray intArray = new IntArray(0);
        for (Map.Entry entry : ((ArrayMap) APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS).entrySet()) {
            if (this.mInjector.getAppOpsManager().unsafeCheckOpNoThrow((String) entry.getValue(), applicationInfo.uid, applicationInfo.packageName) == 0) {
                intArray.add(((Integer) entry.getKey()).intValue());
            }
        }
        return intArray.toArray();
    }

    public final Bundle getApplicationRestrictions(ComponentName componentName, String str, String str2, boolean z) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        boolean z2 = true;
        boolean z3 = false;
        if (!Flags.dmrhSetAppRestrictions()) {
            if ((!callerIdentity.hasAdminComponent() || (!isProfileOwner(callerIdentity) && !isDefaultDeviceOwner(callerIdentity))) && (!callerIdentity.hasPackage() || !isCallerDelegate(callerIdentity, "delegation-app-restrictions"))) {
                z2 = false;
            }
            Preconditions.checkCallAuthorization(z2);
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda10 devicePolicyManagerService$$ExternalSyntheticLambda10 = new DevicePolicyManagerService$$ExternalSyntheticLambda10(this, str2, callerIdentity, 3);
            injector.getClass();
            return (Bundle) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda10);
        }
        if (componentName != null) {
            if (z || (!isProfileOwner(callerIdentity) && !isDefaultDeviceOwner(callerIdentity))) {
                z2 = false;
            }
            Preconditions.checkCallAuthorization(z2);
        } else {
            boolean doesCallerHoldRole = doesCallerHoldRole(callerIdentity, "android.app.role.DEVICE_POLICY_MANAGEMENT");
            if (z) {
                Preconditions.checkCallAuthorization(doesCallerHoldRole);
                Preconditions.checkState(isOrganizationOwnedDeviceWithManagedProfile(), "Role Holder can only operate parent app restriction on COPE devices");
            } else {
                if (!doesCallerHoldRole && !isCallerDelegate(callerIdentity, "delegation-app-restrictions")) {
                    z2 = false;
                }
                Preconditions.checkCallAuthorization(z2);
            }
            z3 = doesCallerHoldRole;
        }
        if (z3) {
            EnforcingAdmin enforcingAdminForCaller = getEnforcingAdminForCaller(null, callerIdentity.mPackageName);
            int i = callerIdentity.mUid;
            LinkedHashMap localPoliciesSetByAdmins = this.mDevicePolicyEngine.getLocalPoliciesSetByAdmins(PolicyDefinition.APPLICATION_RESTRICTIONS(str2), z ? getProfileParentId(UserHandle.getUserId(i)) : UserHandle.getUserId(i));
            return !localPoliciesSetByAdmins.containsKey(enforcingAdminForCaller) ? Bundle.EMPTY : (Bundle) ((PolicyValue) localPoliciesSetByAdmins.get(enforcingAdminForCaller)).getValue();
        }
        Injector injector2 = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda10 devicePolicyManagerService$$ExternalSyntheticLambda102 = new DevicePolicyManagerService$$ExternalSyntheticLambda10(this, str2, callerIdentity, 2);
        injector2.getClass();
        return (Bundle) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda102);
    }

    public final Bundle getApplicationRestrictionsMDM(ComponentName componentName, String str, int i) {
        KnoxPolicyHelper knoxPolicyHelper = this.mKnoxPolicyHelper;
        knoxPolicyHelper.getClass();
        ContextInfo contextInfo = new ContextInfo(Binder.getCallingUid(), i);
        knoxPolicyHelper.getEDM().enforceComponentCheck(contextInfo, componentName);
        knoxPolicyHelper.getEDM().enforceActiveAdminPermissionByContext(contextInfo, new ArrayList(Arrays.asList("com.samsung.android.knox.permission.KNOX_APP_MGMT")));
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            Bundle applicationRestrictions = knoxPolicyHelper.mUserManager.getApplicationRestrictions(str, new UserHandle(i));
            if (applicationRestrictions == null) {
                applicationRestrictions = Bundle.EMPTY;
            }
            return applicationRestrictions;
        } finally {
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final String getApplicationRestrictionsManagingPackage(ComponentName componentName) {
        ArrayList arrayList = (ArrayList) getDelegatePackages(componentName, "delegation-app-restrictions");
        if (arrayList.size() > 0) {
            return (String) arrayList.get(0);
        }
        return null;
    }

    public final boolean getAutoTimeEnabled(ComponentName componentName, String str) {
        if (!this.mHasFeature) {
            return false;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        return this.mInjector.settingsGlobalGetInt("auto_time") > 0;
    }

    public final boolean getAutoTimeRequired() {
        if (!this.mHasFeature) {
            return false;
        }
        DevicePolicyEngine devicePolicyEngine = this.mDevicePolicyEngine;
        PolicyDefinition policyDefinitionForUserRestriction = PolicyDefinition.getPolicyDefinitionForUserRestriction("no_config_date_time");
        this.mInjector.getClass();
        Boolean bool = (Boolean) devicePolicyEngine.getResolvedPolicy(policyDefinitionForUserRestriction, Binder.getCallingUserHandle().getIdentifier());
        return bool != null && bool.booleanValue();
    }

    public final boolean getAutoTimeZoneEnabled(ComponentName componentName, String str) {
        if (!this.mHasFeature) {
            return false;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        return this.mInjector.settingsGlobalGetInt("auto_time_zone") > 0;
    }

    public final List getBindDeviceAdminTargetUsers(ComponentName componentName) {
        List list;
        if (!this.mHasFeature) {
            return Collections.emptyList();
        }
        Objects.requireNonNull(componentName);
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda64 devicePolicyManagerService$$ExternalSyntheticLambda64 = new DevicePolicyManagerService$$ExternalSyntheticLambda64(this, componentName, userId, 1);
            injector.getClass();
            list = (List) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda64);
        }
        return list;
    }

    public final boolean getBluetoothContactSharingDisabled(ComponentName componentName) {
        boolean z;
        if (!this.mHasFeature) {
            return false;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        synchronized (getLockObject()) {
            z = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).disableBluetoothContactSharing;
        }
        return z;
    }

    public final boolean getBluetoothContactSharingDisabledForUser(int i) {
        boolean z;
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                z = profileOwnerAdminLocked != null ? profileOwnerAdminLocked.disableBluetoothContactSharing : false;
            } catch (Throwable th) {
                throw th;
            }
        }
        return z;
    }

    public CallerIdentity getCallerIdentity(ComponentName componentName) {
        return getCallerIdentity(componentName, null);
    }

    public CallerIdentity getCallerIdentity(ComponentName componentName, String str) {
        this.mInjector.getClass();
        int callingUid = Binder.getCallingUid();
        if (str != null && !isCallingFromPackage(callingUid, str)) {
            throw new SecurityException(String.format("Caller with uid %d is not %s", Integer.valueOf(callingUid), str));
        }
        if (componentName != null) {
            ActiveAdmin activeAdmin = (ActiveAdmin) getUserData(UserHandle.getUserId(callingUid)).mAdminMap.get(componentName);
            if (activeAdmin == null || !(activeAdmin.getUid() == callingUid || SemPersonaManager.isContainerServicebyUID(Binder.getCallingUid()) || callingUid == 1000)) {
                throw new SecurityException(String.format("Admin %s does not exist or is not owned by uid %d", componentName, Integer.valueOf(callingUid)));
            }
            if (str != null && !SemPersonaManager.isContainerServicebyUID(Binder.getCallingUid())) {
                this.mInjector.getClass();
                this.mKnoxPolicyHelper.getClass();
                if (callingUid != 1000 || !str.equals("com.samsung.sept.AdminPolicy")) {
                    Preconditions.checkArgument(str.equals(componentName.getPackageName()));
                }
            }
            str = componentName.getPackageName();
        }
        return new CallerIdentity(componentName, callingUid, str);
    }

    /* JADX WARN: Code restructure failed: missing block: B:12:0x002a, code lost:
    
        if (hasPermission("android.permission.QUERY_ADMIN_POLICY", r3) == false) goto L14;
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final boolean getCameraDisabled(android.content.ComponentName r5, java.lang.String r6, int r7, boolean r8) {
        /*
            r4 = this;
            boolean r0 = r4.mHasFeature
            r1 = 0
            if (r0 != 0) goto L6
            return r1
        L6:
            com.android.server.devicepolicy.CallerIdentity r0 = r4.getCallerIdentity(r5, r6)
            boolean r2 = r4.hasFullCrossUsersPermission(r0, r7)
            if (r2 != 0) goto L2c
            r2 = 1047(0x417, float:1.467E-42)
            int r3 = r0.mUid
            boolean r2 = android.os.UserHandle.isSameApp(r3, r2)
            if (r2 != 0) goto L2c
            java.lang.String r2 = "android.permission.MANAGE_DEVICE_POLICY_CAMERA"
            java.lang.String r3 = r0.mPackageName
            boolean r2 = r4.hasPermission(r2, r3, r7)
            if (r2 != 0) goto L2c
            java.lang.String r2 = "android.permission.QUERY_ADMIN_POLICY"
            boolean r2 = r4.hasPermission(r2, r3)
            if (r2 == 0) goto L2d
        L2c:
            r1 = 1
        L2d:
            com.android.internal.util.Preconditions.checkCallAuthorization(r1)
            if (r8 == 0) goto L36
            int r7 = r4.getProfileParentId(r7)
        L36:
            java.lang.String r8 = "no_camera"
            com.android.server.devicepolicy.PolicyDefinition r8 = com.android.server.devicepolicy.PolicyDefinition.getPolicyDefinitionForUserRestriction(r8)
            if (r5 == 0) goto L61
            com.android.server.devicepolicy.EnforcingAdmin r5 = r4.getEnforcingAdminForCaller(r5, r6)
            boolean r6 = r4.isDeviceOwner(r0)
            if (r6 == 0) goto L52
            com.android.server.devicepolicy.DevicePolicyEngine r4 = r4.mDevicePolicyEngine
            java.lang.Object r4 = r4.getGlobalPolicySetByAdmin(r8, r5)
            java.lang.Boolean r4 = (java.lang.Boolean) r4
            goto L5a
        L52:
            com.android.server.devicepolicy.DevicePolicyEngine r4 = r4.mDevicePolicyEngine
            java.lang.Object r4 = r4.getLocalPolicySetByAdmin(r8, r5, r7)
            java.lang.Boolean r4 = (java.lang.Boolean) r4
        L5a:
            java.lang.Boolean r5 = java.lang.Boolean.TRUE
            boolean r4 = r5.equals(r4)
            return r4
        L61:
            java.lang.Boolean r5 = java.lang.Boolean.TRUE
            com.android.server.devicepolicy.DevicePolicyEngine r4 = r4.mDevicePolicyEngine
            java.lang.Object r4 = r4.getResolvedPolicy(r8, r7)
            boolean r4 = r5.equals(r4)
            return r4
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.getCameraDisabled(android.content.ComponentName, java.lang.String, int, boolean):boolean");
    }

    public final String getCertInstallerPackage(ComponentName componentName) {
        ArrayList arrayList = (ArrayList) getDelegatePackages(componentName, "delegation-cert-install");
        if (arrayList.size() > 0) {
            return (String) arrayList.get(0);
        }
        return null;
    }

    public final WifiSsidPolicy getCombinedWifiSsidPolicyLocked() {
        List activeAdminsForUserAndItsManagedProfilesLocked = getActiveAdminsForUserAndItsManagedProfilesLocked(0, new DevicePolicyManagerService$$ExternalSyntheticLambda9(4));
        this.mKnoxPolicyHelper.getClass();
        ArraySet arraySet = new ArraySet();
        ArraySet arraySet2 = new ArraySet();
        Iterator it = ((ArrayList) activeAdminsForUserAndItsManagedProfilesLocked).iterator();
        while (it.hasNext()) {
            WifiSsidPolicy wifiSsidPolicy = ((ActiveAdmin) it.next()).mWifiSsidPolicy;
            if (wifiSsidPolicy != null) {
                if (wifiSsidPolicy.getPolicyType() == 0) {
                    arraySet.addAll(wifiSsidPolicy.getSsids());
                } else if (wifiSsidPolicy.getPolicyType() == 1) {
                    arraySet2.addAll(wifiSsidPolicy.getSsids());
                }
            }
        }
        if (!arraySet.isEmpty()) {
            return new WifiSsidPolicy(0, arraySet);
        }
        if (arraySet2.isEmpty()) {
            return null;
        }
        return new WifiSsidPolicy(1, arraySet2);
    }

    public final int getContentProtectionPolicy(ComponentName componentName, String str) {
        if (!com.android.internal.hidden_from_bootclasspath.android.view.contentprotection.flags.Flags.manageDevicePolicyEnabled()) {
            return 1;
        }
        int userId = UserHandle.getUserId(getCallerIdentity(componentName, str).mUid);
        enforceCanQuery(userId, "android.permission.MANAGE_DEVICE_POLICY_CONTENT_PROTECTION", str);
        Integer num = (Integer) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.CONTENT_PROTECTION, userId);
        if (num == null) {
            return 1;
        }
        return num.intValue();
    }

    public final PackagePolicy getCredentialManagerPolicy(int i) {
        PackagePolicy packagePolicy;
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(canWriteCredentialManagerPolicy(callerIdentity) || hasCallingOrSelfPermission("android.permission.QUERY_ADMIN_POLICY"));
        if (i != UserHandle.getUserId(callerIdentity.mUid)) {
            Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS"));
        }
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(i);
                packagePolicy = profileOwnerOrDeviceOwnerLocked != null ? profileOwnerOrDeviceOwnerLocked.mCredentialManagerPolicy : null;
            } catch (Throwable th) {
                throw th;
            }
        }
        return packagePolicy;
    }

    public final int getCredentialOwner(final int i, final boolean z) {
        Injector injector = this.mInjector;
        FunctionalUtils.ThrowingSupplier throwingSupplier = new FunctionalUtils.ThrowingSupplier() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda8
            public final Object getOrThrow() {
                UserInfo profileParent;
                DevicePolicyManagerService devicePolicyManagerService = this;
                int i2 = i;
                if (z && (profileParent = devicePolicyManagerService.mUserManager.getProfileParent(i2)) != null) {
                    i2 = profileParent.id;
                }
                return Integer.valueOf(devicePolicyManagerService.mUserManager.getCredentialOwnerProfile(i2));
            }
        };
        injector.getClass();
        return ((Integer) Binder.withCleanCallingIdentity(throwingSupplier)).intValue();
    }

    public final List getCrossProfileCalendarPackages(ComponentName componentName) {
        List list;
        if (!this.mHasFeature) {
            return Collections.emptyList();
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
        synchronized (getLockObject()) {
            list = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).mCrossProfileCalendarPackages;
        }
        return list;
    }

    public final List getCrossProfileCalendarPackagesForUser(int i) {
        if (!this.mHasFeature) {
            return Collections.emptyList();
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS") || hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL"));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                if (profileOwnerAdminLocked != null) {
                    return profileOwnerAdminLocked.mCrossProfileCalendarPackages;
                }
                return Collections.emptyList();
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean getCrossProfileCallerIdDisabled(ComponentName componentName) {
        if (!this.mHasFeature) {
            return false;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                if (profileOwnerLocked == null) {
                    return false;
                }
                PackagePolicy packagePolicy = profileOwnerLocked.mManagedProfileCallerIdAccess;
                if (packagePolicy == null) {
                    return profileOwnerLocked.disableCallerId;
                }
                if (packagePolicy.getPolicyType() == 2) {
                    Slogf.w("DevicePolicyManager", "Denying callerId due to PACKAGE_POLICY_SYSTEM policyType");
                }
                return profileOwnerLocked.mManagedProfileCallerIdAccess.getPolicyType() != 1;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean getCrossProfileCallerIdDisabledForUser(int i) {
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                if (profileOwnerAdminLocked == null) {
                    return false;
                }
                PackagePolicy packagePolicy = profileOwnerAdminLocked.mManagedProfileCallerIdAccess;
                if (packagePolicy == null) {
                    return profileOwnerAdminLocked.disableCallerId;
                }
                return packagePolicy.getPolicyType() == 3;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean getCrossProfileContactsSearchDisabled(ComponentName componentName) {
        if (!this.mHasFeature) {
            return false;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                if (profileOwnerLocked == null) {
                    return false;
                }
                PackagePolicy packagePolicy = profileOwnerLocked.mManagedProfileContactsAccess;
                if (packagePolicy == null) {
                    return profileOwnerLocked.disableContactsSearch;
                }
                return packagePolicy.getPolicyType() != 1;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean getCrossProfileContactsSearchDisabledForUser(int i) {
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                if (profileOwnerAdminLocked == null) {
                    return false;
                }
                PackagePolicy packagePolicy = profileOwnerAdminLocked.mManagedProfileContactsAccess;
                if (packagePolicy == null) {
                    return profileOwnerAdminLocked.disableContactsSearch;
                }
                if (packagePolicy.getPolicyType() == 2) {
                    Slogf.w("DevicePolicyManager", "Denying contacts due to PACKAGE_POLICY_SYSTEM policyType");
                }
                return profileOwnerAdminLocked.mManagedProfileContactsAccess.getPolicyType() != 1;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final List getCrossProfilePackages(ComponentName componentName) {
        List list;
        if (!this.mHasFeature) {
            return Collections.emptyList();
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
        synchronized (getLockObject()) {
            list = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).mCrossProfilePackages;
        }
        return list;
    }

    public final List getCrossProfileWidgetProviders(ComponentName componentName, String str) {
        ActiveAdmin profileOwnerLocked;
        ActiveAdmin activeAdmin;
        CallerIdentity callerIdentity = isPermissionCheckFlagEnabled() ? getCallerIdentity(componentName, str) : getCallerIdentity(componentName);
        if (isPermissionCheckFlagEnabled()) {
            String str2 = callerIdentity.mPackageName;
            enforceCanQuery(UserHandle.getUserId(callerIdentity.mUid), "android.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION", str2);
            activeAdmin = getEnforcingAdminForCaller(componentName, str2).mActiveAdmin;
        } else {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
            }
            activeAdmin = profileOwnerLocked;
        }
        synchronized (getLockObject()) {
            try {
                List list = activeAdmin.crossProfileWidgetProviders;
                if (list != null && !((ArrayList) list).isEmpty()) {
                    this.mInjector.getClass();
                    if (Binder.getCallingUid() == Process.myUid()) {
                        return new ArrayList(activeAdmin.crossProfileWidgetProviders);
                    }
                    return activeAdmin.crossProfileWidgetProviders;
                }
                return null;
            } finally {
            }
        }
    }

    public final int getCurrentFailedBiometricAttempts(int i) {
        int i2;
        this.mInjector.getClass();
        if (i == 0 || !isManagedProfile(i)) {
            return -1;
        }
        if (!this.mLockPatternUtils.hasSecureLockScreen()) {
            return 0;
        }
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            try {
                if (!isSystemUid(getCallerIdentity(null, null)) && this.mContext.checkCallingPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE") != 0) {
                    getActiveAdminForCallerLocked(1, null);
                }
                i2 = getUserDataUnchecked(i).mFailedBiometricAttempts;
            } catch (Throwable th) {
                throw th;
            }
        }
        return i2;
    }

    public final int getCurrentFailedPasswordAttempts(String str, int i, boolean z) {
        int i2;
        if (!this.mLockPatternUtils.hasSecureLockScreen()) {
            return 0;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(callerIdentity, i));
        synchronized (getLockObject()) {
            try {
                if (!UserHandle.isSameApp(callerIdentity.mUid, 1000) && !hasCallingPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE")) {
                    if (isPermissionCheckFlagEnabled()) {
                        enforcePermission("android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", str, z ? getProfileParentId(i) : i);
                    } else {
                        getActiveAdminOrCheckPermissionForCallerLocked(null, null, 1, z);
                    }
                }
                i2 = getUserDataUnchecked(getCredentialOwner(i, z)).mFailedPasswordAttempts;
            } catch (Throwable th) {
                throw th;
            }
        }
        return i2;
    }

    public final int getCurrentForegroundUserId() {
        try {
            this.mInjector.getClass();
            UserInfo currentUser = ActivityManager.getService().getCurrentUser();
            if (currentUser != null) {
                return currentUser.id;
            }
            Slogf.wtf("DevicePolicyManager", "getCurrentForegroundUserId(): mInjector.getIActivityManager().getCurrentUser() returned null, please ignore when running unit tests");
            return ActivityManager.getCurrentUser();
        } catch (RemoteException e) {
            Slogf.wtf("DevicePolicyManager", "cannot get current user", e);
            return -10000;
        }
    }

    public final List getDefaultCrossProfilePackages() {
        HashSet hashSet = new HashSet();
        try {
            if (this.mOwners.hasDeviceOwner()) {
                Log.i("DevicePolicyManager", "getDefaultCrossProfilePackages : DO is enabled. Return empty list.");
                return new ArrayList();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        Collections.addAll(hashSet, this.mContext.getResources().getStringArray(17236433));
        Collections.addAll(hashSet, this.mContext.getResources().getStringArray(17236479));
        return new ArrayList(hashSet);
    }

    public final List getDelegatePackages(ComponentName componentName, String str) {
        List delegatePackagesInternalLocked;
        Objects.requireNonNull(componentName, "ComponentName is null");
        Objects.requireNonNull(str, "Scope is null");
        if (!Arrays.asList(DELEGATIONS).contains(str)) {
            throw new IllegalArgumentException("Unexpected delegation scope: ".concat(str));
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        synchronized (getLockObject()) {
            delegatePackagesInternalLocked = getDelegatePackagesInternalLocked(UserHandle.getUserId(callerIdentity.mUid), str);
        }
        return delegatePackagesInternalLocked;
    }

    public final List getDelegatePackagesInternalLocked(int i, String str) {
        DevicePolicyData userData = getUserData(i);
        ArrayList arrayList = new ArrayList();
        for (int i2 = 0; i2 < userData.mDelegationMap.size(); i2++) {
            if (((List) userData.mDelegationMap.valueAt(i2)).contains(str)) {
                arrayList.add((String) userData.mDelegationMap.keyAt(i2));
            }
        }
        return arrayList;
    }

    public final Map getDelegatedPackages(int i) {
        ArrayMap arrayMap;
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can check for delegations in a user");
        synchronized (getLockObject()) {
            arrayMap = new ArrayMap(getUserData(i).mDelegationMap);
        }
        return arrayMap;
    }

    public final List getDelegatedScopes(ComponentName componentName, String str) {
        List list;
        Objects.requireNonNull(str, "Delegate package is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        if (callerIdentity.hasAdminComponent()) {
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        } else {
            Preconditions.checkCallAuthorization(isCallingFromPackage(callerIdentity.mUid, str), String.format("Caller with uid %d is not %s", Integer.valueOf(callerIdentity.mUid), str));
        }
        synchronized (getLockObject()) {
            try {
                list = (List) getUserData(UserHandle.getUserId(callerIdentity.mUid)).mDelegationMap.get(str);
                if (list == null) {
                    list = Collections.EMPTY_LIST;
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        return list;
    }

    public final ActiveAdmin getDeviceOrProfileOwnerAdminLocked(int i) {
        ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
        if (profileOwnerAdminLocked == null) {
            return (this.mOwners.hasDeviceOwner() ? this.mOwners.getDeviceOwnerUserId() : -10000) == i ? getDeviceOwnerAdminLocked() : profileOwnerAdminLocked;
        }
        return profileOwnerAdminLocked;
    }

    public ActiveAdmin getDeviceOwnerAdminLocked() {
        ensureLocked();
        ComponentName deviceOwnerComponent = this.mOwners.getDeviceOwnerComponent();
        if (deviceOwnerComponent == null) {
            return null;
        }
        DevicePolicyData userData = getUserData(this.mOwners.getDeviceOwnerUserId());
        int size = userData.mAdminList.size();
        for (int i = 0; i < size; i++) {
            ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminList.get(i);
            if (deviceOwnerComponent.equals(activeAdmin.info.getComponent())) {
                return activeAdmin;
            }
        }
        Slogf.wtf("DevicePolicyManager", "Active admin for device owner not found. component=" + deviceOwnerComponent);
        return null;
    }

    public final ComponentName getDeviceOwnerComponent(boolean z) {
        if (!this.mHasFeature) {
            return null;
        }
        if (!z) {
            getCallerIdentity(null, null);
            Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        }
        synchronized (getLockObject()) {
            try {
                if (!this.mOwners.hasDeviceOwner()) {
                    return null;
                }
                if (z) {
                    this.mInjector.getClass();
                    if (Injector.userHandleGetCallingUserId() != this.mOwners.getDeviceOwnerUserId()) {
                        return null;
                    }
                }
                return this.mOwners.getDeviceOwnerComponent();
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final ComponentName getDeviceOwnerComponentOnUser(int i) {
        if (!this.mHasFeature) {
            return null;
        }
        this.mInjector.getClass();
        if (Injector.userHandleGetCallingUserId() != i) {
            getCallerIdentity(null, null);
            Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        }
        synchronized (getLockObject()) {
            try {
                if (this.mOwners.getDeviceOwnerUserId() != i && i != -1) {
                    return null;
                }
                return this.mOwners.getDeviceOwnerComponent();
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final CharSequence getDeviceOwnerLockScreenInfo() {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 16);
        injector.getClass();
        return (CharSequence) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33);
    }

    public final String getDeviceOwnerName() {
        if (!this.mHasFeature) {
            return null;
        }
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        synchronized (getLockObject()) {
            try {
                if (!this.mOwners.hasDeviceOwner()) {
                    return null;
                }
                String deviceOwnerPackageName = this.mOwners.getDeviceOwnerPackageName();
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda20 devicePolicyManagerService$$ExternalSyntheticLambda20 = new DevicePolicyManagerService$$ExternalSyntheticLambda20(0, this, deviceOwnerPackageName);
                injector.getClass();
                return (String) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda20);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final ActiveAdmin getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked() {
        ensureLocked();
        ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
        if (deviceOwnerAdminLocked != null) {
            return deviceOwnerAdminLocked;
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 12);
        injector.getClass();
        return (ActiveAdmin) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33);
    }

    public final CharSequence getDeviceOwnerOrganizationName() {
        String str = null;
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || isFinancedDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
            if (deviceOwnerAdminLocked != null) {
                str = deviceOwnerAdminLocked.organizationName;
            }
        }
        return str;
    }

    public final Pair getDeviceOwnerRemoteBugreportUriAndHash() {
        Pair pair;
        String str;
        String str2;
        synchronized (getLockObject()) {
            Owners owners = this.mOwners;
            synchronized (owners.mData) {
                try {
                    OwnersData.OwnerInfo ownerInfo = owners.mData.mDeviceOwner;
                    pair = null;
                    str = ownerInfo != null ? ownerInfo.remoteBugreportUri : null;
                } finally {
                }
            }
            if (str != null) {
                Owners owners2 = this.mOwners;
                synchronized (owners2.mData) {
                    try {
                        OwnersData.OwnerInfo ownerInfo2 = owners2.mData.mDeviceOwner;
                        str2 = ownerInfo2 != null ? ownerInfo2.remoteBugreportHash : null;
                    } finally {
                    }
                }
                pair = new Pair(str, str2);
            }
        }
        return pair;
    }

    public final int getDeviceOwnerType(ComponentName componentName) {
        int deviceOwnerType;
        synchronized (getLockObject()) {
            Preconditions.checkState(this.mOwners.hasDeviceOwner(), "there is no device owner");
            Preconditions.checkState(this.mOwners.getDeviceOwnerComponent().equals(componentName), "admin is not the device owner");
            deviceOwnerType = this.mOwners.getDeviceOwnerType(componentName.getPackageName());
        }
        return deviceOwnerType;
    }

    public final int getDeviceOwnerUserId() {
        int deviceOwnerUserId;
        if (!this.mHasFeature) {
            return -10000;
        }
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        synchronized (getLockObject()) {
            deviceOwnerUserId = this.mOwners.hasDeviceOwner() ? this.mOwners.getDeviceOwnerUserId() : -10000;
        }
        return deviceOwnerUserId;
    }

    public final DevicePolicyState getDevicePolicyState() {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        Injector injector = this.mInjector;
        DevicePolicyEngine devicePolicyEngine = this.mDevicePolicyEngine;
        Objects.requireNonNull(devicePolicyEngine);
        DevicePolicyManagerService$$ExternalSyntheticLambda4 devicePolicyManagerService$$ExternalSyntheticLambda4 = new DevicePolicyManagerService$$ExternalSyntheticLambda4(0, devicePolicyEngine);
        injector.getClass();
        return (DevicePolicyState) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda4);
    }

    public final List getDisallowedSystemApps(ComponentName componentName, int i, String str) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        return new ArrayList(this.mOverlayPackagesProvider.getNonRequiredApps(componentName, i, str));
    }

    public final boolean getDoNotAskCredentialsOnBoot() {
        boolean z;
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.QUERY_DO_NOT_ASK_CREDENTIALS_ON_BOOT"));
        synchronized (getLockObject()) {
            z = getUserData(0).mDoNotAskCredentialsOnBoot;
        }
        return z;
    }

    public final ParcelableResource getDrawable(String str, String str2, String str3) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda47 devicePolicyManagerService$$ExternalSyntheticLambda47 = new DevicePolicyManagerService$$ExternalSyntheticLambda47(this, str, str2, str3, 0);
        injector.getClass();
        return (ParcelableResource) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda47);
    }

    public final int getEncryptionStatus() {
        this.mInjector.getClass();
        return StorageManager.isFileEncrypted() ? 5 : 0;
    }

    public final CharSequence getEndUserSessionMessage(ComponentName componentName) {
        String str;
        if (!this.mHasFeature) {
            return null;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        synchronized (getLockObject()) {
            str = getDeviceOwnerAdminLocked().endUserSessionMessage;
        }
        return str;
    }

    public final Bundle getEnforcingAdminAndUserDetails(int i, String str) {
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)));
        return getEnforcingAdminAndUserDetailsInternal(i, str);
    }

    public final Bundle getEnforcingAdminAndUserDetailsInternal(int i, String str) {
        if (str == null || "policy_suspend_packages".equals(str)) {
            ComponentName profileOwnerComponent = this.mOwners.getProfileOwnerComponent(i);
            if (profileOwnerComponent != null) {
                Bundle bundle = new Bundle();
                bundle.putInt("android.intent.extra.USER_ID", i);
                bundle.putParcelable("android.app.extra.DEVICE_ADMIN", profileOwnerComponent);
                return bundle;
            }
            Pair deviceOwnerUserIdAndComponent = this.mOwners.getDeviceOwnerUserIdAndComponent();
            if (deviceOwnerUserIdAndComponent != null && ((Integer) deviceOwnerUserIdAndComponent.first).intValue() == i) {
                Bundle m = SystemUpdateManagerService$$ExternalSyntheticOutline0.m(i, "android.intent.extra.USER_ID");
                m.putParcelable("android.app.extra.DEVICE_ADMIN", (Parcelable) deviceOwnerUserIdAndComponent.second);
                return m;
            }
        } else if ("policy_disable_screen_capture".equals(str)) {
            Boolean bool = (Boolean) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.SCREEN_CAPTURE_DISABLED, i);
            if (bool != null && bool.booleanValue()) {
                return SystemUpdateManagerService$$ExternalSyntheticOutline0.m(i, "android.intent.extra.USER_ID");
            }
        } else {
            if (!"policy_disable_camera".equals(str)) {
                this.mInjector.getClass();
                long clearCallingIdentity = Binder.clearCallingIdentity();
                try {
                    if (((HashSet) getEnforcingAdminsForRestrictionInternal(i, str)).size() == 0) {
                        return null;
                    }
                    ActiveAdmin mostProbableDPCAdminForLocalPolicy = getMostProbableDPCAdminForLocalPolicy(i);
                    if (mostProbableDPCAdminForLocalPolicy == null) {
                        return null;
                    }
                    Bundle bundle2 = new Bundle();
                    bundle2.putInt("android.intent.extra.USER_ID", mostProbableDPCAdminForLocalPolicy.getUserHandle().getIdentifier());
                    bundle2.putParcelable("android.app.extra.DEVICE_ADMIN", mostProbableDPCAdminForLocalPolicy.info.getComponent());
                    return bundle2;
                } finally {
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                }
            }
            Boolean bool2 = (Boolean) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.getPolicyDefinitionForUserRestriction("no_camera"), i);
            if (bool2 != null && bool2.booleanValue()) {
                return SystemUpdateManagerService$$ExternalSyntheticOutline0.m(i, "android.intent.extra.USER_ID");
            }
        }
        return null;
    }

    public final EnforcingAdmin getEnforcingAdminForCaller(ComponentName componentName, String str) {
        ActiveAdmin deviceOrProfileOwnerAdminLocked;
        ActiveAdmin activeAdmin;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        if (isDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity) || isCallerDelegate(callerIdentity)) {
            synchronized (getLockObject()) {
                try {
                    if (componentName != null) {
                        deviceOrProfileOwnerAdminLocked = getActiveAdminUncheckedLocked(userId, componentName);
                    } else {
                        deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(userId);
                        componentName = deviceOrProfileOwnerAdminLocked.info.getComponent();
                    }
                } finally {
                }
            }
            return EnforcingAdmin.createEnterpriseEnforcingAdmin(componentName, userId, deviceOrProfileOwnerAdminLocked);
        }
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    activeAdmin = getActiveAdminUncheckedLocked(UserHandle.getUserId(callerIdentity.mUid), componentName);
                } else {
                    Injector injector = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 7);
                    injector.getClass();
                    activeAdmin = (ActiveAdmin) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7);
                }
            } finally {
            }
        }
        ActiveAdmin activeAdmin2 = activeAdmin;
        if (activeAdmin2 != null) {
            ComponentName component = activeAdmin2.info.getComponent();
            Objects.requireNonNull(component);
            return new EnforcingAdmin(component.getPackageName(), component, Set.of("device_admin"), userId, activeAdmin2);
        }
        DevicePolicyData userData = getUserData(userId);
        if (userData.mPermissionBasedAdmin == null) {
            userData.mPermissionBasedAdmin = new ActiveAdmin(userId);
        }
        ActiveAdmin activeAdmin3 = userData.mPermissionBasedAdmin;
        String str2 = callerIdentity.mPackageName;
        Objects.requireNonNull(str2);
        return new EnforcingAdmin(str2, userId, activeAdmin3);
    }

    public final List getEnforcingAdminsForRestriction(int i, String str) {
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)));
        return new ArrayList(getEnforcingAdminsForRestrictionInternal(i, str));
    }

    public final Set getEnforcingAdminsForRestrictionInternal(int i, String str) {
        Objects.requireNonNull(str);
        HashSet hashSet = new HashSet();
        if ("policy_suspend_packages".equals(str)) {
            ComponentName profileOwnerComponent = this.mOwners.getProfileOwnerComponent(i);
            if (profileOwnerComponent != null) {
                hashSet.add(EnforcingAdmin.createEnterpriseEnforcingAdmin(i, profileOwnerComponent).getParcelableAdmin());
                return hashSet;
            }
            Pair deviceOwnerUserIdAndComponent = this.mOwners.getDeviceOwnerUserIdAndComponent();
            if (deviceOwnerUserIdAndComponent != null && ((Integer) deviceOwnerUserIdAndComponent.first).intValue() == i) {
                hashSet.add(EnforcingAdmin.createEnterpriseEnforcingAdmin(((Integer) deviceOwnerUserIdAndComponent.first).intValue(), (ComponentName) deviceOwnerUserIdAndComponent.second).getParcelableAdmin());
                return hashSet;
            }
        } else {
            this.mInjector.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                PolicyDefinition policyDefinitionForUserRestriction = "policy_disable_camera".equals(str) ? PolicyDefinition.getPolicyDefinitionForUserRestriction("no_camera") : "policy_disable_screen_capture".equals(str) ? PolicyDefinition.SCREEN_CAPTURE_DISABLED : PolicyDefinition.getPolicyDefinitionForUserRestriction(str);
                Boolean bool = (Boolean) this.mDevicePolicyEngine.getResolvedPolicy(policyDefinitionForUserRestriction, i);
                if (bool != null && bool.booleanValue()) {
                    LinkedHashMap globalPoliciesSetByAdmins = this.mDevicePolicyEngine.getGlobalPoliciesSetByAdmins(policyDefinitionForUserRestriction);
                    for (EnforcingAdmin enforcingAdmin : globalPoliciesSetByAdmins.keySet()) {
                        if (globalPoliciesSetByAdmins.get(enforcingAdmin) != null && Boolean.TRUE.equals(((PolicyValue) globalPoliciesSetByAdmins.get(enforcingAdmin)).getValue())) {
                            hashSet.add(enforcingAdmin.getParcelableAdmin());
                        }
                    }
                    LinkedHashMap localPoliciesSetByAdmins = this.mDevicePolicyEngine.getLocalPoliciesSetByAdmins(policyDefinitionForUserRestriction, i);
                    for (EnforcingAdmin enforcingAdmin2 : localPoliciesSetByAdmins.keySet()) {
                        if (localPoliciesSetByAdmins.get(enforcingAdmin2) != null && Boolean.TRUE.equals(((PolicyValue) localPoliciesSetByAdmins.get(enforcingAdmin2)).getValue())) {
                            hashSet.add(enforcingAdmin2.getParcelableAdmin());
                        }
                    }
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    return hashSet;
                }
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
            } catch (Throwable th) {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                throw th;
            }
        }
        return hashSet;
    }

    public final String getEnrollmentSpecificId(String str) {
        String str2;
        if (!this.mHasFeature) {
            return "";
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        if (Flags.permissionMigrationForZeroTrustImplEnabled()) {
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES", callerIdentity.mPackageName);
        } else {
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity) || isCallerDelegate(callerIdentity, "delegation-cert-install"));
        }
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(UserHandle.getUserId(callerIdentity.mUid));
                str2 = deviceOrProfileOwnerAdminLocked != null ? deviceOrProfileOwnerAdminLocked.mEnrollmentSpecificId : null;
                if (str2 == null) {
                    str2 = "";
                }
            } finally {
            }
        }
        return str2;
    }

    public final FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(ComponentName componentName) {
        ActiveAdmin profileOwnerOrDeviceOwnerLocked;
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        int frpManagementAgentUid = getFrpManagementAgentUid();
        if (frpManagementAgentUid == -1) {
            throw new UnsupportedOperationException("The persistent data block service is not supported on this device");
        }
        synchronized (getLockObject()) {
            boolean z = true;
            try {
                if (componentName == null) {
                    if (frpManagementAgentUid != callerIdentity.mUid && !hasCallingPermission("android.permission.MASTER_CLEAR") && !hasCallingPermission("android.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET")) {
                        z = false;
                    }
                    Preconditions.checkCallAuthorization(z, "Must be called by the FRP management agent on device");
                    ensureLocked();
                    profileOwnerOrDeviceOwnerLocked = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();
                    if (isPermissionCheckFlagEnabled() && profileOwnerOrDeviceOwnerLocked == null) {
                        profileOwnerOrDeviceOwnerLocked = getUserData(0).mPermissionBasedAdmin;
                    }
                } else {
                    Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
                    profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        if (profileOwnerOrDeviceOwnerLocked != null) {
            return profileOwnerOrDeviceOwnerLocked.mFactoryResetProtectionPolicy;
        }
        return null;
    }

    public final String getFinancedDeviceKioskRoleHolder(String str) {
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        enforcePermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS", callerIdentity.mPackageName, UserHandle.getUserId(callerIdentity.mUid));
        return getRoleHolderPackageNameOnUser(-1, "android.app.role.FINANCED_DEVICE_KIOSK");
    }

    public final boolean getForceEphemeralUsers(ComponentName componentName) {
        throw new UnsupportedOperationException("This method was used by split system user only.");
    }

    public final int getFrpManagementAgentUid() {
        this.mInjector.getClass();
        PersistentDataBlockManagerInternal persistentDataBlockManagerInternal = (PersistentDataBlockManagerInternal) LocalServices.getService(PersistentDataBlockManagerInternal.class);
        if (persistentDataBlockManagerInternal != null) {
            return PersistentDataBlockService.this.mAllowedUid;
        }
        return -1;
    }

    public final String getGlobalPrivateDnsHost(ComponentName componentName) {
        if (!this.mHasFeature) {
            return null;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        return Settings.Global.getString(this.mInjector.mContext.getContentResolver(), "private_dns_specifier");
    }

    public final int getGlobalPrivateDnsMode(ComponentName componentName) {
        if (!this.mHasFeature) {
            return 0;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        int privateDnsMode = ConnectivitySettingsManager.getPrivateDnsMode(this.mContext);
        int i = 1;
        if (privateDnsMode != 1) {
            i = 2;
            if (privateDnsMode != 2) {
                i = 3;
                if (privateDnsMode != 3) {
                    return 0;
                }
            }
        }
        return i;
    }

    public final ComponentName getGlobalProxyAdmin(int i) {
        if (!this.mHasFeature) {
            return null;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i) && hasCallingOrSelfPermission("android.permission.QUERY_ADMIN_POLICY"));
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userData = getUserData(0);
                int size = userData.mAdminList.size();
                for (int i2 = 0; i2 < size; i2++) {
                    ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminList.get(i2);
                    if (activeAdmin.specifiesGlobalProxy) {
                        return activeAdmin.info.getComponent();
                    }
                }
                return null;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int getHeadlessDeviceOwnerMode(String str) {
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        enforcePermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS", callerIdentity.mPackageName, UserHandle.getUserId(callerIdentity.mUid));
        return ((Integer) Binder.withCleanCallingIdentity(new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 7))).intValue();
    }

    public final int getHeadlessDeviceOwnerModeForDeviceAdmin(int i, ComponentName componentName) {
        synchronized (getLockObject()) {
            try {
                if (componentName == null) {
                    return 0;
                }
                DeviceAdminInfo findAdmin = findAdmin(i, componentName, false);
                if (findAdmin == null) {
                    return 0;
                }
                return findAdmin.getHeadlessDeviceOwnerMode();
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int getHeadlessDeviceOwnerModeForDeviceOwner() {
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
                if (deviceOwnerAdminLocked == null) {
                    return 0;
                }
                return deviceOwnerAdminLocked.info.getHeadlessDeviceOwnerMode();
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final List getKeepUninstalledPackages(ComponentName componentName, String str) {
        List list;
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && isDefaultDeviceOwner(callerIdentity)) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-keep-uninstalled-packages")));
        synchronized (getLockObject()) {
            ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
            list = deviceOwnerAdminLocked != null ? deviceOwnerAdminLocked.keepUninstalledPackages : null;
        }
        return list;
    }

    public final ParcelableGranteeMap getKeyPairGrants(String str, String str2) {
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        Preconditions.checkCallAuthorization(canChooseCertificates(callerIdentity));
        ArrayMap arrayMap = new ArrayMap();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda1 devicePolicyManagerService$$ExternalSyntheticLambda1 = new DevicePolicyManagerService$$ExternalSyntheticLambda1(this, callerIdentity, str2, arrayMap);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda1);
        return new ParcelableGranteeMap(arrayMap);
    }

    /* JADX WARN: Removed duplicated region for block: B:14:0x0038  */
    /* JADX WARN: Removed duplicated region for block: B:17:0x0040 A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:29:0x0078 A[Catch: all -> 0x0067, TryCatch #0 {all -> 0x0067, blocks: (B:50:0x005a, B:52:0x0060, B:27:0x0071, B:29:0x0078, B:33:0x0091, B:34:0x0093, B:36:0x008b, B:38:0x0095, B:26:0x0069), top: B:49:0x005a, outer: #1 }] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final int getKeyguardDisabledFeatures(android.content.ComponentName r9, int r10, boolean r11) {
        /*
            r8 = this;
            boolean r0 = r8.mHasFeature
            r1 = 0
            if (r0 != 0) goto L6
            return r1
        L6:
            java.lang.String r0 = "Invalid userId"
            com.android.internal.util.Preconditions.checkArgumentNonnegative(r10, r0)
            r0 = 0
            com.android.server.devicepolicy.CallerIdentity r0 = r8.getCallerIdentity(r0, r0)
            boolean r2 = r8.hasFullCrossUsersPermission(r0, r10)
            com.android.internal.util.Preconditions.checkCallAuthorization(r2)
            if (r9 == 0) goto L32
            java.lang.String r2 = r9.getPackageName()
            int r3 = r0.mUid
            boolean r2 = r8.isCallingFromPackage(r3, r2)
            if (r2 != 0) goto L32
            int r0 = r0.mUid
            r2 = 1000(0x3e8, float:1.401E-42)
            boolean r0 = android.os.UserHandle.isSameApp(r0, r2)
            if (r0 == 0) goto L30
            goto L32
        L30:
            r0 = r1
            goto L33
        L32:
            r0 = 1
        L33:
            com.android.internal.util.Preconditions.checkCallAuthorization(r0)
            if (r11 == 0) goto L3b
            r8.getProfileParentId(r10)
        L3b:
            java.lang.Object r0 = r8.getLockObject()
            monitor-enter(r0)
            if (r9 == 0) goto L4f
            com.android.server.devicepolicy.ActiveAdmin r8 = r8.getActiveAdminUncheckedLocked(r10, r9, r11)     // Catch: java.lang.Throwable -> L4b
            if (r8 == 0) goto L4d
            int r1 = r8.disabledKeyguardFeatures     // Catch: java.lang.Throwable -> L4b
            goto L4d
        L4b:
            r8 = move-exception
            goto Lb0
        L4d:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L4b
            return r1
        L4f:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r9 = r8.mInjector     // Catch: java.lang.Throwable -> L4b
            r9.getClass()     // Catch: java.lang.Throwable -> L4b
            long r2 = android.os.Binder.clearCallingIdentity()     // Catch: java.lang.Throwable -> L4b
            if (r11 != 0) goto L69
            boolean r9 = r8.isManagedProfile(r10)     // Catch: java.lang.Throwable -> L67
            if (r9 == 0) goto L69
            com.android.server.devicepolicy.DevicePolicyData r9 = r8.getUserDataUnchecked(r10)     // Catch: java.lang.Throwable -> L67
            java.util.ArrayList r9 = r9.mAdminList     // Catch: java.lang.Throwable -> L67
            goto L71
        L67:
            r9 = move-exception
            goto La7
        L69:
            int r9 = r8.getProfileParentUserIfRequested(r10, r11)     // Catch: java.lang.Throwable -> L67
            java.util.List r9 = r8.getActiveAdminsForLockscreenPoliciesLocked(r9)     // Catch: java.lang.Throwable -> L67
        L71:
            int r4 = r9.size()     // Catch: java.lang.Throwable -> L67
            r5 = r1
        L76:
            if (r1 >= r4) goto L9d
            java.lang.Object r6 = r9.get(r1)     // Catch: java.lang.Throwable -> L67
            com.android.server.devicepolicy.ActiveAdmin r6 = (com.android.server.devicepolicy.ActiveAdmin) r6     // Catch: java.lang.Throwable -> L67
            android.os.UserHandle r7 = r6.getUserHandle()     // Catch: java.lang.Throwable -> L67
            int r7 = r7.getIdentifier()     // Catch: java.lang.Throwable -> L67
            if (r11 != 0) goto L8b
            if (r7 != r10) goto L8b
            goto L91
        L8b:
            boolean r7 = r8.isManagedProfile(r7)     // Catch: java.lang.Throwable -> L67
            if (r7 != 0) goto L95
        L91:
            int r6 = r6.disabledKeyguardFeatures     // Catch: java.lang.Throwable -> L67
        L93:
            r5 = r5 | r6
            goto L9a
        L95:
            int r6 = r6.disabledKeyguardFeatures     // Catch: java.lang.Throwable -> L67
            r6 = r6 & 951(0x3b7, float:1.333E-42)
            goto L93
        L9a:
            int r1 = r1 + 1
            goto L76
        L9d:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r8 = r8.mInjector     // Catch: java.lang.Throwable -> L4b
            r8.getClass()     // Catch: java.lang.Throwable -> L4b
            android.os.Binder.restoreCallingIdentity(r2)     // Catch: java.lang.Throwable -> L4b
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L4b
            return r5
        La7:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r8 = r8.mInjector     // Catch: java.lang.Throwable -> L4b
            r8.getClass()     // Catch: java.lang.Throwable -> L4b
            android.os.Binder.restoreCallingIdentity(r2)     // Catch: java.lang.Throwable -> L4b
            throw r9     // Catch: java.lang.Throwable -> L4b
        Lb0:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L4b
            throw r8
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.getKeyguardDisabledFeatures(android.content.ComponentName, int, boolean):int");
    }

    public final long getLastBugReportRequestTime() {
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(null, null)) || hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        return getUserData(0).mLastBugReportRequestTime;
    }

    public final long getLastNetworkLogRetrievalTime() {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || (isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid))) || hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        int networkLoggingAffectedUser = getNetworkLoggingAffectedUser();
        if (networkLoggingAffectedUser >= 0) {
            return getUserData(networkLoggingAffectedUser).mLastNetworkLogsRetrievalTime;
        }
        return -1L;
    }

    public final long getLastSecurityLogRetrievalTime() {
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(null, null)) || hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        return getUserData(0).mLastSecurityLogRetrievalTime;
    }

    public final Object getLockObject() {
        long time = this.mStatLogger.getTime();
        LockGuard.guard(8);
        this.mStatLogger.logDurationStat(0, time);
        return this.mLockDoNoUseDirectly;
    }

    public final int getLockTaskFeatures(ComponentName componentName, String str) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        synchronized (getLockObject()) {
            enforceCanQueryLockTaskLocked(componentName, callerIdentity.mPackageName);
        }
        LockTaskPolicy lockTaskPolicy = (LockTaskPolicy) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.LOCK_TASK, userId);
        if (lockTaskPolicy == null) {
            return 16;
        }
        return lockTaskPolicy.getFlags();
    }

    public final String[] getLockTaskPackages(ComponentName componentName, String str) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        synchronized (getLockObject()) {
            enforceCanQueryLockTaskLocked(componentName, callerIdentity.mPackageName);
        }
        LockTaskPolicy lockTaskPolicy = (LockTaskPolicy) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.LOCK_TASK, userId);
        return lockTaskPolicy == null ? new String[0] : (String[]) lockTaskPolicy.getPackages().toArray(new String[lockTaskPolicy.getPackages().size()]);
    }

    public final int getLogoutUserId() {
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS"));
        return getLogoutUserIdUnchecked();
    }

    public final int getLogoutUserIdUnchecked() {
        int i;
        synchronized (getLockObject()) {
            i = this.mLogoutUserId;
        }
        return i;
    }

    public final CharSequence getLongSupportMessage(ComponentName componentName) {
        CharSequence charSequence;
        if (!this.mHasFeature) {
            return null;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        synchronized (getLockObject()) {
            charSequence = getActiveAdminForUidLocked(callerIdentity.mUid, componentName).longSupportMessage;
        }
        return charSequence;
    }

    public final CharSequence getLongSupportMessageForUser(ComponentName componentName, int i) {
        if (!this.mHasFeature) {
            return null;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can query support message for user");
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                if (activeAdminUncheckedLocked == null) {
                    return null;
                }
                return activeAdminUncheckedLocked.longSupportMessage;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int getMainUserId() {
        int mainUserId = this.mUserManagerInternal.getMainUserId();
        if (mainUserId != -10000) {
            return mainUserId;
        }
        Slogf.d("DevicePolicyManager", "getMainUserId(): no main user, returning USER_SYSTEM");
        return 0;
    }

    public final PackagePolicy getManagedProfileCallerIdAccessPolicy() {
        PackagePolicy packagePolicy;
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                packagePolicy = profileOwnerLocked != null ? profileOwnerLocked.mManagedProfileCallerIdAccess : null;
            } catch (Throwable th) {
                throw th;
            }
        }
        return packagePolicy;
    }

    public final PackagePolicy getManagedProfileContactsAccessPolicy() {
        PackagePolicy packagePolicy;
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                packagePolicy = profileOwnerLocked != null ? profileOwnerLocked.mManagedProfileContactsAccess : null;
            } catch (Throwable th) {
                throw th;
            }
        }
        return packagePolicy;
    }

    public final long getManagedProfileMaximumTimeOff(ComponentName componentName) {
        long j;
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        synchronized (getLockObject()) {
            j = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).mProfileMaximumTimeOffMillis;
        }
        return j;
    }

    public final ManagedSubscriptionsPolicy getManagedSubscriptionsPolicy() {
        ManagedSubscriptionsPolicy managedSubscriptionsPolicy;
        synchronized (getLockObject()) {
            try {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 12);
                injector.getClass();
                ActiveAdmin activeAdmin = (ActiveAdmin) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33);
                return (activeAdmin == null || (managedSubscriptionsPolicy = activeAdmin.mManagedSubscriptionsPolicy) == null) ? new ManagedSubscriptionsPolicy(0) : managedSubscriptionsPolicy;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int getManagedUserId(int i) {
        for (UserInfo userInfo : this.mUserManager.getProfiles(i)) {
            if (userInfo.id != i && userInfo.isManagedProfile()) {
                return userInfo.id;
            }
        }
        return -10000;
    }

    public final int getMaxPolicyStorageLimit(String str) {
        if (!Flags.devicePolicySizeTrackingInternalBugFixEnabled()) {
            return -1;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        enforcePermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS", callerIdentity.mPackageName, UserHandle.getUserId(callerIdentity.mUid));
        return this.mDevicePolicyEngine.mPolicySizeLimit;
    }

    /* JADX WARN: Removed duplicated region for block: B:14:0x0041 A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final int getMaximumFailedPasswordsForWipe(android.content.ComponentName r4, int r5, boolean r6) {
        /*
            r3 = this;
            boolean r0 = r3.mHasFeature
            r1 = 0
            if (r0 == 0) goto L56
            com.android.internal.widget.LockPatternUtils r0 = r3.mLockPatternUtils
            boolean r0 = r0.hasSecureLockScreen()
            if (r0 != 0) goto Le
            goto L56
        Le:
            java.lang.String r0 = "Invalid userId"
            com.android.internal.util.Preconditions.checkArgumentNonnegative(r5, r0)
            r0 = 0
            com.android.server.devicepolicy.CallerIdentity r0 = r3.getCallerIdentity(r0, r0)
            boolean r2 = r3.hasFullCrossUsersPermission(r0, r5)
            com.android.internal.util.Preconditions.checkCallAuthorization(r2)
            if (r4 == 0) goto L38
            java.lang.String r2 = r4.getPackageName()
            int r0 = r0.mUid
            boolean r0 = r3.isCallingFromPackage(r0, r2)
            if (r0 != 0) goto L38
            java.lang.String r0 = "android.permission.QUERY_ADMIN_POLICY"
            boolean r0 = r3.hasCallingOrSelfPermission(r0)
            if (r0 == 0) goto L36
            goto L38
        L36:
            r0 = r1
            goto L39
        L38:
            r0 = 1
        L39:
            com.android.internal.util.Preconditions.checkCallAuthorization(r0)
            java.lang.Object r0 = r3.getLockObject()
            monitor-enter(r0)
            if (r4 == 0) goto L4a
            com.android.server.devicepolicy.ActiveAdmin r3 = r3.getActiveAdminUncheckedLocked(r5, r4, r6)     // Catch: java.lang.Throwable -> L48
            goto L4e
        L48:
            r3 = move-exception
            goto L54
        L4a:
            com.android.server.devicepolicy.ActiveAdmin r3 = r3.getAdminWithMinimumFailedPasswordsForWipeLocked(r5, r6)     // Catch: java.lang.Throwable -> L48
        L4e:
            if (r3 == 0) goto L52
            int r1 = r3.maximumFailedPasswordsForWipe     // Catch: java.lang.Throwable -> L48
        L52:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L48
            return r1
        L54:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L48
            throw r3
        L56:
            return r1
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.getMaximumFailedPasswordsForWipe(android.content.ComponentName, int, boolean):int");
    }

    /* JADX WARN: Removed duplicated region for block: B:14:0x003a A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final long getMaximumTimeToLock(android.content.ComponentName r5, int r6, boolean r7) {
        /*
            r4 = this;
            boolean r0 = r4.mHasFeature
            r1 = 0
            if (r0 != 0) goto L7
            return r1
        L7:
            java.lang.String r0 = "Invalid userId"
            com.android.internal.util.Preconditions.checkArgumentNonnegative(r6, r0)
            r0 = 0
            com.android.server.devicepolicy.CallerIdentity r0 = r4.getCallerIdentity(r0, r0)
            boolean r3 = r4.hasFullCrossUsersPermission(r0, r6)
            com.android.internal.util.Preconditions.checkCallAuthorization(r3)
            if (r5 == 0) goto L31
            java.lang.String r3 = r5.getPackageName()
            int r0 = r0.mUid
            boolean r0 = r4.isCallingFromPackage(r0, r3)
            if (r0 != 0) goto L31
            java.lang.String r0 = "android.permission.QUERY_ADMIN_POLICY"
            boolean r0 = r4.hasCallingOrSelfPermission(r0)
            if (r0 == 0) goto L2f
            goto L31
        L2f:
            r0 = 0
            goto L32
        L31:
            r0 = 1
        L32:
            com.android.internal.util.Preconditions.checkCallAuthorization(r0)
            java.lang.Object r0 = r4.getLockObject()
            monitor-enter(r0)
            if (r5 == 0) goto L49
            com.android.server.devicepolicy.ActiveAdmin r4 = r4.getActiveAdminUncheckedLocked(r6, r5, r7)     // Catch: java.lang.Throwable -> L45
            if (r4 == 0) goto L47
            long r1 = r4.maximumTimeToUnlock     // Catch: java.lang.Throwable -> L45
            goto L47
        L45:
            r4 = move-exception
            goto L62
        L47:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L45
            return r1
        L49:
            int r5 = r4.getProfileParentUserIfRequested(r6, r7)     // Catch: java.lang.Throwable -> L45
            java.util.List r4 = r4.getActiveAdminsForLockscreenPoliciesLocked(r5)     // Catch: java.lang.Throwable -> L45
            long r4 = getMaximumTimeToLockPolicyFromAdmins(r4)     // Catch: java.lang.Throwable -> L45
            r6 = 9223372036854775807(0x7fffffffffffffff, double:NaN)
            int r6 = (r4 > r6 ? 1 : (r4 == r6 ? 0 : -1))
            if (r6 != 0) goto L5f
            goto L60
        L5f:
            r1 = r4
        L60:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L45
            return r1
        L62:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L45
            throw r4
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.getMaximumTimeToLock(android.content.ComponentName, int, boolean):long");
    }

    public final List getMeteredDataDisabledPackages(ComponentName componentName) {
        List list;
        Objects.requireNonNull(componentName);
        if (!this.mHasFeature) {
            return new ArrayList();
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity), "Admin %s does not own the profile", new Object[]{callerIdentity.mComponentName});
        synchronized (getLockObject()) {
            try {
                list = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).meteredDisabledPackages;
                if (list == null) {
                    list = new ArrayList();
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        return list;
    }

    public final Set getMeteredDisabledPackages(int i) {
        ArraySet arraySet;
        List list;
        synchronized (getLockObject()) {
            try {
                arraySet = new ArraySet();
                ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(i);
                if (deviceOrProfileOwnerAdminLocked != null && (list = deviceOrProfileOwnerAdminLocked.meteredDisabledPackages) != null) {
                    arraySet.addAll(list);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        return arraySet;
    }

    public final int getMinimumRequiredWifiSecurityLevel() {
        int strictestMinimumRequiredWifiSecurityLevelLocked;
        synchronized (getLockObject()) {
            this.mInjector.getClass();
            strictestMinimumRequiredWifiSecurityLevelLocked = getStrictestMinimumRequiredWifiSecurityLevelLocked();
        }
        return strictestMinimumRequiredWifiSecurityLevelLocked;
    }

    public final ActiveAdmin getMostProbableDPCAdminForLocalPolicy(int i) {
        synchronized (getLockObject()) {
            try {
                ensureLocked();
                ActiveAdmin activeAdmin = (ActiveAdmin) getUserData(i).mAdminMap.get(this.mOwners.getDeviceOwnerComponent());
                if (activeAdmin != null) {
                    return activeAdmin;
                }
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(i);
                if (profileOwnerLocked != null) {
                    return profileOwnerLocked;
                }
                int[] profileIds = this.mUserManager.getProfileIds(i, false);
                for (int i2 : profileIds) {
                    if (i2 != i && isProfileOwnerOfOrganizationOwnedDevice(i2)) {
                        return getProfileOwnerAdminLocked(i2);
                    }
                }
                for (int i3 : profileIds) {
                    if (i3 != i && isManagedProfile(i3)) {
                        return getProfileOwnerAdminLocked(i3);
                    }
                }
                ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
                if (deviceOwnerAdminLocked != null) {
                    return deviceOwnerAdminLocked;
                }
                Iterator it = this.mUserManager.getUsers().iterator();
                while (it.hasNext()) {
                    ActiveAdmin profileOwnerLocked2 = getProfileOwnerLocked(((UserInfo) it.next()).id);
                    if (profileOwnerLocked2 != null) {
                        return profileOwnerLocked2;
                    }
                }
                return null;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int getMtePolicy(String str) {
        int i;
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        if (isPermissionCheckFlagEnabled()) {
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_MTE", callerIdentity.mPackageName, -1);
        } else {
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) || isSystemUid(callerIdentity));
        }
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();
                i = deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked != null ? deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked.mtePolicy : 0;
            } catch (Throwable th) {
                throw th;
            }
        }
        return i;
    }

    public final int getNearbyAppStreamingPolicy(int i) {
        int i2;
        if (!this.mHasFeature) {
            return 0;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity) || hasCallingOrSelfPermission("android.permission.READ_NEARBY_STREAMING_POLICY"));
        Preconditions.checkCallAuthorization(hasCrossUsersPermission(callerIdentity, i));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(i);
                i2 = deviceOrProfileOwnerAdminLocked != null ? deviceOrProfileOwnerAdminLocked.mNearbyAppStreamingPolicy : 0;
            } catch (Throwable th) {
                throw th;
            }
        }
        return i2;
    }

    public final int getNearbyNotificationStreamingPolicy(int i) {
        int i2;
        if (!this.mHasFeature) {
            return 0;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity) || hasCallingOrSelfPermission("android.permission.READ_NEARBY_STREAMING_POLICY"));
        Preconditions.checkCallAuthorization(hasCrossUsersPermission(callerIdentity, i));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(i);
                i2 = deviceOrProfileOwnerAdminLocked != null ? deviceOrProfileOwnerAdminLocked.mNearbyNotificationStreamingPolicy : 0;
            } catch (Throwable th) {
                throw th;
            }
        }
        return i2;
    }

    public final int getNetworkLoggingAffectedUser() {
        synchronized (getLockObject()) {
            try {
                if (this.mOwners.hasDeviceOwner()) {
                    return this.mOwners.getDeviceOwnerUserId();
                }
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 10);
                injector.getClass();
                return ((Integer) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33)).intValue();
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int getOrganizationColor(ComponentName componentName) {
        int i;
        if (!this.mHasFeature) {
            return ActiveAdmin.DEF_ORGANIZATION_COLOR;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallingUser(isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)));
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
        synchronized (getLockObject()) {
            i = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).organizationColor;
        }
        return i;
    }

    public final int getOrganizationColorForUser(int i) {
        int i2;
        if (!this.mHasFeature) {
            return ActiveAdmin.DEF_ORGANIZATION_COLOR;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(isManagedProfile(i), "You can not get organization color outside a managed profile, userId = %d", new Object[]{Integer.valueOf(i)});
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                i2 = profileOwnerAdminLocked != null ? profileOwnerAdminLocked.organizationColor : ActiveAdmin.DEF_ORGANIZATION_COLOR;
            } catch (Throwable th) {
                throw th;
            }
        }
        return i2;
    }

    public final CharSequence getOrganizationName(ComponentName componentName, String str) {
        ActiveAdmin profileOwnerOrDeviceOwnerLocked;
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        if (isPermissionCheckFlagEnabled()) {
            String str2 = callerIdentity.mPackageName;
            enforceCanQuery(UserHandle.getUserId(callerIdentity.mUid), "android.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY", str2);
            profileOwnerOrDeviceOwnerLocked = getEnforcingAdminForCaller(componentName, str2).mActiveAdmin;
        } else {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallingUser(isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)));
            Preconditions.checkCallAuthorization(isDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
            }
        }
        return profileOwnerOrDeviceOwnerLocked.organizationName;
    }

    public final CharSequence getOrganizationNameForUser(int i) {
        String str;
        if (!this.mHasFeature) {
            return null;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        Preconditions.checkCallAuthorization(isManagedProfile(i), "You can not get organization name outside a managed profile, userId = %d", new Object[]{Integer.valueOf(i)});
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                str = profileOwnerAdminLocked != null ? profileOwnerAdminLocked.organizationName : null;
            } catch (Throwable th) {
                throw th;
            }
        }
        return str;
    }

    public final int getOrganizationOwnedProfileUserId() {
        for (UserInfo userInfo : this.mUserManagerInternal.getUserInfos()) {
            if (userInfo.isManagedProfile() && isProfileOwnerOfOrganizationOwnedDevice(userInfo.id)) {
                return userInfo.id;
            }
        }
        return -10000;
    }

    public final List getOverrideApns(ComponentName componentName) {
        if (!this.mHasFeature || (!this.mHasTelephonyFeature && !this.mHasTelephonyDataFeature)) {
            return Collections.emptyList();
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isManagedProfileOwner(callerIdentity));
        List<ApnSetting> overrideApnsUnchecked = getOverrideApnsUnchecked();
        if (!isProfileOwner(callerIdentity)) {
            return overrideApnsUnchecked;
        }
        ArrayList arrayList = new ArrayList();
        for (ApnSetting apnSetting : overrideApnsUnchecked) {
            if (apnSetting.getApnTypeBitmask() == 16384) {
                arrayList.add(apnSetting);
            }
        }
        return arrayList;
    }

    public final List getOverrideApnsUnchecked() {
        TelephonyManager telephonyManager = (TelephonyManager) this.mContext.getSystemService(TelephonyManager.class);
        if (telephonyManager == null) {
            Slogf.w("DevicePolicyManager", "TelephonyManager is null when trying to get override apns");
            return Collections.emptyList();
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda34 devicePolicyManagerService$$ExternalSyntheticLambda34 = new DevicePolicyManagerService$$ExternalSyntheticLambda34(3, this, telephonyManager);
        injector.getClass();
        return (List) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda34);
    }

    public final ComponentName getOwnerComponent(int i) {
        synchronized (getLockObject()) {
            try {
                if (this.mOwners.getDeviceOwnerUserId() == i) {
                    return this.mOwners.getDeviceOwnerComponent();
                }
                if (!this.mOwners.hasProfileOwner(i)) {
                    return null;
                }
                return this.mOwners.getProfileOwnerComponent(i);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final StringParceledListSlice getOwnerInstalledCaCerts(UserHandle userHandle) {
        StringParceledListSlice stringParceledListSlice;
        int identifier = userHandle.getIdentifier();
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization((isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity) || hasCallingOrSelfPermission("android.permission.QUERY_ADMIN_POLICY")) && hasFullCrossUsersPermission(callerIdentity, identifier));
        synchronized (getLockObject()) {
            stringParceledListSlice = new StringParceledListSlice(new ArrayList(getUserData(identifier).mOwnerInstalledCaCerts));
        }
        return stringParceledListSlice;
    }

    public final int getPasswordComplexity(boolean z) {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        DevicePolicyEventLogger.createEvent(72).setStrings(z ? "calledFromParent" : "notCalledFromParent", this.mInjector.mContext.getPackageManager().getPackagesForUid(callerIdentity.mUid)).write();
        enforceUserUnlocked(UserHandle.getUserId(callerIdentity.mUid));
        boolean z2 = true;
        int i = 0;
        if (z) {
            if (!isDefaultDeviceOwner(callerIdentity) && !isProfileOwner(callerIdentity) && !UserHandle.isSameApp(callerIdentity.mUid, 1000)) {
                z2 = false;
            }
            Preconditions.checkCallAuthorization(z2, "Only profile owner, device owner and system may call this method on parent.");
        } else if (isPermissionCheckFlagEnabled()) {
            if (!hasCallingOrSelfPermission("android.permission.REQUEST_PASSWORD_COMPLEXITY") && !hasCallingOrSelfPermission("android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS") && !isDefaultDeviceOwner(callerIdentity) && !isProfileOwner(callerIdentity)) {
                z2 = false;
            }
            Preconditions.checkCallAuthorization(z2, "Must have android.permission.REQUEST_PASSWORD_COMPLEXITY or android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS permissions, or be a profile owner or device owner.");
        } else {
            if (!hasCallingOrSelfPermission("android.permission.REQUEST_PASSWORD_COMPLEXITY") && !isDefaultDeviceOwner(callerIdentity) && !isProfileOwner(callerIdentity)) {
                z2 = false;
            }
            Preconditions.checkCallAuthorization(z2, "Must have android.permission.REQUEST_PASSWORD_COMPLEXITY permission, or be a profile owner or device owner.");
        }
        synchronized (getLockObject()) {
            PasswordMetrics userPasswordMetrics = this.mLockSettingsInternal.getUserPasswordMetrics(getCredentialOwner(UserHandle.getUserId(callerIdentity.mUid), z));
            if (userPasswordMetrics != null) {
                i = userPasswordMetrics.determineComplexity();
            }
        }
        return i;
    }

    public final long getPasswordExpiration(ComponentName componentName, int i, boolean z) {
        long passwordExpirationLocked;
        if (!this.mHasFeature || !this.mLockPatternUtils.hasSecureLockScreen()) {
            return 0L;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(componentName), i));
        synchronized (getLockObject()) {
            passwordExpirationLocked = getPasswordExpirationLocked(i, componentName, z);
        }
        return passwordExpirationLocked;
    }

    public final long getPasswordExpirationLocked(int i, ComponentName componentName, boolean z) {
        if (componentName != null) {
            ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName, z);
            if (activeAdminUncheckedLocked != null) {
                return activeAdminUncheckedLocked.passwordExpirationDate;
            }
            return 0L;
        }
        ArrayList arrayList = (ArrayList) getActiveAdminsForLockscreenPoliciesLocked(getProfileParentUserIfRequested(i, z));
        int size = arrayList.size();
        long j = 0;
        for (int i2 = 0; i2 < size; i2++) {
            ActiveAdmin activeAdmin = (ActiveAdmin) arrayList.get(i2);
            if (j != 0) {
                long j2 = activeAdmin.passwordExpirationDate;
                if (j2 != 0) {
                    if (j <= j2) {
                    }
                }
            }
            j = activeAdmin.passwordExpirationDate;
        }
        return j;
    }

    public final long getPasswordExpirationTimeout(ComponentName componentName, int i, boolean z) {
        if (!this.mHasFeature || !this.mLockPatternUtils.hasSecureLockScreen()) {
            return 0L;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(componentName), i));
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName, z);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.passwordExpirationTimeout : 0L;
                }
                ArrayList arrayList = (ArrayList) getActiveAdminsForLockscreenPoliciesLocked(getProfileParentUserIfRequested(i, z));
                int size = arrayList.size();
                long j = 0;
                for (int i2 = 0; i2 < size; i2++) {
                    ActiveAdmin activeAdmin = (ActiveAdmin) arrayList.get(i2);
                    if (j != 0) {
                        long j2 = activeAdmin.passwordExpirationTimeout;
                        if (j2 != 0) {
                            if (j <= j2) {
                            }
                        }
                    }
                    j = activeAdmin.passwordExpirationTimeout;
                }
                return j;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int getPasswordHistoryLength(ComponentName componentName, int i, boolean z) {
        if (this.mLockPatternUtils.hasSecureLockScreen()) {
            return getStrictestPasswordRequirement(componentName, i, z, new DevicePolicyManagerService$$ExternalSyntheticLambda15(7), 0);
        }
        return 0;
    }

    public final int getPasswordMinimumLength(ComponentName componentName, int i, boolean z) {
        return getStrictestPasswordRequirement(componentName, i, z, new DevicePolicyManagerService$$ExternalSyntheticLambda15(11), 131072);
    }

    public final int getPasswordMinimumLetters(ComponentName componentName, int i, boolean z) {
        return getStrictestPasswordRequirement(componentName, i, z, new DevicePolicyManagerService$$ExternalSyntheticLambda15(3), 393216);
    }

    public final int getPasswordMinimumLowerCase(ComponentName componentName, int i, boolean z) {
        return getStrictestPasswordRequirement(componentName, i, z, new DevicePolicyManagerService$$ExternalSyntheticLambda15(1), 393216);
    }

    public final PasswordMetrics getPasswordMinimumMetrics(int i, boolean z) {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(callerIdentity, i) && (UserHandle.isSameApp(callerIdentity.mUid, 1000) || hasCallingOrSelfPermission("android.permission.SET_INITIAL_LOCK") || hasCallingOrSelfPermission("android.permission.SET_AND_VERIFY_LOCKSCREEN_CREDENTIALS") || hasCallingOrSelfPermission("android.permission.ACCESS_KEYGUARD_SECURE_STORAGE")));
        return getPasswordMinimumMetricsUnchecked(i, z);
    }

    public final PasswordMetrics getPasswordMinimumMetricsUnchecked(int i, boolean z) {
        if (!this.mHasFeature) {
            new PasswordMetrics(-1);
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        if (z) {
            Preconditions.checkArgument(!isManagedProfile(i));
        }
        ArrayList arrayList = new ArrayList();
        synchronized (getLockObject()) {
            try {
                Iterator it = (z ? getActiveAdminsForUserAndItsManagedProfilesLocked(i, new DevicePolicyManagerService$$ExternalSyntheticLambda9(0)) : getActiveAdminsForLockscreenPoliciesLocked(i)).iterator();
                while (it.hasNext()) {
                    arrayList.add(((ActiveAdmin) it.next()).mPasswordPolicy.getMinMetrics());
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        return PasswordMetrics.merge(arrayList);
    }

    public final int getPasswordMinimumNonLetter(ComponentName componentName, int i, boolean z) {
        return getStrictestPasswordRequirement(componentName, i, z, new DevicePolicyManagerService$$ExternalSyntheticLambda15(5), 393216);
    }

    public final int getPasswordMinimumNumeric(ComponentName componentName, int i, boolean z) {
        return getStrictestPasswordRequirement(componentName, i, z, new DevicePolicyManagerService$$ExternalSyntheticLambda15(8), 393216);
    }

    public final int getPasswordMinimumSymbols(ComponentName componentName, int i, boolean z) {
        return getStrictestPasswordRequirement(componentName, i, z, new DevicePolicyManagerService$$ExternalSyntheticLambda15(12), 393216);
    }

    public final int getPasswordMinimumUpperCase(ComponentName componentName, int i, boolean z) {
        return getStrictestPasswordRequirement(componentName, i, z, new DevicePolicyManagerService$$ExternalSyntheticLambda15(6), 393216);
    }

    /* JADX WARN: Removed duplicated region for block: B:14:0x0039 A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final int getPasswordQuality(android.content.ComponentName r4, int r5, boolean r6) {
        /*
            r3 = this;
            boolean r0 = r3.mHasFeature
            r1 = 0
            if (r0 != 0) goto L6
            return r1
        L6:
            java.lang.String r0 = "Invalid userId"
            com.android.internal.util.Preconditions.checkArgumentNonnegative(r5, r0)
            r0 = 0
            com.android.server.devicepolicy.CallerIdentity r0 = r3.getCallerIdentity(r0, r0)
            boolean r2 = r3.hasFullCrossUsersPermission(r0, r5)
            com.android.internal.util.Preconditions.checkCallAuthorization(r2)
            if (r4 == 0) goto L30
            java.lang.String r2 = r4.getPackageName()
            int r0 = r0.mUid
            boolean r0 = r3.isCallingFromPackage(r0, r2)
            if (r0 != 0) goto L30
            java.lang.String r0 = "android.permission.QUERY_ADMIN_POLICY"
            boolean r0 = r3.hasCallingOrSelfPermission(r0)
            if (r0 == 0) goto L2e
            goto L30
        L2e:
            r0 = r1
            goto L31
        L30:
            r0 = 1
        L31:
            com.android.internal.util.Preconditions.checkCallAuthorization(r0)
            java.lang.Object r0 = r3.getLockObject()
            monitor-enter(r0)
            if (r4 == 0) goto L4a
            com.android.server.devicepolicy.ActiveAdmin r3 = r3.getActiveAdminUncheckedLocked(r5, r4, r6)     // Catch: java.lang.Throwable -> L46
            if (r3 == 0) goto L48
            android.app.admin.PasswordPolicy r3 = r3.mPasswordPolicy     // Catch: java.lang.Throwable -> L46
            int r1 = r3.quality     // Catch: java.lang.Throwable -> L46
            goto L48
        L46:
            r3 = move-exception
            goto L6d
        L48:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L46
            return r1
        L4a:
            int r4 = r3.getProfileParentUserIfRequested(r5, r6)     // Catch: java.lang.Throwable -> L46
            java.util.List r3 = r3.getActiveAdminsForLockscreenPoliciesLocked(r4)     // Catch: java.lang.Throwable -> L46
            java.util.ArrayList r3 = (java.util.ArrayList) r3     // Catch: java.lang.Throwable -> L46
            int r4 = r3.size()     // Catch: java.lang.Throwable -> L46
            r5 = r1
        L59:
            if (r1 >= r4) goto L6b
            java.lang.Object r6 = r3.get(r1)     // Catch: java.lang.Throwable -> L46
            com.android.server.devicepolicy.ActiveAdmin r6 = (com.android.server.devicepolicy.ActiveAdmin) r6     // Catch: java.lang.Throwable -> L46
            android.app.admin.PasswordPolicy r6 = r6.mPasswordPolicy     // Catch: java.lang.Throwable -> L46
            int r6 = r6.quality     // Catch: java.lang.Throwable -> L46
            if (r5 >= r6) goto L68
            r5 = r6
        L68:
            int r1 = r1 + 1
            goto L59
        L6b:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L46
            return r5
        L6d:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L46
            throw r3
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.getPasswordQuality(android.content.ComponentName, int, boolean):int");
    }

    public final SystemUpdateInfo getPendingSystemUpdate(ComponentName componentName, String str) {
        SystemUpdateInfo systemUpdateInfo;
        if (Flags.permissionMigrationForZeroTrustImplEnabled()) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            enforcePermissions(callerIdentity.mPackageName, UserHandle.getUserId(callerIdentity.mUid), new String[]{"android.permission.NOTIFY_PENDING_SYSTEM_UPDATE", "android.permission.MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES"});
        } else {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity2 = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity2) || isProfileOwner(callerIdentity2));
        }
        Owners owners = this.mOwners;
        synchronized (owners.mData) {
            systemUpdateInfo = owners.mData.mSystemUpdateInfo;
        }
        return systemUpdateInfo;
    }

    public final int getPermissionGrantState(ComponentName componentName, String str, String str2, String str3) {
        int intValue;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        Preconditions.checkCallAuthorization(isSystemUid(callerIdentity) || (callerIdentity.hasAdminComponent() && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity) || isFinancedDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-permission-grant")));
        synchronized (getLockObject()) {
            try {
                if (isFinancedDeviceOwner(callerIdentity)) {
                    enforcePermissionGrantStateOnFinancedDevice(str2, str3);
                }
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda47 devicePolicyManagerService$$ExternalSyntheticLambda47 = new DevicePolicyManagerService$$ExternalSyntheticLambda47(this, str2, str3, callerIdentity, 2);
                injector.getClass();
                intValue = ((Integer) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda47)).intValue();
            } catch (Throwable th) {
                throw th;
            }
        }
        return intValue;
    }

    public final int getPermissionPolicy(ComponentName componentName) {
        return this.mPolicyCache.getPermissionPolicy(UserHandle.getCallingUserId());
    }

    public final List getPermittedAccessibilityServices(ComponentName componentName) {
        List list;
        if (!this.mHasFeature) {
            return null;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        synchronized (getLockObject()) {
            list = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).permittedAccessiblityServices;
        }
        return list;
    }

    public final List getPermittedAccessibilityServicesForUser(int i) {
        ArrayList arrayList = null;
        if (!this.mHasFeature) {
            return null;
        }
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.QUERY_ADMIN_POLICY"));
        synchronized (getLockObject()) {
            try {
                for (int i2 : this.mUserManager.getProfileIdsWithDisabled(i)) {
                    DevicePolicyData userDataUnchecked = getUserDataUnchecked(i2);
                    int size = userDataUnchecked.mAdminList.size();
                    for (int i3 = 0; i3 < size; i3++) {
                        List list = ((ActiveAdmin) userDataUnchecked.mAdminList.get(i3)).permittedAccessiblityServices;
                        if (list != null) {
                            if (arrayList == null) {
                                arrayList = new ArrayList(list);
                            } else {
                                arrayList.retainAll(list);
                            }
                        }
                    }
                }
            } finally {
            }
        }
        if (arrayList != null) {
            this.mInjector.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                UserInfo userInfo = getUserInfo(i);
                if (userInfo.isManagedProfile()) {
                    i = userInfo.profileGroupId;
                }
                List list2 = (List) withAccessibilityManager(i, new DevicePolicyManagerService$$ExternalSyntheticLambda15(0));
                if (list2 != null) {
                    Iterator it = list2.iterator();
                    while (it.hasNext()) {
                        ServiceInfo serviceInfo = ((AccessibilityServiceInfo) it.next()).getResolveInfo().serviceInfo;
                        if ((serviceInfo.applicationInfo.flags & 1) != 0) {
                            arrayList.add(serviceInfo.packageName);
                        }
                    }
                }
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
            } finally {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
            }
        }
        return arrayList;
    }

    public final List getPermittedCrossProfileNotificationListeners(ComponentName componentName) {
        List list;
        if (!this.mHasFeature) {
            return null;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        synchronized (getLockObject()) {
            list = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).permittedNotificationListeners;
        }
        return list;
    }

    public final List getPermittedInputMethods(ComponentName componentName, String str, boolean z) {
        ArrayList arrayList = null;
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        synchronized (getLockObject()) {
            try {
                Set set = (Set) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.PERMITTED_INPUT_METHODS, z ? getProfileParentId(UserHandle.getUserId(callerIdentity.mUid)) : UserHandle.getUserId(callerIdentity.mUid));
                if (set != null) {
                    arrayList = new ArrayList(set);
                }
            } finally {
            }
        }
        return arrayList;
    }

    public final List getPermittedInputMethodsAsUser(int i) {
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.QUERY_ADMIN_POLICY"));
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            return getPermittedInputMethodsUnchecked(i);
        } finally {
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final List getPermittedInputMethodsUnchecked(int i) {
        List inputMethodListAsUser;
        Set set = (Set) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.PERMITTED_INPUT_METHODS, i);
        ArrayList arrayList = set == null ? null : new ArrayList(set);
        if (arrayList != null && (inputMethodListAsUser = InputMethodManagerInternal.get().getInputMethodListAsUser(i)) != null) {
            Iterator it = inputMethodListAsUser.iterator();
            while (it.hasNext()) {
                ServiceInfo serviceInfo = ((InputMethodInfo) it.next()).getServiceInfo();
                if ((serviceInfo.applicationInfo.flags & 1) != 0) {
                    arrayList.add(serviceInfo.packageName);
                }
            }
        }
        return arrayList;
    }

    /* JADX WARN: Multi-variable type inference failed */
    public final int getPersonalAppsSuspendedReasons(ComponentName componentName) {
        int i;
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                long j = profileOwnerLocked.mProfileOffDeadline;
                boolean z = profileOwnerLocked.mSuspendPersonalApps;
                i = z;
                if (j != 0) {
                    this.mInjector.getClass();
                    i = z;
                    if (System.currentTimeMillis() > j) {
                        i = (z ? 1 : 0) | 2;
                    }
                }
                this.mInjector.getClass();
                Slogf.d("DevicePolicyManager", "getPersonalAppsSuspendedReasons user: %d; result: %d", Integer.valueOf(Injector.userHandleGetCallingUserId()), Integer.valueOf(i));
            } catch (Throwable th) {
                throw th;
            }
        }
        return i;
    }

    public final List getPolicyManagedProfiles(UserHandle userHandle) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        int identifier = userHandle.getIdentifier();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, identifier, 1);
        injector.getClass();
        return (List) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6);
    }

    public final int getPolicySizeForAdmin(String str, android.app.admin.EnforcingAdmin enforcingAdmin) {
        if (!Flags.devicePolicySizeTrackingInternalBugFixEnabled()) {
            return -1;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        enforcePermission("android.permission.MANAGE_DEVICE_POLICY_STORAGE_LIMIT", callerIdentity.mPackageName, UserHandle.getUserId(callerIdentity.mUid));
        DevicePolicyEngine devicePolicyEngine = this.mDevicePolicyEngine;
        Objects.requireNonNull(enforcingAdmin);
        RoleAuthority authority = enforcingAdmin.getAuthority();
        new HashSet();
        EnforcingAdmin enforcingAdmin2 = DpcAuthority.DPC_AUTHORITY.equals(authority) ? new EnforcingAdmin(enforcingAdmin.getPackageName(), enforcingAdmin.getComponentName(), Set.of("enterprise"), enforcingAdmin.getUserHandle().getIdentifier(), null) : DeviceAdminAuthority.DEVICE_ADMIN_AUTHORITY.equals(authority) ? new EnforcingAdmin(enforcingAdmin.getPackageName(), enforcingAdmin.getComponentName(), Set.of("device_admin"), enforcingAdmin.getUserHandle().getIdentifier(), null) : authority instanceof RoleAuthority ? new EnforcingAdmin(enforcingAdmin.getPackageName(), enforcingAdmin.getComponentName(), Set.of("device_admin"), enforcingAdmin.getUserHandle().getIdentifier()) : new EnforcingAdmin(enforcingAdmin.getPackageName(), enforcingAdmin.getComponentName(), Set.of(), enforcingAdmin.getUserHandle().getIdentifier(), null);
        SparseArray sparseArray = devicePolicyEngine.mAdminPolicySize;
        int i = enforcingAdmin2.mUserId;
        if (sparseArray.contains(i) && ((HashMap) devicePolicyEngine.mAdminPolicySize.get(i)).containsKey(enforcingAdmin2)) {
            return ((Integer) ((HashMap) devicePolicyEngine.mAdminPolicySize.get(i)).get(enforcingAdmin2)).intValue();
        }
        return 0;
    }

    public final List getPreferentialNetworkServiceConfigs() {
        List list;
        if (!this.mHasFeature) {
            return List.of(PreferentialNetworkServiceConfig.DEFAULT);
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization((isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid))) || isDefaultDeviceOwner(callerIdentity), "Caller is not managed profile owner or device owner; only managed profile owner or device owner may retrieve the preferential network service configurations");
        synchronized (getLockObject()) {
            list = getDeviceOrProfileOwnerAdminLocked(UserHandle.getUserId(callerIdentity.mUid)).mPreferentialNetworkServiceConfigs;
        }
        return list;
    }

    public ActiveAdmin getProfileOwnerAdminLocked(int i) {
        ComponentName profileOwnerComponent = this.mOwners.getProfileOwnerComponent(i);
        if (profileOwnerComponent == null) {
            return null;
        }
        DevicePolicyData userData = getUserData(i);
        int size = userData.mAdminList.size();
        for (int i2 = 0; i2 < size; i2++) {
            ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminList.get(i2);
            if (profileOwnerComponent.equals(activeAdmin.info.getComponent())) {
                return activeAdmin;
            }
        }
        return null;
    }

    public final List getProfileOwnerAdminsForProfileGroup(int i) {
        ArrayList arrayList;
        ActiveAdmin activeAdminUncheckedLocked;
        synchronized (getLockObject()) {
            try {
                arrayList = new ArrayList();
                int[] profileIdsWithDisabled = this.mUserManager.getProfileIdsWithDisabled(i);
                for (int i2 = 0; i2 < profileIdsWithDisabled.length; i2++) {
                    ComponentName profileOwnerAsUser = getProfileOwnerAsUser(profileIdsWithDisabled[i2]);
                    if (profileOwnerAsUser != null && (activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(profileIdsWithDisabled[i2], profileOwnerAsUser)) != null) {
                        arrayList.add(activeAdminUncheckedLocked);
                    }
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        return arrayList;
    }

    public final ComponentName getProfileOwnerAsUser(int i) {
        ComponentName profileOwnerComponent;
        if (!this.mHasFeature) {
            return null;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCrossUsersPermission(callerIdentity, i) || hasFullCrossUsersPermission(callerIdentity, i));
        synchronized (getLockObject()) {
            profileOwnerComponent = this.mOwners.getProfileOwnerComponent(i);
        }
        return profileOwnerComponent;
    }

    public final ActiveAdmin getProfileOwnerLocked(int i) {
        ensureLocked();
        return (ActiveAdmin) getUserData(i).mAdminMap.get(this.mOwners.getProfileOwnerComponent(i));
    }

    public final String getProfileOwnerName(int i) {
        if (!this.mHasFeature) {
            return null;
        }
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        ComponentName profileOwnerAsUser = getProfileOwnerAsUser(i);
        if (profileOwnerAsUser == null) {
            return null;
        }
        String packageName = profileOwnerAsUser.getPackageName();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda20 devicePolicyManagerService$$ExternalSyntheticLambda20 = new DevicePolicyManagerService$$ExternalSyntheticLambda20(i, this, packageName);
        injector.getClass();
        return (String) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda20);
    }

    public final ActiveAdmin getProfileOwnerOrDeviceOwnerLocked(int i) {
        ensureLocked();
        if (this.mOwners.getProfileOwnerComponent(i) != null) {
            return getProfileOwnerLocked(i);
        }
        ensureLocked();
        return (ActiveAdmin) getUserData(i).mAdminMap.get(this.mOwners.getDeviceOwnerComponent());
    }

    public final ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(UserHandle userHandle) {
        if (!this.mHasFeature) {
            return null;
        }
        synchronized (getLockObject()) {
            try {
                ComponentName deviceOwnerComponent = this.mOwners.getDeviceOwnerComponent();
                ComponentName profileOwnerComponent = this.mOwners.getProfileOwnerComponent(userHandle.getIdentifier());
                if (this.mConstants.USE_TEST_ADMIN_AS_SUPERVISION_COMPONENT) {
                    if (isAdminTestOnlyLocked(userHandle.getIdentifier(), deviceOwnerComponent)) {
                        return deviceOwnerComponent;
                    }
                    if (isAdminTestOnlyLocked(userHandle.getIdentifier(), profileOwnerComponent)) {
                        return profileOwnerComponent;
                    }
                }
                if (isSupervisionComponentLocked(profileOwnerComponent)) {
                    return profileOwnerComponent;
                }
                if (isSupervisionComponentLocked(deviceOwnerComponent)) {
                    return deviceOwnerComponent;
                }
                return null;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int getProfileParentId(int i) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, i, 2);
        injector.getClass();
        return ((Integer) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6)).intValue();
    }

    public final int getProfileParentUserIfRequested(int i, boolean z) {
        return z ? getProfileParentId(i) : i;
    }

    public final int getProfileWithMinimumFailedPasswordsForWipe(int i, boolean z) {
        int userIdToWipeForFailedPasswords;
        if (!this.mHasFeature || !this.mLockPatternUtils.hasSecureLockScreen()) {
            return -10000;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin adminWithMinimumFailedPasswordsForWipeLocked = getAdminWithMinimumFailedPasswordsForWipeLocked(i, z);
                userIdToWipeForFailedPasswords = adminWithMinimumFailedPasswordsForWipeLocked != null ? getUserIdToWipeForFailedPasswords(adminWithMinimumFailedPasswordsForWipeLocked) : -10000;
            } catch (Throwable th) {
                throw th;
            }
        }
        return userIdToWipeForFailedPasswords;
    }

    public final void getRemoveWarning(ComponentName componentName, RemoteCallback remoteCallback, int i) {
        if (this.mHasFeature) {
            Preconditions.checkArgumentNonnegative(i, "Invalid userId");
            Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
            Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.BIND_DEVICE_ADMIN"));
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    if (activeAdminUncheckedLocked == null) {
                        remoteCallback.sendResult((Bundle) null);
                        return;
                    }
                    Intent intent = new Intent("android.app.action.DEVICE_ADMIN_DISABLE_REQUESTED");
                    intent.setFlags(268435456);
                    intent.setComponent(activeAdminUncheckedLocked.info.getComponent());
                    this.mContext.sendOrderedBroadcastAsUser(intent, new UserHandle(i), null, new AnonymousClass1(1, remoteCallback), null, -1, null, null);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final int getRequiredPasswordComplexity(String str, boolean z) {
        int i;
        if (!this.mHasFeature) {
            return 0;
        }
        if (Flags.unmanagedModeMigration()) {
            CallerIdentity callerIdentity = getCallerIdentity(null, str);
            int profileParentId = z ? getProfileParentId(UserHandle.getUserId(callerIdentity.mUid)) : UserHandle.getUserId(callerIdentity.mUid);
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", str, profileParentId);
            Integer num = (Integer) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.PASSWORD_COMPLEXITY, profileParentId);
            if (num != null) {
                return num.intValue();
            }
            return 0;
        }
        CallerIdentity callerIdentity2 = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity2) || isProfileOwner(callerIdentity2));
        Preconditions.checkArgument(!z || isProfileOwner(callerIdentity2));
        synchronized (getLockObject()) {
            ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(UserHandle.getUserId(callerIdentity2.mUid));
            Objects.requireNonNull(deviceOrProfileOwnerAdminLocked);
            if (z) {
                deviceOrProfileOwnerAdminLocked = deviceOrProfileOwnerAdminLocked.getParentActiveAdmin();
            }
            i = deviceOrProfileOwnerAdminLocked.mPasswordComplexity;
        }
        return i;
    }

    public final long getRequiredStrongAuthTimeout(ComponentName componentName, int i, boolean z) {
        long min;
        long j = 259200000;
        if (!this.mHasFeature) {
            return 259200000L;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(componentName), i));
        if (!this.mLockPatternUtils.hasSecureLockScreen()) {
            return 0L;
        }
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName, z);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.strongAuthUnlockTimeout : 0L;
                }
                List activeAdminsForLockscreenPoliciesLocked = getActiveAdminsForLockscreenPoliciesLocked(getProfileParentUserIfRequested(i, z));
                int i2 = 0;
                while (true) {
                    ArrayList arrayList = (ArrayList) activeAdminsForLockscreenPoliciesLocked;
                    if (i2 >= arrayList.size()) {
                        break;
                    }
                    long j2 = ((ActiveAdmin) arrayList.get(i2)).strongAuthUnlockTimeout;
                    if (j2 != 0) {
                        j = Math.min(j2, j);
                    }
                    i2++;
                }
                this.mInjector.getClass();
                if (Build.IS_DEBUGGABLE) {
                    Injector injector = this.mInjector;
                    long j3 = MINIMUM_STRONG_AUTH_TIMEOUT_MS;
                    injector.getClass();
                    min = Math.min(SystemProperties.getLong("persist.sys.min_str_auth_timeo", j3), j3);
                } else {
                    min = MINIMUM_STRONG_AUTH_TIMEOUT_MS;
                }
                return Math.max(j, min);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final Object getResolvedPolicyForUserAndItsManagedProfiles(PolicyDefinition policyDefinition, int i, Predicate predicate) {
        ArrayList arrayList = new ArrayList();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda173 devicePolicyManagerService$$ExternalSyntheticLambda173 = new DevicePolicyManagerService$$ExternalSyntheticLambda173(this, i, arrayList, predicate);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda173);
        DevicePolicyEngine devicePolicyEngine = this.mDevicePolicyEngine;
        devicePolicyEngine.getClass();
        Objects.requireNonNull(policyDefinition);
        ArrayList arrayList2 = new ArrayList();
        synchronized (devicePolicyEngine.mLock) {
            try {
                Iterator it = arrayList.iterator();
                while (it.hasNext()) {
                    PolicyValue resolvedPolicyValue = devicePolicyEngine.getResolvedPolicyValue(policyDefinition, ((Integer) it.next()).intValue());
                    if (resolvedPolicyValue != null) {
                        arrayList2.add(resolvedPolicyValue);
                    }
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        PolicyValue resolve = policyDefinition.mResolutionMechanism.resolve(arrayList2);
        if (resolve == null) {
            return null;
        }
        return resolve.getValue();
    }

    public final ComponentName getRestrictionsProvider(int i) {
        ComponentName componentName;
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can query the permission provider");
        synchronized (getLockObject()) {
            componentName = getUserData(i).mRestrictionsProvider;
        }
        return componentName;
    }

    public final String getRoleHolderPackageNameOnUser(int i, String str) {
        RoleManager roleManager = (RoleManager) this.mContext.getSystemService(RoleManager.class);
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda177 devicePolicyManagerService$$ExternalSyntheticLambda177 = new DevicePolicyManagerService$$ExternalSyntheticLambda177(this, i, roleManager, str);
        injector.getClass();
        return (String) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda177);
    }

    public final String getRoleHolderPackageNameOnUser(Context context, String str, UserHandle userHandle) {
        RoleManager roleManager = (RoleManager) context.getSystemService(RoleManager.class);
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda153 devicePolicyManagerService$$ExternalSyntheticLambda153 = new DevicePolicyManagerService$$ExternalSyntheticLambda153(roleManager, str, userHandle, 2);
        injector.getClass();
        return (String) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda153);
    }

    public final boolean getSamsungSDcardEncryptionStatus(ComponentName componentName, int i) {
        if (!this.mHasFeature) {
            return false;
        }
        SecurityPolicyHelper securityPolicyHelper = this.mSecurityPolicyHelper;
        securityPolicyHelper.getClass();
        if (i < 0) {
            throw new IllegalArgumentException(VibrationParam$1$$ExternalSyntheticOutline0.m(i, "Invalid userId "));
        }
        int callingUid = Binder.getCallingUid();
        if (i != UserHandle.getUserId(callingUid) && callingUid != 1000 && callingUid != 0) {
            securityPolicyHelper.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "Must be system or have INTERACT_ACROSS_USERS_FULL permission");
        }
        SemSdCardEncryption semSdCardEncryption = new SemSdCardEncryption(securityPolicyHelper.mContext);
        try {
            if (semSdCardEncryption.getCurrentUserID() != 0) {
                return false;
            }
            if (securityPolicyHelper.mDPM == null) {
                securityPolicyHelper.mDPM = IDevicePolicyManager.Stub.asInterface(ServiceManager.getService("device_policy"));
            }
            IDevicePolicyManager iDevicePolicyManager = securityPolicyHelper.mDPM;
            if (iDevicePolicyManager == null) {
                return false;
            }
            if (!iDevicePolicyManager.semGetRequireStorageCardEncryption(componentName, i, false) && !semSdCardEncryption.isSdCardEncryped()) {
                if (semSdCardEncryption.getCurrentStatus() != 3) {
                    return false;
                }
            }
            return true;
        } catch (RemoteException e) {
            Log.w("SecurityPolicyHelper", "Failed talking with Device Policy Manager", e);
            return false;
        }
    }

    public final boolean getScreenCaptureDisabled(ComponentName componentName, int i, boolean z) {
        if (!this.mHasFeature) {
            return false;
        }
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(componentName), i));
        if (z) {
            Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(UserHandle.getUserId(getCallerIdentity(null, null).mUid)));
        }
        Boolean bool = (Boolean) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.SCREEN_CAPTURE_DISABLED, i);
        return bool != null && bool.booleanValue();
    }

    public final List getSecondaryUsers(ComponentName componentName) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 2);
        injector.getClass();
        return (List) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33);
    }

    public final int getSecurityLoggingEnabledUser() {
        synchronized (getLockObject()) {
            try {
                if (this.mOwners.hasDeviceOwner()) {
                    return -1;
                }
                return getOrganizationOwnedProfileUserId();
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final CharSequence getShortSupportMessage(ComponentName componentName, String str) {
        ActiveAdmin activeAdminForUidLocked;
        if (!this.mHasFeature) {
            return null;
        }
        if (isPermissionCheckFlagEnabled()) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            activeAdminForUidLocked = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE", callerIdentity.mPackageName).mActiveAdmin;
        } else {
            CallerIdentity callerIdentity2 = getCallerIdentity(componentName);
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                activeAdminForUidLocked = getActiveAdminForUidLocked(callerIdentity2.mUid, componentName);
            }
        }
        return activeAdminForUidLocked.shortSupportMessage;
    }

    public final CharSequence getShortSupportMessageForUser(ComponentName componentName, int i) {
        if (!this.mHasFeature) {
            return null;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can query support message for user");
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                if (activeAdminUncheckedLocked == null) {
                    return null;
                }
                return activeAdminUncheckedLocked.shortSupportMessage;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final CharSequence getStartUserSessionMessage(ComponentName componentName) {
        String str;
        if (!this.mHasFeature) {
            return null;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        synchronized (getLockObject()) {
            str = getDeviceOwnerAdminLocked().startUserSessionMessage;
        }
        return str;
    }

    public final boolean getStorageEncryption(ComponentName componentName, int i) {
        if (!this.mHasFeature) {
            return false;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(callerIdentity, i));
        synchronized (getLockObject()) {
            try {
                if (callerIdentity.hasAdminComponent()) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.encryptionRequested : false;
                }
                DevicePolicyData userData = getUserData(i);
                int size = userData.mAdminList.size();
                for (int i2 = 0; i2 < size; i2++) {
                    if (((ActiveAdmin) userData.mAdminList.get(i2)).encryptionRequested) {
                        return true;
                    }
                }
                return false;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int getStorageEncryptionStatus(String str, int i) {
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, str), i));
        try {
            boolean z = this.mIPackageManager.getApplicationInfo(str, 0L, i).targetSdkVersion <= 23;
            int encryptionStatus = getEncryptionStatus();
            if (encryptionStatus == 5 && z) {
                return 3;
            }
            return encryptionStatus;
        } catch (RemoteException e) {
            throw new SecurityException(e);
        }
    }

    public final int getStrictestMinimumRequiredWifiSecurityLevelLocked() {
        int i = 0;
        Iterator it = ((ArrayList) getActiveAdminsForUserAndItsManagedProfilesLocked(0, new DevicePolicyManagerService$$ExternalSyntheticLambda9(4))).iterator();
        while (it.hasNext()) {
            int i2 = ((ActiveAdmin) it.next()).mWifiMinimumSecurityLevel;
            if (i2 > i) {
                i = i2;
            }
        }
        return i;
    }

    public final int getStrictestPasswordRequirement(ComponentName componentName, int i, boolean z, Function function, int i2) {
        if (!this.mHasFeature) {
            return 0;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(componentName), i));
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName, z);
                    return activeAdminUncheckedLocked != null ? ((Integer) function.apply(activeAdminUncheckedLocked)).intValue() : 0;
                }
                ArrayList arrayList = (ArrayList) getActiveAdminsForLockscreenPoliciesLocked(getProfileParentUserIfRequested(i, z));
                int size = arrayList.size();
                int i3 = 0;
                for (int i4 = 0; i4 < size; i4++) {
                    ActiveAdmin activeAdmin = (ActiveAdmin) arrayList.get(i4);
                    if (activeAdmin.mPasswordPolicy.quality >= i2 && (activeAdmin.isPermissionBased || activeAdmin.info.usesPolicy(0))) {
                        Integer num = (Integer) function.apply(activeAdmin);
                        if (num.intValue() > i3) {
                            i3 = num.intValue();
                        }
                    }
                }
                return i3;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final ParcelableResource getString(String str) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda34 devicePolicyManagerService$$ExternalSyntheticLambda34 = new DevicePolicyManagerService$$ExternalSyntheticLambda34(4, this, str);
        injector.getClass();
        return (ParcelableResource) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda34);
    }

    public final int[] getSubscriptionIds(String str) {
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        enforceCanQuery(UserHandle.getUserId(callerIdentity.mUid), "android.permission.MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS", callerIdentity.mPackageName);
        SubscriptionManager subscriptionManager = (SubscriptionManager) this.mContext.getSystemService(SubscriptionManager.class);
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda34 devicePolicyManagerService$$ExternalSyntheticLambda34 = new DevicePolicyManagerService$$ExternalSyntheticLambda34(2, subscriptionManager, str);
        injector.getClass();
        return ((IntArray) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda34)).toArray();
    }

    public final SystemUpdatePolicy getSystemUpdatePolicy() {
        synchronized (getLockObject()) {
            try {
                SystemUpdatePolicy systemUpdatePolicy = this.mOwners.getSystemUpdatePolicy();
                if (systemUpdatePolicy == null || systemUpdatePolicy.isValid()) {
                    return systemUpdatePolicy;
                }
                Slogf.w("DevicePolicyManager", "Stored system update policy is invalid, return null instead.");
                return null;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int getTargetSdk(int i, String str) {
        try {
            ApplicationInfo applicationInfo = this.mIPackageManager.getApplicationInfo(str, 0L, i);
            if (applicationInfo == null) {
                return 0;
            }
            return applicationInfo.targetSdkVersion;
        } catch (RemoteException e) {
            Slogf.wtf("DevicePolicyManager", "Error getting application info", e);
            return 0;
        }
    }

    public final PersistableBundle getTransferOwnershipBundle() {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            this.mPathProvider.getClass();
            File file = new File(Environment.getUserSystemDirectory(userId), "transfer-ownership-parameters.xml");
            if (!file.exists()) {
                return null;
            }
            try {
                FileInputStream fileInputStream = new FileInputStream(file);
                try {
                    TypedXmlPullParser resolvePullParser = Xml.resolvePullParser(fileInputStream);
                    resolvePullParser.next();
                    PersistableBundle restoreFromXml = PersistableBundle.restoreFromXml(resolvePullParser);
                    fileInputStream.close();
                    return restoreFromXml;
                } catch (Throwable th) {
                    try {
                        fileInputStream.close();
                    } catch (Throwable th2) {
                        th.addSuppressed(th2);
                    }
                    throw th;
                }
            } catch (IOException | IllegalArgumentException | XmlPullParserException e) {
                Slogf.e("DevicePolicyManager", "Caught exception while trying to load the owner transfer parameters from file " + file, e);
                return null;
            }
        }
    }

    public final List getTrustAgentConfiguration(ComponentName componentName, ComponentName componentName2, int i, boolean z) {
        PersistableBundle persistableBundle;
        ArrayList arrayList = null;
        if (!this.mHasFeature || !this.mLockPatternUtils.hasSecureLockScreen()) {
            return null;
        }
        Objects.requireNonNull(componentName2, "agent null");
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(componentName), i));
        synchronized (getLockObject()) {
            try {
                String flattenToString = componentName2.flattenToString();
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName, z);
                    if (activeAdminUncheckedLocked == null) {
                        return null;
                    }
                    ActiveAdmin.TrustAgentInfo trustAgentInfo = (ActiveAdmin.TrustAgentInfo) activeAdminUncheckedLocked.trustAgentInfos.get(flattenToString);
                    if (trustAgentInfo != null && trustAgentInfo.options != null) {
                        ArrayList arrayList2 = new ArrayList();
                        arrayList2.add(trustAgentInfo.options);
                        return arrayList2;
                    }
                    return null;
                }
                ArrayList arrayList3 = (ArrayList) getActiveAdminsForLockscreenPoliciesLocked(getProfileParentUserIfRequested(i, z));
                int size = arrayList3.size();
                int i2 = 0;
                ArrayList arrayList4 = null;
                while (true) {
                    if (i2 >= size) {
                        arrayList = arrayList4;
                        break;
                    }
                    ActiveAdmin activeAdmin = (ActiveAdmin) arrayList3.get(i2);
                    boolean z2 = (activeAdmin.disabledKeyguardFeatures & 16) != 0;
                    ActiveAdmin.TrustAgentInfo trustAgentInfo2 = (ActiveAdmin.TrustAgentInfo) activeAdmin.trustAgentInfos.get(flattenToString);
                    if (trustAgentInfo2 == null || (persistableBundle = trustAgentInfo2.options) == null || persistableBundle.isEmpty()) {
                        if (z2) {
                        }
                    } else if (z2) {
                        if (arrayList4 == null) {
                            arrayList4 = new ArrayList();
                        }
                        arrayList4.add(trustAgentInfo2.options);
                    } else {
                        Slogf.w("DevicePolicyManager", "Ignoring admin %s because it has trust options but doesn't declare KEYGUARD_DISABLE_TRUST_AGENTS", activeAdmin.info);
                    }
                    i2++;
                }
                return arrayList;
            } finally {
            }
        }
    }

    public final String getUpdatableString(String str, final int i, final Object... objArr) {
        ParcelableResource string = this.mDeviceManagementResourcesProvider.getString(str);
        if (string == null) {
            final int i2 = 0;
            return ParcelableResource.loadDefaultString(new Supplier(this) { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda136
                public final /* synthetic */ DevicePolicyManagerService f$0;

                {
                    this.f$0 = this;
                }

                @Override // java.util.function.Supplier
                public final Object get() {
                    switch (i2) {
                        case 0:
                            DevicePolicyManagerService devicePolicyManagerService = this.f$0;
                            return devicePolicyManagerService.mContext.getString(i, objArr);
                        default:
                            DevicePolicyManagerService devicePolicyManagerService2 = this.f$0;
                            return devicePolicyManagerService2.mContext.getString(i, objArr);
                    }
                }
            });
        }
        final int i3 = 1;
        return string.getString(this.mContext, new Supplier(this) { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda136
            public final /* synthetic */ DevicePolicyManagerService f$0;

            {
                this.f$0 = this;
            }

            @Override // java.util.function.Supplier
            public final Object get() {
                switch (i3) {
                    case 0:
                        DevicePolicyManagerService devicePolicyManagerService = this.f$0;
                        return devicePolicyManagerService.mContext.getString(i, objArr);
                    default:
                        DevicePolicyManagerService devicePolicyManagerService2 = this.f$0;
                        return devicePolicyManagerService2.mContext.getString(i, objArr);
                }
            }
        }, objArr);
    }

    public final List getUserControlDisabledPackages(ComponentName componentName, String str) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        String str2 = callerIdentity.mPackageName;
        int i = callerIdentity.mUid;
        enforceCanQuery(UserHandle.getUserId(i), "android.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL", str2);
        Set set = (Set) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.USER_CONTROLLED_DISABLED_PACKAGES, UserHandle.getUserId(i));
        return set == null ? Collections.emptyList() : set.stream().toList();
    }

    public final DevicePolicyData getUserData(int i) {
        DevicePolicyData devicePolicyData;
        synchronized (getLockObject()) {
            try {
                devicePolicyData = (DevicePolicyData) this.mUserData.get(i);
                if (devicePolicyData == null) {
                    devicePolicyData = new DevicePolicyData(i);
                    this.mUserData.append(i, devicePolicyData);
                    DevicePolicyData.load(devicePolicyData, makeJournaledFile(i, "device_policies.xml"), new DevicePolicyManagerService$$ExternalSyntheticLambda90(i, 0, this), getOwnerComponent(i));
                    devicePolicyData.validatePasswordOwner();
                    updateMaximumTimeToLockLocked(i);
                    boolean z = devicePolicyData.mStatusBarDisabled;
                    if (z) {
                        setStatusBarDisabledInternal(i, z);
                    }
                    if (i == 0) {
                        DeviceStateCacheImpl deviceStateCacheImpl = this.mStateCache;
                        boolean z2 = devicePolicyData.mUserSetupComplete;
                        synchronized (deviceStateCacheImpl.mLock) {
                            deviceStateCacheImpl.mIsDeviceProvisioned = z2;
                        }
                    }
                }
            } finally {
            }
        }
        return devicePolicyData;
    }

    public final DevicePolicyData getUserDataUnchecked(int i) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, i, 10);
        injector.getClass();
        return (DevicePolicyData) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6);
    }

    public final int getUserIdToWipeForFailedPasswords(ActiveAdmin activeAdmin) {
        int identifier = activeAdmin.getUserHandle().getIdentifier();
        return (!activeAdmin.isPermissionBased && isProfileOwner(identifier, activeAdmin.info.getComponent()) && isProfileOwnerOfOrganizationOwnedDevice(identifier)) ? getProfileParentId(identifier) : identifier;
    }

    public final UserInfo getUserInfo(int i) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, i, 7);
        injector.getClass();
        return (UserInfo) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6);
    }

    public final int getUserProvisioningState(int i) {
        if (!this.mHasFeature) {
            return 0;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        if (i != UserHandle.getUserId(callerIdentity.mUid)) {
            Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS"));
        }
        return getUserData(i).mUserProvisioningState;
    }

    public final Bundle getUserRestrictions(ComponentName componentName, String str, boolean z) {
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        int profileParentId = z ? getProfileParentId(UserHandle.getUserId(callerIdentity.mUid)) : UserHandle.getUserId(callerIdentity.mUid);
        EnforcingAdmin enforcingAdminForCaller = getEnforcingAdminForCaller(componentName, str);
        if (isDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity)) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isFinancedDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity) || (z && isProfileOwnerOfOrganizationOwnedDevice(callerIdentity)));
            Bundle userRestrictionsFromPolicyEngine = getUserRestrictionsFromPolicyEngine(enforcingAdminForCaller, profileParentId);
            userRestrictionsFromPolicyEngine.putAll(getUserRestrictionsFromPolicyEngine(enforcingAdminForCaller, -1));
            return userRestrictionsFromPolicyEngine;
        }
        Injector injector = this.mInjector;
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        injector.getClass();
        if (Injector.isChangeEnabled(userId, str, 260560985L)) {
            return getUserRestrictionsFromPolicyEngine(enforcingAdminForCaller, profileParentId);
        }
        throw new IllegalStateException("Calling package is not targeting Android U.");
    }

    public final Bundle getUserRestrictionsFromPolicyEngine(EnforcingAdmin enforcingAdmin, int i) {
        Set userRestrictionPolicyKeysForAdminLocked;
        DevicePolicyEngine devicePolicyEngine = this.mDevicePolicyEngine;
        devicePolicyEngine.getClass();
        synchronized (devicePolicyEngine.mLock) {
            try {
                userRestrictionPolicyKeysForAdminLocked = i == -1 ? DevicePolicyEngine.getUserRestrictionPolicyKeysForAdminLocked(devicePolicyEngine.mGlobalPolicies, enforcingAdmin) : !devicePolicyEngine.mLocalPolicies.contains(i) ? Set.of() : DevicePolicyEngine.getUserRestrictionPolicyKeysForAdminLocked((Map) devicePolicyEngine.mLocalPolicies.get(i), enforcingAdmin);
            } finally {
            }
        }
        Bundle bundle = new Bundle();
        Iterator it = userRestrictionPolicyKeysForAdminLocked.iterator();
        while (it.hasNext()) {
            bundle.putBoolean(((UserRestrictionPolicyKey) it.next()).getRestriction(), true);
        }
        return bundle;
    }

    public final Bundle getUserRestrictionsGlobally(String str) {
        if (this.mHasFeature) {
            return getUserRestrictionsFromPolicyEngine(getEnforcingAdminForCaller(null, getCallerIdentity(null, str).mPackageName), -1);
        }
        return null;
    }

    public final String getWifiMacAddress(ComponentName componentName, String str) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        Bundle bundle = new Bundle();
        bundle.putInt("userId", UserHandle.getUserId(callerIdentity.mUid));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda153 devicePolicyManagerService$$ExternalSyntheticLambda153 = new DevicePolicyManagerService$$ExternalSyntheticLambda153(this, callerIdentity, bundle, 1);
        injector.getClass();
        return (String) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda153);
    }

    public final WifiSsidPolicy getWifiSsidPolicy(String str) {
        WifiSsidPolicy combinedWifiSsidPolicyLocked;
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        if (isPermissionCheckFlagEnabled()) {
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_WIFI", str, UserHandle.getUserId(callerIdentity.mUid));
        } else {
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) || hasCallingOrSelfPermission("android.permission.QUERY_ADMIN_POLICY"), "SSID policy can only be retrieved by a device owner or a profile owner on an organization-owned device or an app with the QUERY_ADMIN_POLICY permission.");
        }
        synchronized (getLockObject()) {
            this.mInjector.getClass();
            combinedWifiSsidPolicyLocked = getCombinedWifiSsidPolicyLocked();
        }
        return combinedWifiSsidPolicyLocked;
    }

    public final void handleStartUser(int i) {
        List of;
        updatePasswordQualityCacheForUserGroup(i == 0 ? -1 : i);
        synchronized (getLockObject()) {
            DevicePolicyData userData = getUserData(i);
            DevicePolicyCacheImpl devicePolicyCacheImpl = this.mPolicyCache;
            int i2 = userData.mPermissionPolicy;
            synchronized (devicePolicyCacheImpl.mLock) {
                devicePolicyCacheImpl.mPermissionPolicy.put(i, i2);
            }
        }
        updateAdminCanGrantSensorsPermissionCache(i);
        this.mPolicyCache.setContentProtectionPolicy(i, (Integer) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.CONTENT_PROTECTION, i));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(i);
                of = deviceOrProfileOwnerAdminLocked != null ? deviceOrProfileOwnerAdminLocked.mPreferentialNetworkServiceConfigs : List.of(PreferentialNetworkServiceConfig.DEFAULT);
            } catch (Throwable th) {
                throw th;
            }
        }
        updateNetworkPreferenceForUser(i, of);
        if (isProfileOwnerOfOrganizationOwnedDevice(i) && getManagedSubscriptionsPolicy().getPolicyType() == 1) {
            updateDialerAndSmsManagedShortcutsOverrideCache();
        }
        startOwnerService(i);
        this.mDevicePolicyEngine.updateDeviceAdminsServicesForUser(i, true);
    }

    public final boolean hasAccountsOnAnyUser() {
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            Iterator it = ((ArrayList) this.mUserManagerInternal.getUsers(true)).iterator();
            while (it.hasNext()) {
                if (((AccountManager) this.mContext.createContextAsUser(UserHandle.of(((UserInfo) it.next()).id), 0).getSystemService(AccountManager.class)).getAccounts().length != 0) {
                    return true;
                }
            }
            return false;
        } finally {
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final boolean hasAdminPolicy(int i, String str) {
        boolean z;
        synchronized (getLockObject()) {
            z = getActiveAdminWithPolicyForUidLocked(i, getCallerIdentity(null, str).mUid, null) != null;
        }
        return z;
    }

    public final boolean hasCallingOrSelfPermission(String str) {
        return this.mContext.checkCallingOrSelfPermission(str) == 0;
    }

    public final boolean hasCallingPermission(String str) {
        return this.mContext.checkCallingPermission(str) == 0;
    }

    public final boolean hasCrossUsersPermission(CallerIdentity callerIdentity, int i) {
        if (i != UserHandle.getUserId(callerIdentity.mUid)) {
            int i2 = callerIdentity.mUid;
            if (!UserHandle.isSameApp(i2, 1000) && !UserHandle.isSameApp(i2, 0) && !hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS")) {
                return false;
            }
        }
        return true;
    }

    public final boolean hasDelegatedPermission(String str, int i, String str2) {
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can " + ConnectivityModuleConnector$$ExternalSyntheticOutline0.m("hasDelegatedPermission:", str2));
        return isCallerDelegate(i, str, str2);
    }

    public boolean hasDeviceIdAccessUnchecked(String str, int i) {
        int userId = UserHandle.getUserId(i);
        if (isPermissionCheckFlagEnabled() && !isUidProfileOwnerLocked(i) && !isUidDeviceOwnerLocked(i)) {
            return hasPermission("android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES", str, userId);
        }
        ComponentName deviceOwnerComponent = getDeviceOwnerComponent(true);
        if (deviceOwnerComponent != null && (deviceOwnerComponent.getPackageName().equals(str) || isCallerDelegate(i, str, "delegation-cert-install"))) {
            return true;
        }
        ComponentName profileOwnerAsUser = getProfileOwnerAsUser(userId);
        if (profileOwnerAsUser == null) {
            return false;
        }
        if (profileOwnerAsUser.getPackageName().equals(str) || isCallerDelegate(i, str, "delegation-cert-install")) {
            return isProfileOwnerOfOrganizationOwnedDevice(userId) || isUserAffiliatedWithDevice(userId);
        }
        return false;
    }

    public final boolean hasDeviceOwner() {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || isFinancedDeviceOwner(callerIdentity) || hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        return this.mOwners.hasDeviceOwner();
    }

    public final boolean hasFullCrossUsersPermission(CallerIdentity callerIdentity, int i) {
        if (i != UserHandle.getUserId(callerIdentity.mUid)) {
            int i2 = callerIdentity.mUid;
            if (!UserHandle.isSameApp(i2, 1000) && !UserHandle.isSameApp(i2, 0) && !hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL")) {
                return false;
            }
        }
        return true;
    }

    public final boolean hasGrantedPolicy(ComponentName componentName, int i, int i2) {
        boolean usesPolicy;
        if (!this.mHasFeature) {
            return false;
        }
        Preconditions.checkArgumentNonnegative(i2, "Invalid userId");
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(callerIdentity, i2));
        Preconditions.checkCallAuthorization(isCallingFromPackage(callerIdentity.mUid, componentName.getPackageName()) || UserHandle.isSameApp(callerIdentity.mUid, 1000));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i2, componentName);
                if (activeAdminUncheckedLocked == null) {
                    throw new SecurityException("No active admin " + componentName);
                }
                usesPolicy = activeAdminUncheckedLocked.info.usesPolicy(i);
            } catch (Throwable th) {
                throw th;
            }
        }
        return usesPolicy;
    }

    public final boolean hasIncompatibleAccountsOnAnyUser() {
        if (this.mHasIncompatibleAccounts == null) {
            return true;
        }
        Iterator it = this.mHasIncompatibleAccounts.values().iterator();
        while (it.hasNext()) {
            if (((Boolean) it.next()).booleanValue()) {
                return true;
            }
        }
        return false;
    }

    public final boolean hasIncompatibleAccountsOrNonAdbNoLock(CallerIdentity callerIdentity, int i, ComponentName componentName) {
        if (!isAdb(callerIdentity)) {
            return true;
        }
        wtfIfInLock();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda64 devicePolicyManagerService$$ExternalSyntheticLambda64 = new DevicePolicyManagerService$$ExternalSyntheticLambda64(i, componentName, this);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda64)).booleanValue();
    }

    public final boolean hasKeyPair(String str, String str2) {
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        boolean isCredentialManagementApp = isCredentialManagementApp(callerIdentity);
        boolean z = true;
        if (!(isPermissionCheckFlagEnabled() ? hasPermission("android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES", callerIdentity.mPackageName, UserHandle.getUserId(callerIdentity.mUid)) : isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity) || isCallerDelegate(callerIdentity, "delegation-cert-install")) && !isCredentialManagementApp) {
            z = false;
        }
        Preconditions.checkCallAuthorization(z);
        if (isCredentialManagementApp) {
            Preconditions.checkCallAuthorization(isAliasInCredentialManagementAppPolicy(callerIdentity, str2), "The alias provided must be contained in the aliases specified in the credential management app's authentication policy");
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda10 devicePolicyManagerService$$ExternalSyntheticLambda10 = new DevicePolicyManagerService$$ExternalSyntheticLambda10(this, callerIdentity, str2, 4);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda10)).booleanValue();
    }

    public final boolean hasLockdownAdminConfiguredNetworks(ComponentName componentName) {
        if (!this.mHasFeature) {
            return false;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        if (isPermissionCheckFlagEnabled()) {
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_WIFI", componentName.getPackageName(), -1);
        } else {
            Preconditions.checkNotNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 1);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33)).booleanValue();
    }

    public final boolean hasManagedProfileCallerIdAccess(int i, String str) {
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                if (profileOwnerAdminLocked == null) {
                    return true;
                }
                PackagePolicy packagePolicy = profileOwnerAdminLocked.mManagedProfileCallerIdAccess;
                if (packagePolicy == null) {
                    return !profileOwnerAdminLocked.disableCallerId;
                }
                return packagePolicy.isPackageAllowed(str, this.mContactSystemRoleHolders);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean hasManagedProfileContactsAccess(int i, String str) {
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                if (profileOwnerAdminLocked == null) {
                    return true;
                }
                PackagePolicy packagePolicy = profileOwnerAdminLocked.mManagedProfileContactsAccess;
                if (packagePolicy == null) {
                    return !profileOwnerAdminLocked.disableContactsSearch;
                }
                return packagePolicy.isPackageAllowed(str, this.mContactSystemRoleHolders);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean hasPermission(String str, String str2) {
        boolean z;
        boolean z2;
        Objects.requireNonNull(str2, "callerPackageName is null");
        if (str == null) {
            return true;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, str2);
        if (this.mContext.checkCallingOrSelfPermission(str) == 0) {
            return true;
        }
        int i = isDefaultDeviceOwner(callerIdentity) ? 0 : isFinancedDeviceOwner(callerIdentity) ? 1 : isProfileOwner(callerIdentity) ? isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) ? 2 : isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)) ? 4 : isProfileOwnerOnUser0(callerIdentity) ? 3 : isUserAffiliatedWithDevice(UserHandle.getUserId(callerIdentity.mUid)) ? 6 : 5 : -1;
        if (i != -1) {
            return ((List) DPC_PERMISSIONS.get(Integer.valueOf(i))).contains(str);
        }
        if (!doesCallerHoldRole(callerIdentity, "android.app.role.DEVICE_POLICY_MANAGEMENT")) {
            HashMap hashMap = DELEGATE_SCOPES;
            if (hashMap.containsKey(str)) {
                return isCallerDelegate(callerIdentity, (String) hashMap.get(str));
            }
            return false;
        }
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        Owners owners = this.mOwners;
        synchronized (owners.mData) {
            try {
                OwnersData ownersData = owners.mData;
                z = ownersData.mDeviceOwner != null && ownersData.mDeviceOwnerUserId == userId && owners.getDeviceOwnerType(owners.getDeviceOwnerPackageName()) == 0;
            } finally {
            }
        }
        if (z) {
            return ((List) DPC_PERMISSIONS.get(0)).contains(str);
        }
        Owners owners2 = this.mOwners;
        synchronized (owners2.mData) {
            try {
                OwnersData ownersData2 = owners2.mData;
                z2 = ownersData2.mDeviceOwner != null && ownersData2.mDeviceOwnerUserId == userId && owners2.getDeviceOwnerType(owners2.getDeviceOwnerPackageName()) == 1;
            } finally {
            }
        }
        if (z2) {
            return ((List) DPC_PERMISSIONS.get(1)).contains(str);
        }
        if (this.mOwners.isProfileOwnerOfOrganizationOwnedDevice(userId)) {
            return ((List) DPC_PERMISSIONS.get(2)).contains(str);
        }
        if (userId == 0 && this.mOwners.hasProfileOwner(0)) {
            return ((List) DPC_PERMISSIONS.get(3)).contains(str);
        }
        if (this.mOwners.hasProfileOwner(userId)) {
            return ((List) DPC_PERMISSIONS.get(4)).contains(str);
        }
        return false;
    }

    public final boolean hasPermission(String str, String str2, int i) {
        CallerIdentity callerIdentity = getCallerIdentity(null, str2);
        boolean hasPermission = hasPermission(str, callerIdentity.mPackageName);
        return hasPermission && ((!hasPermission || UserHandle.getUserId(callerIdentity.mUid) == i) ? true : hasPermission((String) CROSS_USER_PERMISSIONS.get(str), callerIdentity.mPackageName));
    }

    public final boolean hasUserSetupCompleted() {
        this.mInjector.getClass();
        return hasUserSetupCompleted(Injector.userHandleGetCallingUserId());
    }

    public final boolean hasUserSetupCompleted(int i) {
        if (!this.mHasFeature) {
            return true;
        }
        Injector injector = this.mInjector;
        DevicePolicyData userData = getUserData(i);
        injector.getClass();
        return userData.mUserSetupComplete;
    }

    public final boolean installCaCert(final ComponentName componentName, String str, final byte[] bArr) {
        if (!this.mHasFeature) {
            return false;
        }
        final CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        Preconditions.checkCallAuthorization(canManageCaCerts(callerIdentity));
        checkCanExecuteOrThrowUnsafe(24);
        final Bundle bundle = new Bundle();
        bundle.putInt("userId", UserHandle.getUserId(callerIdentity.mUid));
        Injector injector = this.mInjector;
        FunctionalUtils.ThrowingSupplier throwingSupplier = new FunctionalUtils.ThrowingSupplier() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda26
            public final Object getOrThrow() {
                DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                CallerIdentity callerIdentity2 = callerIdentity;
                byte[] bArr2 = bArr;
                ComponentName componentName2 = componentName;
                Bundle bundle2 = bundle;
                CertificateMonitor certificateMonitor = devicePolicyManagerService.mCertificateMonitor;
                UserHandle userHandleForUid = UserHandle.getUserHandleForUid(callerIdentity2.mUid);
                certificateMonitor.getClass();
                String str2 = null;
                try {
                    byte[] convertToPem = Credentials.convertToPem(new Certificate[]{(X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(new ByteArrayInputStream(bArr2))});
                    try {
                        KeyChain.KeyChainConnection bindAsUser = KeyChain.bindAsUser(certificateMonitor.mInjector.mContext, userHandleForUid);
                        try {
                            String installCaCertificate = bindAsUser.getService().installCaCertificate(convertToPem);
                            bindAsUser.close();
                            str2 = installCaCertificate;
                        } catch (Throwable th) {
                            if (bindAsUser != null) {
                                try {
                                    bindAsUser.close();
                                } catch (Throwable th2) {
                                    th.addSuppressed(th2);
                                }
                            }
                            throw th;
                        }
                    } catch (RemoteException e) {
                        Slogf.e("DevicePolicyManager", "installCaCertsToKeyChain(): ", e);
                    } catch (InterruptedException e2) {
                        Slogf.w("DevicePolicyManager", "installCaCertsToKeyChain(): ", e2);
                        Thread.currentThread().interrupt();
                    }
                } catch (IOException | CertificateException e3) {
                    Slogf.e("DevicePolicyManager", "Problem converting cert", e3);
                }
                DevicePolicyEventLogger.createEvent(21).setAdmin(callerIdentity2.mPackageName).setBoolean(componentName2 == null).setKnoxBundleValue(bundle2).write();
                devicePolicyManagerService.mInjector.getClass();
                return str2;
            }
        };
        injector.getClass();
        String str2 = (String) Binder.withCleanCallingIdentity(throwingSupplier);
        if (str2 == null) {
            Slogf.w("DevicePolicyManager", "Problem installing cert");
            return false;
        }
        synchronized (getLockObject()) {
            ((ArraySet) getUserData(UserHandle.getUserId(callerIdentity.mUid)).mOwnerInstalledCaCerts).add(str2);
            saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
        }
        this.mInjector.getClass();
        this.mKnoxAnalyticsHelper.getClass();
        KnoxAnalyticsHelper.setKnoxAnalyticsData("installCaCert", str);
        return true;
    }

    public final void installExistingAdminPackage(int i, String str) {
        try {
            int installExistingPackageAsUser = this.mContext.getPackageManager().installExistingPackageAsUser(str, i);
            if (installExistingPackageAsUser == 1) {
            } else {
                throw new ServiceSpecificException(3, String.format("Failed to install existing package %s for user %d with result code %d", str, Integer.valueOf(i), Integer.valueOf(installExistingPackageAsUser)));
            }
        } catch (PackageManager.NameNotFoundException e) {
            throw new ServiceSpecificException(3, String.format("Failed to install existing package %s for user %d: %s", str, Integer.valueOf(i), e.getMessage()));
        }
    }

    public final boolean installExistingPackage(ComponentName componentName, String str, String str2) {
        boolean z;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-install-existing-package")));
        synchronized (getLockObject()) {
            Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(UserHandle.getUserId(callerIdentity.mUid)), "Admin %s is neither the device owner or affiliated user's profile owner.", new Object[]{componentName});
            this.mInjector.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                z = this.mIPackageManager.installExistingPackageAsUser(str2, UserHandle.getUserId(callerIdentity.mUid), 4194304, 1, (List) null) == 1;
            } catch (RemoteException e) {
                Slogf.wtf("DevicePolicyManager", "Error installing package", e);
                return false;
            } finally {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
            }
        }
        if (z) {
            DevicePolicyEventLogger.createEvent(66).setAdmin(callerIdentity.mPackageName).setBoolean(componentName == null).setStrings(new String[]{str2}).write();
        }
        return z;
    }

    public final boolean installKeyPair(ComponentName componentName, String str, byte[] bArr, byte[] bArr2, byte[] bArr3, String str2, boolean z, boolean z2) {
        Injector injector;
        IKeyChainService iKeyChainService;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        boolean isCallerDelegate = isCallerDelegate(callerIdentity, "delegation-cert-install");
        boolean isCredentialManagementApp = isCredentialManagementApp(callerIdentity);
        boolean isPermissionCheckFlagEnabled = isPermissionCheckFlagEnabled();
        String str3 = callerIdentity.mPackageName;
        int i = callerIdentity.mUid;
        if (isPermissionCheckFlagEnabled) {
            Preconditions.checkCallAuthorization(hasPermission("android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES", str3, UserHandle.getUserId(i)) || isCredentialManagementApp);
        } else {
            Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));
        }
        if (isCredentialManagementApp) {
            Preconditions.checkCallAuthorization(!z2, "The credential management app is not allowed to install a user selectable key pair");
            Preconditions.checkCallAuthorization(isAliasInCredentialManagementAppPolicy(callerIdentity, str2), "The alias provided must be contained in the aliases specified in the credential management app's authentication policy");
        }
        checkCanExecuteOrThrowUnsafe(25);
        Bundle bundle = new Bundle();
        bundle.putInt("userId", UserHandle.getUserId(i));
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                try {
                    KeyChain.KeyChainConnection bindAsUser = KeyChain.bindAsUser(this.mContext, UserHandle.getUserHandleForUid(i));
                    try {
                        IKeyChainService service = bindAsUser.getService();
                        if (!service.installKeyPair(bArr, bArr2, bArr3, str2, -1)) {
                            logInstallKeyPairFailure(callerIdentity, isCredentialManagementApp);
                            bindAsUser.close();
                            return false;
                        }
                        if (z) {
                            iKeyChainService = service;
                            iKeyChainService.setGrant(i, str2, true);
                        } else {
                            iKeyChainService = service;
                        }
                        iKeyChainService.setUserSelectable(str2, z2);
                        DevicePolicyEventLogger.createEvent(20).setAdmin(str3).setBoolean(isCallerDelegate).setStrings(new String[]{isCredentialManagementApp ? "credentialManagementApp" : "notCredentialManagementApp"}).setKnoxBundleValue(bundle).write();
                        this.mInjector.getClass();
                        this.mKnoxAnalyticsHelper.getClass();
                        KnoxAnalyticsHelper.setKnoxAnalyticsData("installKeyPair", str);
                        bindAsUser.close();
                        return true;
                    } finally {
                    }
                } catch (RemoteException | AssertionError e) {
                    Slogf.e("DevicePolicyManager", "Installing certificate", e);
                    injector = this.mInjector;
                    injector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    logInstallKeyPairFailure(callerIdentity, isCredentialManagementApp);
                    return false;
                }
            } finally {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
            }
        } catch (InterruptedException e2) {
            Slogf.w("DevicePolicyManager", "Interrupted while installing certificate", e2);
            Thread.currentThread().interrupt();
            injector = this.mInjector;
        }
    }

    public final void installUpdateFromFile(ComponentName componentName, String str, ParcelFileDescriptor parcelFileDescriptor, StartInstallingUpdateCallback startInstallingUpdateCallback) {
        CallerIdentity callerIdentity;
        if (!isPermissionCheckFlagEnabled()) {
            Objects.requireNonNull(componentName, "ComponentName is null");
        }
        if (isPermissionCheckFlagEnabled()) {
            callerIdentity = getCallerIdentity(componentName, str);
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES", callerIdentity.mPackageName, -1);
        } else {
            callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        }
        checkCanExecuteOrThrowUnsafe(26);
        DevicePolicyEventLogger.createEvent(73).setAdmin(callerIdentity.mPackageName).setBoolean("true".equalsIgnoreCase(SystemProperties.get("ro.build.ab_update", ""))).write();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda51 devicePolicyManagerService$$ExternalSyntheticLambda51 = new DevicePolicyManagerService$$ExternalSyntheticLambda51(this, parcelFileDescriptor, startInstallingUpdateCallback, 1);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda51);
    }

    public final boolean isAccessibilityServicePermittedByAdmin(ComponentName componentName, String str, int i) {
        if (!this.mHasFeature) {
            return true;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkStringNotEmpty(str, "packageName is null");
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can query if an accessibility service is disabled by admin");
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                if (activeAdminUncheckedLocked == null) {
                    return false;
                }
                if (activeAdminUncheckedLocked.permittedAccessiblityServices == null) {
                    return true;
                }
                return checkPackagesInPermittedListOrSystem(i, Collections.singletonList(str), activeAdminUncheckedLocked.permittedAccessiblityServices);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    /* JADX WARN: Code restructure failed: missing block: B:7:0x0035, code lost:
    
        if (getTargetSdk(r5, r3.info.getPackageName()) >= 29) goto L12;
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public boolean isActiveAdminWithPolicyForUserLocked(com.android.server.devicepolicy.ActiveAdmin r3, int r4, int r5) {
        /*
            r2 = this;
            r2.ensureLocked()
            android.app.admin.DeviceAdminInfo r0 = r3.info
            android.content.ComponentName r0 = r0.getComponent()
            boolean r0 = r2.isDeviceOwner(r5, r0)
            android.app.admin.DeviceAdminInfo r1 = r3.info
            android.content.ComponentName r1 = r1.getComponent()
            boolean r1 = r2.isProfileOwner(r5, r1)
            if (r0 != 0) goto L37
            if (r1 != 0) goto L37
            java.util.Set r0 = com.android.server.devicepolicy.DevicePolicyManagerService.DA_DISALLOWED_POLICIES
            java.lang.Integer r1 = java.lang.Integer.valueOf(r4)
            android.util.ArraySet r0 = (android.util.ArraySet) r0
            boolean r0 = r0.contains(r1)
            if (r0 == 0) goto L37
            android.app.admin.DeviceAdminInfo r0 = r3.info
            java.lang.String r0 = r0.getPackageName()
            int r2 = r2.getTargetSdk(r5, r0)
            r5 = 29
            if (r2 >= r5) goto L41
        L37:
            android.app.admin.DeviceAdminInfo r2 = r3.info
            boolean r2 = r2.usesPolicy(r4)
            if (r2 == 0) goto L41
            r2 = 1
            goto L42
        L41:
            r2 = 0
        L42:
            return r2
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.isActiveAdminWithPolicyForUserLocked(com.android.server.devicepolicy.ActiveAdmin, int, int):boolean");
    }

    public final boolean isActiveAdminWithPolicyForUserLockedMDM(ActiveAdmin activeAdmin, int i, int i2) {
        ensureLocked();
        return isDeviceOwner(i2, activeAdmin.info.getComponent()) || isProfileOwner(i2, activeAdmin.info.getComponent()) || activeAdmin.info.usesPolicy(i);
    }

    public final boolean isActivePasswordSufficient(String str, int i, boolean z) {
        boolean z2;
        if (!this.mHasFeature) {
            return true;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        if (z) {
            enforceUserUnlocked(getProfileParentId(i));
        } else {
            enforceUserUnlocked(i);
        }
        synchronized (getLockObject()) {
            try {
                if (isPermissionCheckFlagEnabled()) {
                    enforcePermission("android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", str, z ? getProfileParentId(i) : i);
                } else {
                    this.mInjector.getClass();
                    this.mInjector.getClass();
                    if (Binder.getCallingPid() == Process.myPid()) {
                        getActiveAdminForCallerLockedMDM(0, i, (ComponentName) null);
                    } else {
                        getActiveAdminOrCheckPermissionForCallerLocked(null, null, 0, z);
                    }
                }
                int credentialOwner = getCredentialOwner(i, z);
                DevicePolicyData userDataUnchecked = getUserDataUnchecked(credentialOwner);
                PasswordMetrics userPasswordMetrics = this.mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);
                int profileParentUserIfRequested = getProfileParentUserIfRequested(i, z);
                z2 = userDataUnchecked.mPasswordValidAtLastCheckpoint;
                this.mInjector.getClass();
                if (StorageManager.isFileEncrypted() || userPasswordMetrics != null) {
                    if (userPasswordMetrics == null) {
                        throw new IllegalStateException("isActivePasswordSufficient called on FBE-locked user");
                    }
                    z2 = isPasswordSufficientForUserWithoutCheckpointLocked(userPasswordMetrics, profileParentUserIfRequested);
                }
            } finally {
            }
        }
        return z2;
    }

    public final boolean isActivePasswordSufficientForDeviceRequirement() {
        boolean isEmpty;
        if (!this.mHasFeature) {
            return true;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        Preconditions.checkCallingUser(isManagedProfile(userId));
        int profileParentId = getProfileParentId(userId);
        enforceUserUnlocked(profileParentId);
        synchronized (getLockObject()) {
            isEmpty = PasswordMetrics.validatePasswordMetrics(getPasswordMinimumMetricsUnchecked(profileParentId, true), getAggregatedPasswordComplexityLocked(profileParentId, true), this.mLockSettingsInternal.getUserPasswordMetrics(profileParentId)).isEmpty();
        }
        DevicePolicyEventLogger.createEvent(189).setStrings(new String[]{this.mOwners.getProfileOwnerComponent(UserHandle.getUserId(callerIdentity.mUid)).getPackageName()}).write();
        return isEmpty;
    }

    public final boolean isAdminActive(ComponentName componentName, int i) {
        boolean z;
        if (!this.mHasFeature) {
            return false;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            z = getActiveAdminUncheckedLocked(i, componentName) != null;
        }
        return z;
    }

    public final boolean isAdminAffectedByRestriction(ComponentName componentName, int i, String str) {
        int userRestrictionSource = this.mUserManager.getUserRestrictionSource(str, UserHandle.of(i));
        if (userRestrictionSource == 0) {
            return false;
        }
        if (userRestrictionSource == 2 || userRestrictionSource == 4) {
            return (isDeviceOwner(i, componentName) || isProfileOwner(i, componentName)) ? false : true;
        }
        return true;
    }

    public final boolean isAdminTestOnlyLocked(int i, ComponentName componentName) {
        ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
        return activeAdminUncheckedLocked != null && activeAdminUncheckedLocked.testOnlyAdmin;
    }

    public final boolean isAffiliatedUser(int i) {
        if (!this.mHasFeature) {
            return false;
        }
        Preconditions.checkCallAuthorization(hasCrossUsersPermission(getCallerIdentity(null, null), i));
        return isUserAffiliatedWithDevice(i);
    }

    public final boolean isAliasInCredentialManagementAppPolicy(CallerIdentity callerIdentity, String str) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda10 devicePolicyManagerService$$ExternalSyntheticLambda10 = new DevicePolicyManagerService$$ExternalSyntheticLambda10(this, callerIdentity, str, 1);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda10)).booleanValue();
    }

    public final boolean isAlwaysOnVpnLockdownEnabled(ComponentName componentName) {
        CallerIdentity callerIdentity;
        if (hasCallingPermission("android.permission.MAINLINE_NETWORK_STACK")) {
            callerIdentity = getCallerIdentity(null, null);
        } else {
            callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 2);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7)).booleanValue();
    }

    public final boolean isAlwaysOnVpnLockdownEnabledForUser(int i) {
        boolean z;
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can call isAlwaysOnVpnLockdownEnabledForUser");
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(i);
                z = deviceOrProfileOwnerAdminLocked != null && deviceOrProfileOwnerAdminLocked.mAlwaysOnVpnLockdown;
            } finally {
            }
        }
        return z;
    }

    public final boolean isApplicationHidden(ComponentName componentName, String str, String str2, boolean z) {
        boolean booleanValue;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        int profileParentId = z ? getProfileParentId(UserHandle.getUserId(callerIdentity.mUid)) : UserHandle.getUserId(callerIdentity.mUid);
        enforcePermission("android.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE", callerIdentity.mPackageName, profileParentId);
        synchronized (getLockObject()) {
            if (z) {
                try {
                    Injector injector = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda21 devicePolicyManagerService$$ExternalSyntheticLambda21 = new DevicePolicyManagerService$$ExternalSyntheticLambda21(this, str2, profileParentId, 5);
                    injector.getClass();
                    Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda21);
                } catch (Throwable th) {
                    throw th;
                }
            }
            Injector injector2 = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda20 devicePolicyManagerService$$ExternalSyntheticLambda20 = new DevicePolicyManagerService$$ExternalSyntheticLambda20(this, str2, profileParentId, 3);
            injector2.getClass();
            booleanValue = ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda20)).booleanValue();
        }
        return booleanValue;
    }

    public final boolean isAuditLogEnabled(String str) {
        if (!this.mHasFeature) {
            return false;
        }
        if (!Flags.securityLogV2Enabled()) {
            throw new UnsupportedOperationException("Audit log not enabled");
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        return Boolean.TRUE.equals((Boolean) this.mDevicePolicyEngine.getGlobalPolicySetByAdmin(PolicyDefinition.AUDIT_LOGGING, enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), null, "android.permission.MANAGE_DEVICE_POLICY_AUDIT_LOGGING", callerIdentity.mPackageName)));
    }

    public final boolean isAuthorizedSamsungPackage(ComponentName componentName) {
        String packageName = componentName.getPackageName();
        PackageManager packageManager = this.mInjector.mContext.getPackageManager();
        this.mInjector.getClass();
        if (!Arrays.asList(packageManager.getPackagesForUid(Binder.getCallingUid())).contains(packageName)) {
            Slogf.e("DevicePolicyManager", "Invalid ComponentName for uid, not proceeding.");
            return false;
        }
        if (isPackageSignedByPlatform(packageName)) {
            return true;
        }
        Slogf.e("DevicePolicyManager", "Not Samsung Package, not proceeding.");
        return false;
    }

    public final boolean isBackupServiceEnabled(ComponentName componentName) {
        boolean z = true;
        if (!this.mHasFeature) {
            return true;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        if (!isDefaultDeviceOwner(callerIdentity) && !isProfileOwner(callerIdentity) && !isFinancedDeviceOwner(callerIdentity)) {
            z = false;
        }
        Preconditions.checkCallAuthorization(z);
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 0);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7)).booleanValue();
    }

    public final boolean isCaCertApproved(String str, int i) {
        boolean contains;
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        synchronized (getLockObject()) {
            contains = getUserData(i).mAcceptedCaCertificates.contains(str);
        }
        return contains;
    }

    public final boolean isCallerApplicationRestrictionsManagingPackage(String str) {
        return isCallerDelegate(getCallerIdentity(null, null).mUid, str, "delegation-app-restrictions");
    }

    public final boolean isCallerDelegate(int i, String str, String str2) {
        Objects.requireNonNull(str, "callerPackage is null");
        if (!Arrays.asList(DELEGATIONS).contains(str2)) {
            throw new IllegalArgumentException(ConnectivityModuleConnector$$ExternalSyntheticOutline0.m("Unexpected delegation scope: ", str2));
        }
        int userId = UserHandle.getUserId(i);
        synchronized (getLockObject()) {
            try {
                List list = (List) getUserData(userId).mDelegationMap.get(str);
                if (list == null || !list.contains(str2)) {
                    return false;
                }
                return isCallingFromPackage(i, str);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean isCallerDelegate(CallerIdentity callerIdentity) {
        boolean z;
        Objects.requireNonNull(callerIdentity.mPackageName, "callerPackage is null");
        synchronized (getLockObject()) {
            z = ((List) getUserData(UserHandle.getUserId(callerIdentity.mUid)).mDelegationMap.get(callerIdentity.mPackageName)) != null;
        }
        return z;
    }

    public final boolean isCallerDelegate(CallerIdentity callerIdentity, String str) {
        boolean z = false;
        if (callerIdentity.mPackageName == null) {
            return false;
        }
        Preconditions.checkArgument(Arrays.asList(DELEGATIONS).contains(str), "Unexpected delegation scope: %s", new Object[]{str});
        synchronized (getLockObject()) {
            try {
                List list = (List) getUserData(UserHandle.getUserId(callerIdentity.mUid)).mDelegationMap.get(callerIdentity.mPackageName);
                if (list != null && list.contains(str)) {
                    z = true;
                }
            } finally {
            }
        }
        return z;
    }

    public final boolean isCallingFromPackage(int i, String str) {
        this.mInjector.getClass();
        PackageManagerLocal.UnfilteredSnapshot withUnfilteredSnapshot = ((PackageManagerLocal) LocalManagerRegistry.getManager(PackageManagerLocal.class)).withUnfilteredSnapshot();
        try {
            PackageState packageState = (PackageState) withUnfilteredSnapshot.getPackageStates().get(str);
            int userId = UserHandle.getUserId(i);
            if (packageState == null) {
                Slogf.d("DevicePolicyManager", "Calling UID " + i + " not found");
                withUnfilteredSnapshot.close();
                return false;
            }
            if (packageState.getUserStateOrDefault(userId).isInstalled()) {
                boolean z = i == UserHandle.getUid(userId, packageState.getAppId());
                withUnfilteredSnapshot.close();
                return z;
            }
            Slogf.d("DevicePolicyManager", "Calling UID " + i + " not installed");
            withUnfilteredSnapshot.close();
            return false;
        } catch (Throwable th) {
            if (withUnfilteredSnapshot != null) {
                try {
                    withUnfilteredSnapshot.close();
                } catch (Throwable th2) {
                    th.addSuppressed(th2);
                }
            }
            throw th;
        }
    }

    public final boolean isCallingUserAffiliated() {
        boolean isUserAffiliatedWithDeviceLocked;
        if (!this.mHasFeature) {
            return false;
        }
        synchronized (getLockObject()) {
            this.mInjector.getClass();
            isUserAffiliatedWithDeviceLocked = isUserAffiliatedWithDeviceLocked(Injector.userHandleGetCallingUserId());
        }
        return isUserAffiliatedWithDeviceLocked;
    }

    public final boolean isCommonCriteriaModeEnabled(ComponentName componentName) {
        boolean z;
        boolean z2;
        boolean z3 = true;
        if (componentName != null) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            if (!isDefaultDeviceOwner(callerIdentity) && !isProfileOwnerOfOrganizationOwnedDevice(callerIdentity)) {
                z3 = false;
            }
            Preconditions.checkCallAuthorization(z3, "Common Criteria mode can only be controlled by a device owner or a profile owner on an organization-owned device.");
            synchronized (getLockObject()) {
                z2 = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).mCommonCriteriaMode;
            }
            return z2;
        }
        this.mInjector.getClass();
        this.mSecurityPolicyHelper.getClass();
        if (MdfUtils.isMdfEnforced()) {
            return true;
        }
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();
                z = deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked != null ? deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked.mCommonCriteriaMode : false;
            } catch (Throwable th) {
                throw th;
            }
        }
        return z;
    }

    public final boolean isComplianceAcknowledgementRequired() {
        boolean z;
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        enforceUserUnlocked(UserHandle.getUserId(callerIdentity.mUid));
        synchronized (getLockObject()) {
            z = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).mProfileOffDeadline != 0;
        }
        return z;
    }

    public final boolean isCredentialManagementApp(CallerIdentity callerIdentity) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 3);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7)).booleanValue();
    }

    public final boolean isCurrentInputMethodSetByOwner() {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity) || hasCallingOrSelfPermission("android.permission.QUERY_ADMIN_POLICY") || isSystemUid(callerIdentity), "Only profile owner, device owner, a caller with QUERY_ADMIN_POLICY permission or system may call this method.");
        return getUserData(UserHandle.getUserId(callerIdentity.mUid)).mCurrentInputMethodSet;
    }

    public final boolean isCurrentUserDemo() {
        if (!UserManager.isDeviceInDemoMode(this.mContext)) {
            return false;
        }
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, userHandleGetCallingUserId, 12);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6)).booleanValue();
    }

    public final boolean isDefaultDeviceOwner(CallerIdentity callerIdentity) {
        boolean z;
        synchronized (getLockObject()) {
            try {
                if (isDeviceOwnerLocked(callerIdentity)) {
                    z = this.mOwners.getDeviceOwnerType(this.mOwners.getDeviceOwnerPackageName()) == 0;
                }
            } finally {
            }
        }
        return z;
    }

    public final boolean isDeviceFinanced(String str) {
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        Preconditions.checkCallAuthorization(isDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) || isProfileOwnerOnUser0(callerIdentity) || doesCallerHoldRole(callerIdentity, "android.app.role.DEVICE_POLICY_MANAGEMENT") || doesCallerHoldRole(callerIdentity, "android.app.role.SYSTEM_SUPERVISION"));
        return getRoleHolderPackageNameOnUser(-1, "android.app.role.FINANCED_DEVICE_KIOSK") != null;
    }

    public final boolean isDeviceOwner(int i, ComponentName componentName) {
        boolean z;
        synchronized (getLockObject()) {
            try {
                z = this.mOwners.hasDeviceOwner() && this.mOwners.getDeviceOwnerUserId() == i && this.mOwners.getDeviceOwnerComponent().equals(componentName);
            } finally {
            }
        }
        return z;
    }

    public final boolean isDeviceOwner(ActiveAdmin activeAdmin) {
        return isDeviceOwner(activeAdmin.getUserHandle().getIdentifier(), activeAdmin.info.getComponent());
    }

    public final boolean isDeviceOwner(CallerIdentity callerIdentity) {
        boolean isDeviceOwnerLocked;
        synchronized (getLockObject()) {
            isDeviceOwnerLocked = isDeviceOwnerLocked(callerIdentity);
        }
        return isDeviceOwnerLocked;
    }

    public final boolean isDeviceOwnerLocked(CallerIdentity callerIdentity) {
        if (this.mOwners.hasDeviceOwner() && this.mOwners.getDeviceOwnerUserId() == UserHandle.getUserId(callerIdentity.mUid)) {
            return callerIdentity.hasAdminComponent() ? this.mOwners.getDeviceOwnerComponent().equals(callerIdentity.mComponentName) : isUidDeviceOwnerLocked(callerIdentity.mUid);
        }
        return false;
    }

    public final boolean isDevicePotentiallyStolen(String str) {
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        if (!Flags.deviceTheftImplEnabled()) {
            return false;
        }
        enforcePermission("android.permission.QUERY_DEVICE_STOLEN_STATE", callerIdentity.mPackageName, UserHandle.getUserId(callerIdentity.mUid));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 8);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7)).booleanValue();
    }

    public final boolean isDeviceProvisioned() {
        boolean z;
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        synchronized (getLockObject()) {
            z = getUserDataUnchecked(0).mUserSetupComplete;
        }
        return z;
    }

    public final boolean isDeviceProvisioningConfigApplied() {
        boolean z;
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        synchronized (getLockObject()) {
            z = getUserData(0).mDeviceProvisioningConfigApplied;
        }
        return z;
    }

    public final boolean isDpcDownloaded() {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        ContentResolver contentResolver = this.mContext.getContentResolver();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda4 devicePolicyManagerService$$ExternalSyntheticLambda4 = new DevicePolicyManagerService$$ExternalSyntheticLambda4(2, contentResolver);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda4)).booleanValue();
    }

    public final boolean isEphemeralUser(ComponentName componentName) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 1);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7)).booleanValue();
    }

    public final boolean isFactoryResetProtectionPolicySupported() {
        return getFrpManagementAgentUid() != -1;
    }

    public final boolean isFinancedDeviceOwner(CallerIdentity callerIdentity) {
        boolean z;
        synchronized (getLockObject()) {
            try {
                if (isDeviceOwnerLocked(callerIdentity)) {
                    z = true;
                    if (this.mOwners.getDeviceOwnerType(this.mOwners.getDeviceOwnerPackageName()) == 1) {
                    }
                }
                z = false;
            } finally {
            }
        }
        return z;
    }

    public final boolean isInputMethodPermittedByAdmin(ComponentName componentName, String str, int i, boolean z) {
        if (!this.mHasFeature) {
            return true;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkStringNotEmpty(str, "packageName is null");
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can query if an input method is disabled by admin");
        if (z) {
            i = getProfileParentId(i);
        }
        LinkedHashMap localPoliciesSetByAdmins = this.mDevicePolicyEngine.getLocalPoliciesSetByAdmins(PolicyDefinition.PERMITTED_INPUT_METHODS, i);
        for (EnforcingAdmin enforcingAdmin : localPoliciesSetByAdmins.keySet()) {
            if (enforcingAdmin.mPackageName.equals(componentName.getPackageName())) {
                if (((PolicyValue) localPoliciesSetByAdmins.get(enforcingAdmin)).getValue() == null) {
                    return true;
                }
                return checkPackagesInPermittedListOrSystem(i, Collections.singletonList(str), new ArrayList((Collection) ((PolicyValue) localPoliciesSetByAdmins.get(enforcingAdmin)).getValue()));
            }
        }
        return false;
    }

    public final boolean isKeyPairGrantedToWifiAuth(String str, String str2) {
        Preconditions.checkStringNotEmpty(str2, "Alias to check cannot be empty");
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        Preconditions.checkCallAuthorization(canChooseCertificates(callerIdentity));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda10 devicePolicyManagerService$$ExternalSyntheticLambda10 = new DevicePolicyManagerService$$ExternalSyntheticLambda10(this, callerIdentity, str2, 0);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda10)).booleanValue();
    }

    public final boolean isLockTaskPermitted(String str) {
        if (((ArrayList) listPolicyExemptAppsUnchecked(this.mContext)).contains(str)) {
            return true;
        }
        this.mInjector.getClass();
        LockTaskPolicy lockTaskPolicy = (LockTaskPolicy) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.LOCK_TASK, Injector.userHandleGetCallingUserId());
        if (lockTaskPolicy == null) {
            return false;
        }
        return lockTaskPolicy.getPackages().contains(str);
    }

    public final boolean isLogoutEnabled() {
        boolean z = false;
        if (!this.mHasFeature) {
            return false;
        }
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
                if (deviceOwnerAdminLocked != null && deviceOwnerAdminLocked.isLogoutEnabled) {
                    z = true;
                }
            } finally {
            }
        }
        return z;
    }

    public final boolean isManagedKiosk() {
        if (!this.mHasFeature) {
            return false;
        }
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                return isManagedKioskInternal();
            } catch (RemoteException e) {
                throw new IllegalStateException(e);
            }
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final boolean isManagedKioskInternal() {
        if (this.mOwners.hasDeviceOwner()) {
            this.mInjector.getClass();
            if (ActivityManager.getService().getLockTaskModeState() == 1) {
                LockTaskPolicy lockTaskPolicy = (LockTaskPolicy) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.LOCK_TASK, getCurrentForegroundUserId());
                if (((lockTaskPolicy == null ? 16 : lockTaskPolicy.getFlags()) & 1) != 1) {
                    Iterator it = this.mUserManager.getUsers().iterator();
                    while (true) {
                        if (!it.hasNext()) {
                            Iterator it2 = this.mUserManager.getUsers().iterator();
                            while (it2.hasNext()) {
                                if (UserManager.get(this.mInjector.mContext).isUserEphemeral(((UserInfo) it2.next()).id)) {
                                }
                            }
                            return true;
                        }
                        if (this.mLockPatternUtils.isSecure(((UserInfo) it.next()).id)) {
                            break;
                        }
                    }
                }
            }
        }
        return false;
    }

    public final boolean isManagedProfile(int i) {
        UserInfo userInfo = getUserInfo(i);
        return userInfo != null && userInfo.isManagedProfile();
    }

    public final boolean isManagedProfile(ComponentName componentName) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        return isManagedProfile(UserHandle.getUserId(callerIdentity.mUid));
    }

    public final boolean isManagedProfileOwner(CallerIdentity callerIdentity) {
        return isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid));
    }

    public final boolean isMasterVolumeMuted(ComponentName componentName) {
        boolean isMasterMute;
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            isMasterMute = ((AudioManager) this.mContext.getSystemService("audio")).isMasterMute();
        }
        return isMasterMute;
    }

    public final boolean isMeteredDataDisabledPackageForUser(ComponentName componentName, String str, int i) {
        List list;
        Objects.requireNonNull(componentName);
        if (!this.mHasFeature) {
            return false;
        }
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can query restricted pkgs for a specific user");
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                if (activeAdminUncheckedLocked == null || (list = activeAdminUncheckedLocked.meteredDisabledPackages) == null) {
                    return false;
                }
                return list.contains(str);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean isNetworkLoggingEnabled(ComponentName componentName, String str) {
        boolean isNetworkLoggingEnabledInternalLocked;
        if (!this.mHasFeature) {
            return false;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && (isDefaultDeviceOwner(callerIdentity) || (isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid))))) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-network-logging")) || hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        synchronized (getLockObject()) {
            isNetworkLoggingEnabledInternalLocked = isNetworkLoggingEnabledInternalLocked();
        }
        return isNetworkLoggingEnabledInternalLocked;
    }

    public final boolean isNetworkLoggingEnabledInternalLocked() {
        int networkLoggingAffectedUser = getNetworkLoggingAffectedUser();
        ActiveAdmin deviceOrProfileOwnerAdminLocked = networkLoggingAffectedUser < 0 ? null : getDeviceOrProfileOwnerAdminLocked(networkLoggingAffectedUser);
        return deviceOrProfileOwnerAdminLocked != null && deviceOrProfileOwnerAdminLocked.isNetworkLoggingEnabled;
    }

    public final boolean isNewUserDisclaimerAcknowledged(int i) {
        boolean z = false;
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS"));
        synchronized (getLockObject()) {
            DevicePolicyData userData = getUserData(i);
            String str = userData.mNewUserDisclaimer;
            int i2 = userData.mUserId;
            if (str != null) {
                switch (str) {
                    case "not_needed":
                    case "acked":
                        z = true;
                        break;
                    case "needed":
                        break;
                    default:
                        Slogf.w("DevicePolicyManager", "isNewUserDisclaimerAcknowledged(%d): invalid value %d", Integer.valueOf(i2), userData.mNewUserDisclaimer);
                        break;
                }
            } else {
                if (i2 != 0) {
                    Slogf.w("DevicePolicyManager", "isNewUserDisclaimerAcknowledged(%d): mNewUserDisclaimer is null", Integer.valueOf(i2));
                }
                z = true;
            }
        }
        return z;
    }

    public final boolean isNotificationListenerServicePermitted(String str, int i) {
        if (!this.mHasFeature) {
            return true;
        }
        Preconditions.checkStringNotEmpty(str, "packageName is null or empty");
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can query if a notification listener service is permitted");
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                if (profileOwnerAdminLocked != null && profileOwnerAdminLocked.permittedNotificationListeners != null) {
                    return checkPackagesInPermittedListOrSystem(i, Collections.singletonList(str), profileOwnerAdminLocked.permittedNotificationListeners);
                }
                return true;
            } finally {
            }
        }
    }

    public final boolean isOrganizationOwnedDeviceWithManagedProfile() {
        return this.mHasFeature && getOrganizationOwnedProfileUserId() != -10000;
    }

    public final boolean isOverrideApnEnabled(ComponentName componentName) {
        if (!this.mHasFeature || (!this.mHasTelephonyFeature && !this.mHasTelephonyDataFeature)) {
            return false;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 11);
        injector.getClass();
        Cursor cursor = (Cursor) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33);
        if (cursor == null) {
            return false;
        }
        try {
            try {
                if (cursor.moveToFirst()) {
                    return cursor.getInt(cursor.getColumnIndex("enforced")) == 1;
                }
            } catch (IllegalArgumentException e) {
                Slogf.e("DevicePolicyManager", "Cursor returned from ENFORCE_MANAGED_URI doesn't contain correct info.", e);
            }
            return false;
        } finally {
            cursor.close();
        }
    }

    public final boolean isPackageAllowedToAccessCalendarForUser(String str, int i) {
        if (!this.mHasFeature) {
            return false;
        }
        Preconditions.checkStringNotEmpty(str, "Package name is null or empty");
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        this.mInjector.getClass();
        PackageManagerLocal.UnfilteredSnapshot withUnfilteredSnapshot = ((PackageManagerLocal) LocalManagerRegistry.getManager(PackageManagerLocal.class)).withUnfilteredSnapshot();
        try {
            PackageState packageState = (PackageState) withUnfilteredSnapshot.getPackageStates().get(str);
            if (packageState == null) {
                Slogf.w("DevicePolicyManager", "Couldn't find package %s in user %d", str, Integer.valueOf(i));
                withUnfilteredSnapshot.close();
                return false;
            }
            if (!packageState.getUserStateOrDefault(i).isInstalled()) {
                Slogf.w("DevicePolicyManager", "Couldn't find installed package %s in user %d", str, Integer.valueOf(i));
                withUnfilteredSnapshot.close();
                return false;
            }
            int uid = UserHandle.getUid(i, packageState.getAppId());
            withUnfilteredSnapshot.close();
            if (getCallerIdentity(null, null).mUid != uid) {
                Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS") || hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL"));
            }
            synchronized (getLockObject()) {
                try {
                    if (Settings.Secure.getIntForUser(this.mInjector.mContext.getContentResolver(), "cross_profile_calendar_enabled", 0, i) == 0) {
                        return false;
                    }
                    ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i);
                    if (profileOwnerAdminLocked == null) {
                        return false;
                    }
                    List list = profileOwnerAdminLocked.mCrossProfileCalendarPackages;
                    if (list == null) {
                        return true;
                    }
                    return list.contains(str);
                } catch (Throwable th) {
                    throw th;
                }
            }
        } catch (Throwable th2) {
            if (withUnfilteredSnapshot != null) {
                try {
                    withUnfilteredSnapshot.close();
                } catch (Throwable th3) {
                    th2.addSuppressed(th3);
                }
            }
            throw th2;
        }
    }

    public final boolean isPackageInstalledForUser(int i, String str) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda20 devicePolicyManagerService$$ExternalSyntheticLambda20 = new DevicePolicyManagerService$$ExternalSyntheticLambda20(this, str, i, 1);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda20)).booleanValue();
    }

    public final boolean isPackageSignedByPlatform(String str) {
        boolean z = this.mInjector.mContext.getPackageManager().checkSignatures("android", str) == 0;
        Log.d("DevicePolicyManager", "EAS IT Policy " + str + " isPackageSignedByPlatform = " + z);
        return z;
    }

    public final boolean isPackageSuspended(ComponentName componentName, String str, String str2) {
        boolean isPackageSuspendedForUser;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        if (Flags.unmanagedModeMigration()) {
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE", callerIdentity.mPackageName, UserHandle.getUserId(callerIdentity.mUid));
        } else {
            Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-package-access")));
        }
        synchronized (getLockObject()) {
            this.mInjector.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                try {
                    isPackageSuspendedForUser = this.mIPackageManager.isPackageSuspendedForUser(str2, UserHandle.getUserId(callerIdentity.mUid));
                } catch (RemoteException e) {
                    Slogf.e("DevicePolicyManager", "Failed talking to the package manager", e);
                    return false;
                }
            } finally {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
            }
        }
        return isPackageSuspendedForUser;
    }

    public final boolean isPasswordSufficientAfterProfileUnification(int i, int i2) {
        if (!this.mHasFeature) {
            return true;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(!isManagedProfile(i), "You can not check password sufficiency for a managed profile, userId = %d", new Object[]{Integer.valueOf(i)});
        enforceUserUnlocked(i);
        synchronized (getLockObject()) {
            try {
                PasswordMetrics userPasswordMetrics = this.mLockSettingsInternal.getUserPasswordMetrics(i);
                ArrayList arrayList = (ArrayList) getActiveAdminsForUserAndItsManagedProfilesLocked(i, new DevicePolicyManagerService$$ExternalSyntheticLambda179(i2, 0, this));
                ArrayList arrayList2 = new ArrayList(arrayList.size());
                if (Flags.unmanagedModeMigration()) {
                    Iterator it = arrayList.iterator();
                    while (it.hasNext()) {
                        arrayList2.add(((ActiveAdmin) it.next()).mPasswordPolicy.getMinMetrics());
                    }
                    Integer num = (Integer) getResolvedPolicyForUserAndItsManagedProfiles(PolicyDefinition.PASSWORD_COMPLEXITY, i, new DevicePolicyManagerService$$ExternalSyntheticLambda179(i2, 1, this));
                    return PasswordMetrics.validatePasswordMetrics(PasswordMetrics.merge(arrayList2), num != null ? num.intValue() : 0, userPasswordMetrics).isEmpty();
                }
                Iterator it2 = arrayList.iterator();
                while (it2.hasNext()) {
                    ActiveAdmin activeAdmin = (ActiveAdmin) it2.next();
                    arrayList2.add(activeAdmin.mPasswordPolicy.getMinMetrics());
                    r5 = Math.max(r5, activeAdmin.mPasswordComplexity);
                }
                return PasswordMetrics.validatePasswordMetrics(PasswordMetrics.merge(arrayList2), r5, userPasswordMetrics).isEmpty();
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean isPasswordSufficientForUserWithoutCheckpointLocked(PasswordMetrics passwordMetrics, int i) {
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            if (!semIsSimplePasswordEnabled(null, i)) {
                if (this.mContext == null) {
                    Slogf.e("DevicePolicyManager", "isActivePasswordSufficient() : fail to get isDevicePasswordSimple() due to mContext == null");
                } else if (this.mLockPatternUtils.isDevicePasswordSimple(i)) {
                    Slogf.e("DevicePolicyManager", "isActivePasswordSufficient() : simple password is not allowed");
                    return false;
                }
            }
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            return PasswordMetrics.validatePasswordMetrics(getPasswordMinimumMetricsUnchecked(i, false), getAggregatedPasswordComplexityLocked(i, false), passwordMetrics).isEmpty();
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final boolean isProfileOwner(int i, ComponentName componentName) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, i, 6);
        injector.getClass();
        return componentName != null && componentName.equals((ComponentName) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6));
    }

    public final boolean isProfileOwner(CallerIdentity callerIdentity) {
        synchronized (getLockObject()) {
            try {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 9);
                injector.getClass();
                ComponentName componentName = (ComponentName) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7);
                if (componentName == null) {
                    return false;
                }
                if (callerIdentity.hasAdminComponent()) {
                    return componentName.equals(callerIdentity.mComponentName);
                }
                return isUidProfileOwnerLocked(callerIdentity.mUid);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean isProfileOwnerOfOrganizationOwnedDevice(int i) {
        boolean isProfileOwnerOfOrganizationOwnedDevice;
        synchronized (getLockObject()) {
            isProfileOwnerOfOrganizationOwnedDevice = this.mOwners.isProfileOwnerOfOrganizationOwnedDevice(i);
        }
        return isProfileOwnerOfOrganizationOwnedDevice;
    }

    public final boolean isProfileOwnerOfOrganizationOwnedDevice(CallerIdentity callerIdentity) {
        return isProfileOwner(callerIdentity) && isProfileOwnerOfOrganizationOwnedDevice(UserHandle.getUserId(callerIdentity.mUid));
    }

    public final boolean isProfileOwnerOfOrganizationOwnedDeviceMDM(int i) {
        boolean isProfileOwnerOfOrganizationOwnedDevice;
        synchronized (getLockObject()) {
            isProfileOwnerOfOrganizationOwnedDevice = this.mOwners.isProfileOwnerOfOrganizationOwnedDevice(i);
        }
        return isProfileOwnerOfOrganizationOwnedDevice;
    }

    public final boolean isProfileOwnerOnUser0(CallerIdentity callerIdentity) {
        return isProfileOwner(callerIdentity) && UserHandle.getUserHandleForUid(callerIdentity.mUid).isSystem();
    }

    public final boolean isProvisioningAllowed(String str, String str2) {
        Objects.requireNonNull(str2);
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            Preconditions.checkArgument(Arrays.asList(this.mInjector.mContext.getPackageManager().getPackagesForUid(callerIdentity.mUid)).contains(str2), "Caller uid doesn't match the one for the provided package.");
            return checkProvisioningPreconditionSkipPermission(UserHandle.getUserId(callerIdentity.mUid), null, str, str2) == 0;
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final boolean isRemovingAdmin(ComponentName componentName, int i) {
        boolean contains;
        if (!this.mHasFeature) {
            return false;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            contains = getUserData(i).mRemovingAdmins.contains(componentName);
        }
        return contains;
    }

    public final boolean isResetPasswordTokenActive(ComponentName componentName, String str) {
        boolean z = false;
        if (!this.mHasFeature || !this.mLockPatternUtils.hasSecureLockScreen()) {
            return false;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            long j = getUserData(userId).mPasswordTokenHandle;
            if (j != 0) {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda23 devicePolicyManagerService$$ExternalSyntheticLambda23 = new DevicePolicyManagerService$$ExternalSyntheticLambda23(this, j, userId, 0);
                injector.getClass();
                z = ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda23)).booleanValue();
            }
        }
        return z;
    }

    public final boolean isResetPasswordTokenActiveMDM(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                getActiveAdminForCallerLockedMDM(2, i, componentName);
                DevicePolicyData userData = getUserData(i);
                if (userData.mPasswordTokenHandle == 0) {
                    return false;
                }
                this.mInjector.getClass();
                long clearCallingIdentity = Binder.clearCallingIdentity();
                try {
                    return this.mLockPatternUtils.isEscrowTokenActive(userData.mPasswordTokenHandle, i);
                } finally {
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean isSafeOperation(int i) {
        DevicePolicySafetyChecker devicePolicySafetyChecker = this.mSafetyChecker;
        if (devicePolicySafetyChecker == null) {
            return true;
        }
        return devicePolicySafetyChecker.isSafeOperation(i);
    }

    public final boolean isSecondaryLockscreenEnabled(UserHandle userHandle) {
        boolean z;
        synchronized (getLockObject()) {
            z = getUserData(userHandle.getIdentifier()).mSecondaryLockscreenEnabled;
        }
        return z;
    }

    public final boolean isSecurityLoggingEnabled(ComponentName componentName, String str) {
        boolean loggingEnabledProperty;
        boolean z = false;
        if (!this.mHasFeature) {
            return false;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        if (isSystemUid(callerIdentity)) {
            this.mInjector.getClass();
            return SecurityLog.getLoggingEnabledProperty();
        }
        if (Flags.securityLogV2Enabled()) {
            return Boolean.TRUE.equals((Boolean) this.mDevicePolicyEngine.getGlobalPolicySetByAdmin(PolicyDefinition.SECURITY_LOGGING, enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING", callerIdentity.mPackageName)));
        }
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    if (!isProfileOwnerOfOrganizationOwnedDevice(callerIdentity)) {
                        if (isDefaultDeviceOwner(callerIdentity)) {
                        }
                        Preconditions.checkCallAuthorization(z);
                    }
                    z = true;
                    Preconditions.checkCallAuthorization(z);
                } else {
                    Preconditions.checkCallAuthorization(isCallerDelegate(callerIdentity, "delegation-security-logging"));
                }
                this.mInjector.getClass();
                loggingEnabledProperty = SecurityLog.getLoggingEnabledProperty();
            } catch (Throwable th) {
                throw th;
            }
        }
        return loggingEnabledProperty;
    }

    public final boolean isSeparateProfileChallengeEnabled(int i) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, i, 0);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6)).booleanValue();
    }

    public final boolean isStatusBarDisabled(String str) {
        boolean z;
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        synchronized (getLockObject()) {
            try {
                Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId), "Admin " + str + " is neither the device owner or affiliated user's profile owner.");
                if (isManagedProfile(userId)) {
                    throw new SecurityException("Managed profile cannot disable status bar");
                }
                z = getUserData(userId).mStatusBarDisabled;
            } catch (Throwable th) {
                throw th;
            }
        }
        return z;
    }

    public final boolean isSupervisionComponent(ComponentName componentName) {
        if (!this.mHasFeature) {
            return false;
        }
        synchronized (getLockObject()) {
            try {
                if (this.mConstants.USE_TEST_ADMIN_AS_SUPERVISION_COMPONENT && isAdminTestOnlyLocked(UserHandle.getUserId(getCallerIdentity(null, null).mUid), componentName)) {
                    return true;
                }
                return isSupervisionComponentLocked(componentName);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean isSupervisionComponentLocked(ComponentName componentName) {
        if (componentName == null) {
            return false;
        }
        String string = this.mContext.getResources().getString(R.string.deprecated_target_sdk_app_store);
        if (string != null && componentName.equals(ComponentName.unflattenFromString(string))) {
            return true;
        }
        return componentName.getPackageName().equals(this.mContext.getResources().getString(R.string.config_systemSupervision));
    }

    public final boolean isUidDeviceOwnerLocked(int i) {
        String[] packagesForUid;
        ensureLocked();
        String packageName = this.mOwners.getDeviceOwnerComponent().getPackageName();
        try {
            this.mInjector.getClass();
            packagesForUid = AppGlobals.getPackageManager().getPackagesForUid(i);
        } catch (RemoteException unused) {
        }
        if (packagesForUid == null) {
            return false;
        }
        for (String str : packagesForUid) {
            if (packageName.equals(str)) {
                return true;
            }
        }
        return false;
    }

    public final boolean isUidProfileOwnerLocked(int i) {
        ensureLocked();
        int userId = UserHandle.getUserId(i);
        ComponentName profileOwnerComponent = this.mOwners.getProfileOwnerComponent(userId);
        if (profileOwnerComponent == null) {
            return false;
        }
        Iterator it = getUserData(userId).mAdminList.iterator();
        while (it.hasNext()) {
            ActiveAdmin activeAdmin = (ActiveAdmin) it.next();
            ComponentName component = activeAdmin.info.getComponent();
            if (activeAdmin.getUid() == i && profileOwnerComponent.equals(component)) {
                return true;
            }
        }
        return false;
    }

    public final boolean isUnattendedManagedKiosk() {
        if (!this.mHasFeature) {
            return false;
        }
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 0);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33)).booleanValue();
    }

    public final boolean isUninstallBlocked(String str) {
        boolean blockUninstallForUser;
        int callingUserId = UserHandle.getCallingUserId();
        synchronized (getLockObject()) {
            try {
                try {
                    blockUninstallForUser = this.mIPackageManager.getBlockUninstallForUser(str, callingUserId);
                } catch (RemoteException e) {
                    Slogf.e("DevicePolicyManager", "Failed to getBlockUninstallForUser", e);
                    return false;
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        return blockUninstallForUser;
    }

    public final boolean isUninstallInQueue(String str) {
        boolean contains;
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_DEVICE_ADMINS"));
        UserPackage of = UserPackage.of(UserHandle.getUserId(callerIdentity.mUid), str);
        synchronized (getLockObject()) {
            contains = ((ArraySet) this.mPackagesToRemove).contains(of);
        }
        return contains;
    }

    public final boolean isUsbDataSignalingEnabled(String str) {
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        boolean z = true;
        if (Flags.policyEngineMigrationV2Enabled()) {
            Boolean bool = (Boolean) this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.USB_DATA_SIGNALING, UserHandle.getUserId(callerIdentity.mUid));
            return bool == null || bool.booleanValue();
        }
        synchronized (getLockObject()) {
            try {
                if (!isDefaultDeviceOwner(callerIdentity) && !isProfileOwnerOfOrganizationOwnedDevice(callerIdentity)) {
                    ActiveAdmin deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();
                    if (deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked != null && !deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked.mUsbDataSignalingEnabled) {
                        z = false;
                    }
                    return z;
                }
                return getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).mUsbDataSignalingEnabled;
            } finally {
            }
        }
    }

    public final boolean isUserAffiliatedWithDevice(int i) {
        boolean isUserAffiliatedWithDeviceLocked;
        synchronized (getLockObject()) {
            isUserAffiliatedWithDeviceLocked = isUserAffiliatedWithDeviceLocked(i);
        }
        return isUserAffiliatedWithDeviceLocked;
    }

    public final boolean isUserAffiliatedWithDeviceLocked(int i) {
        if (!this.mOwners.hasDeviceOwner()) {
            return false;
        }
        if (i == 0 || i == this.mOwners.getDeviceOwnerUserId()) {
            return true;
        }
        if (getProfileOwnerAsUser(i) == null) {
            return false;
        }
        Set set = getUserData(i).mAffiliationIds;
        Set set2 = getUserData(0).mAffiliationIds;
        Iterator it = set.iterator();
        while (it.hasNext()) {
            if (set2.contains((String) it.next())) {
                return true;
            }
        }
        return false;
    }

    public final boolean isUsingUnifiedPassword(ComponentName componentName) {
        if (!this.mHasFeature) {
            return true;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        Preconditions.checkCallingUser(isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)));
        return !isSeparateProfileChallengeEnabled(UserHandle.getUserId(callerIdentity.mUid));
    }

    public final List listForegroundAffiliatedUsers() {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity), callerIdentity.mUid + " is not device owner");
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 15);
        injector.getClass();
        return (List) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33);
    }

    public final List listPolicyExemptApps() {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_DEVICE_ADMINS") || isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        return listPolicyExemptAppsUnchecked(this.mContext);
    }

    /* JADX WARN: Finally extract failed */
    /* JADX WARN: Removed duplicated region for block: B:34:0x0084 A[Catch: all -> 0x0059, RemoteException -> 0x005c, TryCatch #2 {all -> 0x0059, blocks: (B:11:0x0034, B:13:0x0048, B:15:0x0053, B:16:0x005f, B:17:0x0066, B:19:0x0067, B:20:0x006e, B:28:0x0072, B:32:0x007c, B:34:0x0084, B:37:0x009d, B:38:0x00c1, B:42:0x00cb, B:43:0x00d1, B:46:0x0089, B:47:0x00b1, B:50:0x0028), top: B:49:0x0028, outer: #0 }] */
    /* JADX WARN: Removed duplicated region for block: B:42:0x00cb A[Catch: all -> 0x0059, RemoteException -> 0x005c, TryCatch #2 {all -> 0x0059, blocks: (B:11:0x0034, B:13:0x0048, B:15:0x0053, B:16:0x005f, B:17:0x0066, B:19:0x0067, B:20:0x006e, B:28:0x0072, B:32:0x007c, B:34:0x0084, B:37:0x009d, B:38:0x00c1, B:42:0x00cb, B:43:0x00d1, B:46:0x0089, B:47:0x00b1, B:50:0x0028), top: B:49:0x0028, outer: #0 }] */
    /* JADX WARN: Removed duplicated region for block: B:44:0x00d0  */
    /* JADX WARN: Removed duplicated region for block: B:47:0x00b1 A[Catch: all -> 0x0059, RemoteException -> 0x005c, TryCatch #2 {all -> 0x0059, blocks: (B:11:0x0034, B:13:0x0048, B:15:0x0053, B:16:0x005f, B:17:0x0066, B:19:0x0067, B:20:0x006e, B:28:0x0072, B:32:0x007c, B:34:0x0084, B:37:0x009d, B:38:0x00c1, B:42:0x00cb, B:43:0x00d1, B:46:0x0089, B:47:0x00b1, B:50:0x0028), top: B:49:0x0028, outer: #0 }] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void lockNow(int r11, java.lang.String r12, boolean r13) {
        /*
            Method dump skipped, instructions count: 281
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.lockNow(int, java.lang.String, boolean):void");
    }

    public final void logPasswordComplexityRequiredIfSecurityLogEnabled(int i, int i2, String str, boolean z) {
        if (SecurityLog.isLoggingEnabled()) {
            SecurityLog.writeEvent(210035, new Object[]{str, Integer.valueOf(i), Integer.valueOf(z ? getProfileParentId(i) : i), Integer.valueOf(i2)});
        }
    }

    public final void logPasswordQualitySetIfSecurityLogEnabled(ComponentName componentName, int i, boolean z, PasswordPolicy passwordPolicy) {
        if (SecurityLog.isLoggingEnabled()) {
            SecurityLog.writeEvent(210017, new Object[]{componentName.getPackageName(), Integer.valueOf(i), Integer.valueOf(z ? getProfileParentId(i) : i), Integer.valueOf(passwordPolicy.length), Integer.valueOf(passwordPolicy.quality), Integer.valueOf(passwordPolicy.letters), Integer.valueOf(passwordPolicy.nonLetter), Integer.valueOf(passwordPolicy.numeric), Integer.valueOf(passwordPolicy.upperCase), Integer.valueOf(passwordPolicy.lowerCase), Integer.valueOf(passwordPolicy.symbols)});
        }
    }

    public final int logoutUser(ComponentName componentName) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        checkCanExecuteOrThrowUnsafe(9);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        synchronized (getLockObject()) {
            if (!isUserAffiliatedWithDeviceLocked(userId)) {
                throw new SecurityException("Admin " + componentName + " is neither the device owner or affiliated user's profile owner.");
            }
        }
        if (isManagedProfile(userId)) {
            Slogf.w("DevicePolicyManager", "Managed profile cannot be logout");
            return 2;
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 14);
        injector.getClass();
        if (userId == ((Integer) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33)).intValue()) {
            return logoutUserUnchecked(userId);
        }
        Slogf.d("DevicePolicyManager", "logoutUser(): user %d is in background, just stopping, not switching", Integer.valueOf(userId));
        return stopUserUnchecked(userId);
    }

    public final int logoutUserInternal() {
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS") || hasCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS"));
        return logoutUserUnchecked(getCurrentForegroundUserId());
    }

    public final int logoutUserUnchecked(int i) {
        int logoutUserIdUnchecked = getLogoutUserIdUnchecked();
        if (logoutUserIdUnchecked == -10000) {
            Slogf.w("DevicePolicyManager", "logoutUser(): could not determine which user to switch to");
            return 1;
        }
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            Slogf.i("DevicePolicyManager", "logoutUser(): switching to user %d", Integer.valueOf(logoutUserIdUnchecked));
            this.mInjector.getClass();
            if (!ActivityManager.getService().switchUser(logoutUserIdUnchecked)) {
                Slogf.w("DevicePolicyManager", "Failed to switch to user %d", Integer.valueOf(logoutUserIdUnchecked));
                return 1;
            }
            synchronized (getLockObject()) {
                setLogoutUserIdLocked(-10000);
            }
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            return stopUserUnchecked(i);
        } catch (RemoteException unused) {
            return 1;
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final JournaledFile makeJournaledFile(int i, String str) {
        File userSystemDirectory;
        if (i == 0) {
            this.mPathProvider.getClass();
            userSystemDirectory = Environment.getDataSystemDirectory();
        } else {
            this.mPathProvider.getClass();
            userSystemDirectory = Environment.getUserSystemDirectory(i);
        }
        String absolutePath = new File(userSystemDirectory, str).getAbsolutePath();
        return new JournaledFile(new File(absolutePath), new File(ConnectivityModuleConnector$$ExternalSyntheticOutline0.m$1(absolutePath, ".tmp")));
    }

    public final void manageUserUnchecked(ComponentName componentName, ComponentName componentName2, int i, PersistableBundle persistableBundle, boolean z) {
        synchronized (getLockObject()) {
        }
        String packageName = componentName.getPackageName();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda21 devicePolicyManagerService$$ExternalSyntheticLambda21 = new DevicePolicyManagerService$$ExternalSyntheticLambda21(this, packageName, i, 0);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda21);
        setActiveAdmin(componentName2, true, i);
        setProfileOwner(componentName2, i);
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userData = getUserData(i);
                userData.mInitBundle = persistableBundle;
                userData.mAdminBroadcastPending = true;
                userData.mNewUserDisclaimer = z ? "needed" : "not_needed";
                saveSettingsLocked(i, false, false, false);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void maybeInstallDevicePolicyManagementRoleHolderInUser(int i) {
        String roleHolderPackageNameOnUser = getRoleHolderPackageNameOnUser(this.mContext, "android.app.role.DEVICE_POLICY_MANAGEMENT", Process.myUserHandle());
        if (roleHolderPackageNameOnUser == null) {
            Slogf.d("DevicePolicyManager", "No device policy management role holder specified.");
            return;
        }
        try {
            if (this.mIPackageManager.isPackageAvailable(roleHolderPackageNameOnUser, i)) {
                Slogf.d("DevicePolicyManager", "The device policy management role holder " + roleHolderPackageNameOnUser + " is already installed in user " + i);
                return;
            }
            Slogf.d("DevicePolicyManager", "Installing the device policy management role holder " + roleHolderPackageNameOnUser + " in user " + i);
            this.mIPackageManager.installExistingPackageAsUser(roleHolderPackageNameOnUser, i, 4194304, 1, (List) null);
        } catch (RemoteException unused) {
        }
    }

    public final void maybeMigrateAccount(int i, int i2, Account account, boolean z, String str) {
        UserHandle of = UserHandle.of(i2);
        UserHandle of2 = UserHandle.of(i);
        if (account == null) {
            Slogf.d("DevicePolicyManager", "No account to migrate.");
            return;
        }
        if (of.equals(of2)) {
            Slogf.w("DevicePolicyManager", "sourceUser and targetUser are the same, won't migrate account.");
            return;
        }
        if (Flags.copyAccountWithRetryEnabled()) {
            boolean z2 = false;
            for (int i3 = 3; !z2 && i3 > 0; i3 += -1) {
                Slogf.i("DevicePolicyManager", "Copying account. Attempts left : " + i3);
                z2 = copyAccount(of2, of, account, str);
            }
        } else {
            copyAccount(of2, of, account, str);
        }
        if (z) {
            return;
        }
        try {
            Bundle result = ((AccountManager) this.mContext.createContextAsUser(UserHandle.of(i2), 0).getSystemService(AccountManager.class)).removeAccount(account, null, null, null).getResult(60L, TimeUnit.SECONDS);
            if (result.getBoolean("booleanResult", false)) {
                Slogf.i("DevicePolicyManager", "Account removed from the primary user.");
            } else {
                Intent intent = (Intent) result.getParcelable(KnoxCustomManagerService.INTENT, Intent.class);
                intent.addFlags(268435456);
                Slogf.i("DevicePolicyManager", "Starting activity to remove account");
                new Handler(Looper.getMainLooper()).post(new DevicePolicyManagerService$$ExternalSyntheticLambda27(this, intent, 0));
            }
        } catch (AuthenticatorException | OperationCanceledException | IOException e) {
            Slogf.e("DevicePolicyManager", "Exception removing account from the primary user.", e);
        }
    }

    public final void maybeMigratePoliciesPostUpgradeToDevicePolicyEngineLocked() {
        boolean z;
        boolean z2;
        Owners owners = this.mOwners;
        synchronized (owners.mData) {
            z = owners.mData.mMigratedToPolicyEngine;
        }
        if (z) {
            Owners owners2 = this.mOwners;
            synchronized (owners2.mData) {
                z2 = owners2.mData.mPoliciesMigratedPostUpdate;
            }
            if (z2) {
                return;
            }
            migratePoliciesPostUpgradeToDevicePolicyEngineLocked();
            Owners owners3 = this.mOwners;
            synchronized (owners3.mData) {
                OwnersData ownersData = owners3.mData;
                ownersData.mPoliciesMigratedPostUpdate = true;
                ownersData.writeDeviceOwner();
            }
        }
    }

    public final boolean maybeMigrateSuspendedPackagesLocked() {
        boolean z;
        Slog.i("DevicePolicyManager", "Migrating suspended packages to policy engine");
        if (!Flags.unmanagedModeMigration()) {
            return false;
        }
        Owners owners = this.mOwners;
        synchronized (owners.mData) {
            z = owners.mData.mSuspendedPackagesMigrated;
        }
        if (z) {
            return false;
        }
        synchronized (this.mDevicePolicyEngine.mLock) {
            DevicePolicyEngine.DevicePoliciesReaderWriter.createBackup();
        }
        try {
            Binder.withCleanCallingIdentity(new DevicePolicyManagerService$$ExternalSyntheticLambda46(6, this, new DevicePolicyManagerService$$ExternalSyntheticLambda99(this, 1)));
        } catch (Exception e) {
            Slog.wtf("DevicePolicyManager", "Failed to migrate suspended packages to policy engine", e);
        }
        Slog.i("DevicePolicyManager", "Marking suspended packages migration complete");
        Owners owners2 = this.mOwners;
        synchronized (owners2.mData) {
            OwnersData ownersData = owners2.mData;
            ownersData.mSuspendedPackagesMigrated = true;
            ownersData.writeDeviceOwner();
        }
        return true;
    }

    public final void maybePauseDeviceWideLoggingLocked() {
        NetworkLoggingHandler networkLoggingHandler;
        if (areAllUsersAffiliatedWithDeviceLocked()) {
            return;
        }
        if (this.mOwners.hasDeviceOwner()) {
            Slogf.i("DevicePolicyManager", "There are unaffiliated users, network logging will be paused if enabled.");
            NetworkLogger networkLogger = this.mNetworkLogger;
            if (networkLogger != null && (networkLoggingHandler = networkLogger.mNetworkLoggingHandler) != null) {
                synchronized (networkLoggingHandler) {
                    Slog.d("NetworkLoggingHandler", "Paused network logging");
                    networkLoggingHandler.mPaused = true;
                }
            }
        }
        if (isOrganizationOwnedDeviceWithManagedProfile()) {
            return;
        }
        Slogf.i("DevicePolicyManager", "Not org-owned managed profile device, security logging will be paused if enabled.");
        SecurityLogMonitor securityLogMonitor = this.mSecurityLogMonitor;
        securityLogMonitor.getClass();
        Slog.i("SecurityLogMonitor", "Paused.");
        ((ReentrantLock) securityLogMonitor.mLock).lock();
        securityLogMonitor.mPaused = true;
        securityLogMonitor.mAllowedToRetrieve = false;
        ((ReentrantLock) securityLogMonitor.mLock).unlock();
    }

    public final void maybeSetDefaultProfileOwnerUserRestrictions() {
        synchronized (getLockObject()) {
            try {
                Iterator it = this.mOwners.getProfileOwnerKeys().iterator();
                while (it.hasNext()) {
                    int intValue = ((Integer) it.next()).intValue();
                    ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(intValue);
                    if (profileOwnerAdminLocked != null && this.mUserManager.isManagedProfile(intValue)) {
                        maybeSetDefaultRestrictionsForAdminLocked(intValue, profileOwnerAdminLocked);
                        ensureUnknownSourcesRestrictionForProfileOwnerLocked(intValue, profileOwnerAdminLocked, false);
                    }
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void maybeSetDefaultRestrictionsForAdminLocked(int i, ActiveAdmin activeAdmin) {
        ArraySet arraySet = (ArraySet) UserRestrictionsUtils.DEFAULT_ENABLED_FOR_MANAGED_PROFILES;
        if (arraySet.equals(activeAdmin.defaultEnabledRestrictionsAlreadySet)) {
            return;
        }
        this.mInjector.getClass();
        this.mInjector.getClass();
        if (SemPersonaManager.isSecureFolderId(i)) {
            return;
        }
        Iterator it = arraySet.iterator();
        while (it.hasNext()) {
            this.mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.getPolicyDefinitionForUserRestriction((String) it.next()), EnforcingAdmin.createEnterpriseEnforcingAdmin(activeAdmin.getUserHandle().getIdentifier(), activeAdmin.info.getComponent()), new BooleanPolicyValue(true), i, false);
        }
        ((ArraySet) activeAdmin.defaultEnabledRestrictionsAlreadySet).addAll((Collection) arraySet);
        Slogf.i("DevicePolicyManager", "Enabled the following restrictions by default: " + arraySet);
    }

    public final void maybeStartSecurityLogMonitorOnActivityManagerReady() {
        this.mInjector.getClass();
        if (SecurityLog.isLoggingEnabled()) {
            if (Flags.securityLogV2Enabled()) {
                Boolean bool = Boolean.TRUE;
                setLoggingConfiguration(bool.equals(this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.SECURITY_LOGGING, -1)), bool.equals(this.mDevicePolicyEngine.getResolvedPolicy(PolicyDefinition.AUDIT_LOGGING, -1)));
                this.mInjector.getClass();
                CryptoTestHelper.runAndLogSelfTest();
                return;
            }
            synchronized (getLockObject()) {
                this.mSecurityLogMonitor.start(getSecurityLoggingEnabledUser());
                this.mInjector.getClass();
                CryptoTestHelper.runAndLogSelfTest();
                maybePauseDeviceWideLoggingLocked();
            }
        }
    }

    public final boolean migratePoliciesPostUpgradeToDevicePolicyEngineLocked() {
        try {
            Binder.withCleanCallingIdentity(new DevicePolicyManagerService$$ExternalSyntheticLambda57(12, this));
            Binder.withCleanCallingIdentity(new DevicePolicyManagerService$$ExternalSyntheticLambda57(2, this));
            Binder.withCleanCallingIdentity(new DevicePolicyManagerService$$ExternalSyntheticLambda57(5, this));
            return true;
        } catch (Exception e) {
            Slogf.e("DevicePolicyManager", e, "Error occurred during post upgrade migration to the device policy engine.", new Object[0]);
            return false;
        }
    }

    /* JADX WARN: Removed duplicated region for block: B:34:0x0094  */
    /* JADX WARN: Removed duplicated region for block: B:36:? A[RETURN, SYNTHETIC] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void migratePoliciesToPolicyEngineLocked() {
        /*
            r4 = this;
            boolean r0 = android.app.admin.flags.Flags.securityLogV2Enabled()
            r1 = 1
            if (r0 == 0) goto L3b
            com.android.server.devicepolicy.Owners r0 = r4.mOwners
            com.android.server.devicepolicy.OwnersData r2 = r0.mData
            monitor-enter(r2)
            com.android.server.devicepolicy.OwnersData r0 = r0.mData     // Catch: java.lang.Throwable -> L38
            boolean r0 = r0.mSecurityLoggingMigrated     // Catch: java.lang.Throwable -> L38
            monitor-exit(r2)     // Catch: java.lang.Throwable -> L38
            if (r0 == 0) goto L14
            goto L3b
        L14:
            r4.migrateSecurityLoggingPolicyInternalLocked()     // Catch: java.lang.Exception -> L18
            goto L20
        L18:
            r0 = move-exception
            java.lang.String r2 = "DevicePolicyManager"
            java.lang.String r3 = "Failed to properly migrate security logging to policy engine"
            android.util.Slog.e(r2, r3, r0)
        L20:
            java.lang.String r0 = "DevicePolicyManager"
            java.lang.String r2 = "Marking security logging policy migration complete"
            android.util.Slog.i(r0, r2)
            com.android.server.devicepolicy.Owners r0 = r4.mOwners
            com.android.server.devicepolicy.OwnersData r3 = r0.mData
            monitor-enter(r3)
            com.android.server.devicepolicy.OwnersData r0 = r0.mData     // Catch: java.lang.Throwable -> L35
            r0.mSecurityLoggingMigrated = r1     // Catch: java.lang.Throwable -> L35
            r0.writeDeviceOwner()     // Catch: java.lang.Throwable -> L35
            monitor-exit(r3)     // Catch: java.lang.Throwable -> L35
            goto L3b
        L35:
            r4 = move-exception
            monitor-exit(r3)     // Catch: java.lang.Throwable -> L35
            throw r4
        L38:
            r4 = move-exception
            monitor-exit(r2)     // Catch: java.lang.Throwable -> L38
            throw r4
        L3b:
            java.lang.String r0 = "DevicePolicyManager"
            java.lang.String r2 = "Migrating password complexity to policy engine"
            android.util.Slog.i(r0, r2)
            boolean r0 = android.app.admin.flags.Flags.unmanagedModeMigration()
            r2 = 0
            if (r0 != 0) goto L4b
        L49:
            r1 = r2
            goto L8d
        L4b:
            com.android.server.devicepolicy.Owners r0 = r4.mOwners
            com.android.server.devicepolicy.OwnersData r3 = r0.mData
            monitor-enter(r3)
            com.android.server.devicepolicy.OwnersData r0 = r0.mData     // Catch: java.lang.Throwable -> La2
            boolean r0 = r0.mRequiredPasswordComplexityMigrated     // Catch: java.lang.Throwable -> La2
            monitor-exit(r3)     // Catch: java.lang.Throwable -> La2
            if (r0 == 0) goto L58
            goto L49
        L58:
            com.android.server.devicepolicy.DevicePolicyEngine r0 = r4.mDevicePolicyEngine
            java.lang.Object r0 = r0.mLock
            monitor-enter(r0)
            com.android.server.devicepolicy.DevicePolicyEngine.DevicePoliciesReaderWriter.createBackup()     // Catch: java.lang.Throwable -> L9f
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L9f
            com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda99 r0 = new com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda99     // Catch: java.lang.Exception -> L71
            r2 = 0
            r0.<init>(r4, r2)     // Catch: java.lang.Exception -> L71
            com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda46 r2 = new com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda46     // Catch: java.lang.Exception -> L71
            r3 = 6
            r2.<init>(r3, r4, r0)     // Catch: java.lang.Exception -> L71
            android.os.Binder.withCleanCallingIdentity(r2)     // Catch: java.lang.Exception -> L71
            goto L79
        L71:
            r0 = move-exception
            java.lang.String r2 = "DevicePolicyManager"
            java.lang.String r3 = "Failed to migrate password complexity to policy engine"
            android.util.Slog.wtf(r2, r3, r0)
        L79:
            java.lang.String r0 = "DevicePolicyManager"
            java.lang.String r2 = "Marking password complexity migration complete"
            android.util.Slog.i(r0, r2)
            com.android.server.devicepolicy.Owners r0 = r4.mOwners
            com.android.server.devicepolicy.OwnersData r2 = r0.mData
            monitor-enter(r2)
            com.android.server.devicepolicy.OwnersData r0 = r0.mData     // Catch: java.lang.Throwable -> L9c
            r0.mRequiredPasswordComplexityMigrated = r1     // Catch: java.lang.Throwable -> L9c
            r0.writeDeviceOwner()     // Catch: java.lang.Throwable -> L9c
            monitor-exit(r2)     // Catch: java.lang.Throwable -> L9c
        L8d:
            boolean r4 = r4.maybeMigrateSuspendedPackagesLocked()
            r4 = r4 | r1
            if (r4 == 0) goto L9b
            java.lang.String r4 = "DevicePolicyManager"
            java.lang.String r0 = "Backup made: 35.1.unmanaged-mode"
            com.android.server.utils.Slogf.i(r4, r0)
        L9b:
            return
        L9c:
            r4 = move-exception
            monitor-exit(r2)     // Catch: java.lang.Throwable -> L9c
            throw r4
        L9f:
            r4 = move-exception
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L9f
            throw r4
        La2:
            r4 = move-exception
            monitor-exit(r3)     // Catch: java.lang.Throwable -> La2
            throw r4
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.migratePoliciesToPolicyEngineLocked():void");
    }

    public final void migrateSecurityLoggingPolicyInternalLocked() {
        Slog.i("DevicePolicyManager", "Migrating security logging policy to policy engine");
        this.mInjector.getClass();
        if (!SecurityLog.getLoggingEnabledProperty()) {
            Slog.i("DevicePolicyManager", "Security logs not enabled, exiting");
            return;
        }
        ActiveAdmin deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();
        if (deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked == null) {
            Slog.wtf("DevicePolicyManager", "Security logging is enabled, but no appropriate admin found");
        } else {
            this.mDevicePolicyEngine.setGlobalPolicy(PolicyDefinition.SECURITY_LOGGING, EnforcingAdmin.createEnterpriseEnforcingAdmin(deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked.info.getComponent(), deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked.getUserHandle().getIdentifier(), deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked), new BooleanPolicyValue(true));
        }
    }

    public final void migrateToProfileOnOrganizationOwnedDeviceIfCompLocked() {
        final int deviceOwnerUserId = this.mOwners.getDeviceOwnerUserId();
        if (deviceOwnerUserId == -10000) {
            return;
        }
        List profiles = this.mUserManager.getProfiles(deviceOwnerUserId);
        if (profiles.size() != 2) {
            if (profiles.size() == 1) {
                return;
            }
            Slogf.wtf("DevicePolicyManager", "Found " + profiles.size() + " profiles, skipping migration");
            return;
        }
        int managedUserId = getManagedUserId(deviceOwnerUserId);
        if (managedUserId < 0) {
            Slogf.wtf("DevicePolicyManager", "Found DO and a profile, but it is not managed, skipping migration");
            return;
        }
        ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
        ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(managedUserId);
        if (deviceOwnerAdminLocked == null || profileOwnerAdminLocked == null) {
            Slogf.wtf("DevicePolicyManager", "Failed to get either PO or DO admin, aborting migration.");
            return;
        }
        ComponentName deviceOwnerComponent = this.mOwners.getDeviceOwnerComponent();
        ComponentName profileOwnerComponent = this.mOwners.getProfileOwnerComponent(managedUserId);
        if (deviceOwnerComponent == null || profileOwnerComponent == null) {
            Slogf.wtf("DevicePolicyManager", "Cannot find PO or DO component name, aborting migration.");
            return;
        }
        if (!deviceOwnerComponent.getPackageName().equals(profileOwnerComponent.getPackageName())) {
            Slogf.e("DevicePolicyManager", "DO and PO are different packages, aborting migration.");
            return;
        }
        Slogf.i("DevicePolicyManager", "Migrating COMP to PO on a corp owned device; primary user: %d; profile: %d", Integer.valueOf(deviceOwnerUserId), Integer.valueOf(managedUserId));
        Slogf.i("DevicePolicyManager", "Giving the PO additional power...");
        setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(managedUserId, profileOwnerComponent, true);
        Slogf.i("DevicePolicyManager", "Migrating DO policies to PO...");
        ActiveAdmin parentActiveAdmin = profileOwnerAdminLocked.getParentActiveAdmin();
        if (parentActiveAdmin.mPasswordPolicy.quality == 0) {
            parentActiveAdmin.mPasswordPolicy = deviceOwnerAdminLocked.mPasswordPolicy;
        }
        if (parentActiveAdmin.passwordHistoryLength == 0) {
            parentActiveAdmin.passwordHistoryLength = deviceOwnerAdminLocked.passwordHistoryLength;
        }
        if (parentActiveAdmin.passwordExpirationTimeout == 0) {
            parentActiveAdmin.passwordExpirationTimeout = deviceOwnerAdminLocked.passwordExpirationTimeout;
        }
        if (parentActiveAdmin.maximumFailedPasswordsForWipe == 0) {
            parentActiveAdmin.maximumFailedPasswordsForWipe = deviceOwnerAdminLocked.maximumFailedPasswordsForWipe;
        }
        if (parentActiveAdmin.maximumTimeToUnlock == 0) {
            parentActiveAdmin.maximumTimeToUnlock = deviceOwnerAdminLocked.maximumTimeToUnlock;
        }
        if (parentActiveAdmin.strongAuthUnlockTimeout == 259200000) {
            parentActiveAdmin.strongAuthUnlockTimeout = deviceOwnerAdminLocked.strongAuthUnlockTimeout;
        }
        parentActiveAdmin.disabledKeyguardFeatures |= deviceOwnerAdminLocked.disabledKeyguardFeatures & 951;
        parentActiveAdmin.trustAgentInfos.putAll(deviceOwnerAdminLocked.trustAgentInfos);
        parentActiveAdmin.disableCamera = deviceOwnerAdminLocked.disableCamera;
        parentActiveAdmin.disableScreenCapture = deviceOwnerAdminLocked.disableScreenCapture;
        ((ArraySet) parentActiveAdmin.accountTypesWithManagementDisabled).addAll(deviceOwnerAdminLocked.accountTypesWithManagementDisabled);
        Bundle bundle = deviceOwnerAdminLocked.userRestrictions;
        if (bundle != null) {
            for (String str : bundle.keySet()) {
                if (((ArraySet) UserRestrictionsUtils.PROFILE_OWNER_ORGANIZATION_OWNED_PARENT_GLOBAL_RESTRICTIONS).contains(str) || ((ArraySet) UserRestrictionsUtils.PROFILE_OWNER_ORGANIZATION_OWNED_PARENT_LOCAL_RESTRICTIONS).contains(str)) {
                    parentActiveAdmin.ensureUserRestrictions().putBoolean(str, deviceOwnerAdminLocked.userRestrictions.getBoolean(str));
                }
            }
        }
        if (deviceOwnerAdminLocked.requireAutoTime) {
            parentActiveAdmin.ensureUserRestrictions().putBoolean("no_config_date_time", true);
        }
        this.mInjector.getClass();
        PackageManagerService.PackageManagerInternalImpl packageManagerInternalImpl = (PackageManagerService.PackageManagerInternalImpl) Injector.getPackageManagerInternal();
        packageManagerInternalImpl.getClass();
        if (!packageManagerInternalImpl.mService.snapshotComputer().isSuspendingAnyPackages(Flags.crossUserSuspensionEnabledRo() ? 0 : deviceOwnerUserId, deviceOwnerUserId)) {
            Slogf.i("DevicePolicyManager", "DO is not suspending any apps.");
        } else if (getTargetSdk(managedUserId, profileOwnerAdminLocked.info.getPackageName()) >= 30) {
            Slogf.i("DevicePolicyManager", "PO is targeting R+, keeping personal apps suspended.");
            getUserData(deviceOwnerUserId).mAppsSuspended = true;
            profileOwnerAdminLocked.mSuspendPersonalApps = true;
        } else {
            Slogf.i("DevicePolicyManager", "PO isn't targeting R+, unsuspending personal apps.");
            packageManagerInternalImpl.getClass();
            int i = Flags.crossUserSuspensionEnabledRo() ? 0 : deviceOwnerUserId;
            PackageManagerService packageManagerService = packageManagerInternalImpl.mService;
            packageManagerService.unsuspendForSuspendingPackage(i, packageManagerService.snapshotComputer(), "android", false);
        }
        this.mInjector.getClass();
        KnoxPolicyHelper knoxPolicyHelper = this.mKnoxPolicyHelper;
        knoxPolicyHelper.getClass();
        Log.d("KnoxPolicyHelper", "migrateKnoxPoliciesForWpcod()");
        try {
            if (knoxPolicyHelper.getIEDMService() != null) {
                knoxPolicyHelper.mEdmService.migrateKnoxPoliciesForWpcod(managedUserId);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        saveSettingsLocked(managedUserId, false, false, false);
        Slogf.i("DevicePolicyManager", "Clearing the DO...");
        ComponentName component = deviceOwnerAdminLocked.info.getComponent();
        clearDeviceOwnerLocked(deviceOwnerUserId, deviceOwnerAdminLocked);
        Slogf.i("DevicePolicyManager", "Removing admin artifacts...");
        removeAdminArtifacts(deviceOwnerUserId, component);
        Slogf.i("DevicePolicyManager", "Uninstalling the DO...");
        final String packageName = deviceOwnerComponent.getPackageName();
        try {
            ApplicationInfo applicationInfo = this.mIPackageManager.getApplicationInfo(packageName, 786432L, deviceOwnerUserId);
            if (applicationInfo == null) {
                Slogf.wtf("DevicePolicyManager", "Failed to get package info for " + packageName);
            } else if ((applicationInfo.flags & 1) != 0) {
                Slogf.i("DevicePolicyManager", "Package %s is pre-installed, marking disabled until used", packageName);
                this.mContext.getPackageManager().setApplicationEnabledSetting(packageName, 4, 0);
            } else {
                this.mInjector.getPackageManager(deviceOwnerUserId).getPackageInstaller().uninstall(packageName, 0, new IntentSender(new IIntentSender.Stub() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService.3
                    public final void send(int i2, Intent intent, String str2, IBinder iBinder, IIntentReceiver iIntentReceiver, String str3, Bundle bundle2) {
                        int intExtra = intent.getIntExtra("android.content.pm.extra.STATUS", 1);
                        if (intExtra == 0) {
                            Slogf.i("DevicePolicyManager", "Package %s uninstalled for user %d", packageName, Integer.valueOf(deviceOwnerUserId));
                        } else {
                            Slogf.e("DevicePolicyManager", "Failed to uninstall %s; status: %d", packageName, Integer.valueOf(intExtra));
                        }
                    }
                }));
            }
        } catch (RemoteException e2) {
            Slogf.wtf("DevicePolicyManager", "Error getting application info", e2);
        }
        Slogf.i("DevicePolicyManager", "Migration complete.");
        DevicePolicyEventLogger.createEvent(137).setAdmin(profileOwnerComponent).write();
    }

    public final boolean nonTestNonPrecreatedUsersExist() {
        return this.mUserManagerInternal.getUsers(true).stream().filter(new DevicePolicyManagerService$$ExternalSyntheticLambda9(1)).count() > ((long) (UserManager.isHeadlessSystemUserMode() ? 2 : 1));
    }

    public final boolean notSupportedOnAutomotive(String str) {
        if (!this.mIsAutomotive) {
            return false;
        }
        Slogf.i("DevicePolicyManager", "%s is not supported on automotive builds", str);
        return true;
    }

    public final void notifyLockTaskModeChanged(boolean z, String str, int i) {
        Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)), "Only the system can call notifyLockTaskModeChanged");
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userData = getUserData(i);
                if (userData.mStatusBarDisabled) {
                    setStatusBarDisabledInternal(i, !z);
                }
                Bundle bundle = new Bundle();
                bundle.putString("android.app.extra.LOCK_TASK_PACKAGE", str);
                Iterator it = userData.mAdminList.iterator();
                while (it.hasNext()) {
                    ActiveAdmin activeAdmin = (ActiveAdmin) it.next();
                    boolean isDeviceOwner = isDeviceOwner(i, activeAdmin.info.getComponent());
                    boolean isProfileOwner = isProfileOwner(i, activeAdmin.info.getComponent());
                    if (isDeviceOwner || isProfileOwner) {
                        if (z) {
                            sendAdminCommandLocked(activeAdmin, "android.app.action.LOCK_TASK_ENTERING", bundle, null, false);
                        } else {
                            sendAdminCommandLocked(activeAdmin, "android.app.action.LOCK_TASK_EXITING", null, null, false);
                        }
                        DevicePolicyEventLogger createEvent = DevicePolicyEventLogger.createEvent(51);
                        DeviceAdminInfo deviceAdminInfo = activeAdmin.info;
                        createEvent.setAdmin(deviceAdminInfo == null ? null : deviceAdminInfo.getPackageName()).setBoolean(z).setStrings(new String[]{str}).write();
                    }
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        for (EnforcingAdmin enforcingAdmin : this.mDevicePolicyEngine.getLocalPoliciesSetByAdmins(PolicyDefinition.LOCK_TASK, i).keySet()) {
            if (!enforcingAdmin.hasAuthority("enterprise")) {
                DevicePolicyEventLogger.createEvent(51).setAdmin(enforcingAdmin.mPackageName).setBoolean(z).setStrings(new String[]{str}).write();
            }
        }
    }

    public final void notifyMinimumRequiredWifiSecurityLevelChanged(int i) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda29 devicePolicyManagerService$$ExternalSyntheticLambda29 = new DevicePolicyManagerService$$ExternalSyntheticLambda29(i, 1, this);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda29);
    }

    public final void notifyPendingSystemUpdate(SystemUpdateInfo systemUpdateInfo) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.NOTIFY_PENDING_SYSTEM_UPDATE"), "Only the system update service can broadcast update information");
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda57 devicePolicyManagerService$$ExternalSyntheticLambda57 = new DevicePolicyManagerService$$ExternalSyntheticLambda57(4, this);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda57);
        Owners owners = this.mOwners;
        synchronized (owners.mData) {
            try {
                if (Objects.equals(systemUpdateInfo, owners.mData.mSystemUpdateInfo)) {
                    return;
                }
                OwnersData ownersData = owners.mData;
                ownersData.mSystemUpdateInfo = systemUpdateInfo;
                ownersData.writeDeviceOwner();
                Intent putExtra = new Intent("android.app.action.NOTIFY_PENDING_SYSTEM_UPDATE").putExtra("android.app.extra.SYSTEM_UPDATE_RECEIVED_TIME", systemUpdateInfo == null ? -1L : systemUpdateInfo.getReceivedTime());
                Injector injector2 = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda46 devicePolicyManagerService$$ExternalSyntheticLambda46 = new DevicePolicyManagerService$$ExternalSyntheticLambda46(1, this, putExtra);
                injector2.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda46);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void notifyWifiSsidPolicyChanged(WifiSsidPolicy wifiSsidPolicy) {
        if (wifiSsidPolicy == null) {
            return;
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda46 devicePolicyManagerService$$ExternalSyntheticLambda46 = new DevicePolicyManagerService$$ExternalSyntheticLambda46(0, this, wifiSsidPolicy);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda46);
    }

    /* JADX WARN: Removed duplicated region for block: B:44:0x01c2 A[Catch: all -> 0x0193, Exception -> 0x01ca, LOOP:1: B:44:0x01c2->B:46:0x01c6, LOOP_START, TryCatch #2 {Exception -> 0x01ca, blocks: (B:35:0x014b, B:42:0x019d, B:44:0x01c2, B:46:0x01c6, B:54:0x01cc, B:55:0x01d4, B:58:0x019a), top: B:34:0x014b, outer: #0 }] */
    /* JADX WARN: Removed duplicated region for block: B:54:0x01cc A[Catch: all -> 0x0193, Exception -> 0x01ca, TryCatch #2 {Exception -> 0x01ca, blocks: (B:35:0x014b, B:42:0x019d, B:44:0x01c2, B:46:0x01c6, B:54:0x01cc, B:55:0x01d4, B:58:0x019a), top: B:34:0x014b, outer: #0 }] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void onCreateAndProvisionManagedProfileCompleted(android.app.admin.ManagedProfileProvisioningParams r20, int r21) {
        /*
            Method dump skipped, instructions count: 523
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.onCreateAndProvisionManagedProfileCompleted(android.app.admin.ManagedProfileProvisioningParams, int):void");
    }

    /* JADX WARN: Removed duplicated region for block: B:44:0x01b0 A[Catch: all -> 0x0181, Exception -> 0x01b8, LOOP:1: B:44:0x01b0->B:46:0x01b4, LOOP_START, TryCatch #2 {Exception -> 0x01b8, blocks: (B:35:0x013e, B:42:0x018b, B:44:0x01b0, B:46:0x01b4, B:54:0x01ba, B:55:0x01c2, B:58:0x0188), top: B:34:0x013e, outer: #0 }] */
    /* JADX WARN: Removed duplicated region for block: B:54:0x01ba A[Catch: all -> 0x0181, Exception -> 0x01b8, TryCatch #2 {Exception -> 0x01b8, blocks: (B:35:0x013e, B:42:0x018b, B:44:0x01b0, B:46:0x01b4, B:54:0x01ba, B:55:0x01c2, B:58:0x0188), top: B:34:0x013e, outer: #0 }] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void onCreateAndProvisionManagedProfileStarted(android.app.admin.ManagedProfileProvisioningParams r18) {
        /*
            Method dump skipped, instructions count: 506
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.onCreateAndProvisionManagedProfileStarted(android.app.admin.ManagedProfileProvisioningParams):void");
    }

    public final void onLockSettingsReady() {
        Set profileOwnerKeys;
        ArraySet arraySet;
        List list;
        synchronized (getLockObject()) {
            fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration();
        }
        getUserData(0);
        synchronized (getLockObject()) {
            try {
                profileOwnerKeys = this.mOwners.getProfileOwnerKeys();
                arraySet = new ArraySet();
                for (int i = 0; i < this.mUserData.size(); i++) {
                    arraySet.add(Integer.valueOf(this.mUserData.keyAt(i)));
                }
            } finally {
            }
        }
        List users = this.mUserManager.getUsers();
        ArraySet arraySet2 = new ArraySet();
        arraySet2.addAll(profileOwnerKeys);
        arraySet2.addAll((Collection) arraySet);
        Iterator it = users.iterator();
        while (it.hasNext()) {
            arraySet2.remove(Integer.valueOf(((UserInfo) it.next()).id));
        }
        Iterator it2 = arraySet2.iterator();
        while (it2.hasNext()) {
            Integer num = (Integer) it2.next();
            removeUserData(num.intValue());
            this.mDevicePolicyEngine.handleUserRemoved(num.intValue());
        }
        maybeSetDefaultProfileOwnerUserRestrictions();
        handleStartUser(0);
        if (SecurityLog.isLoggingEnabled()) {
            this.mInjector.getClass();
            String str = SystemProperties.get("ro.boot.verifiedbootstate");
            this.mInjector.getClass();
            SecurityLog.writeEvent(210009, new Object[]{str, SystemProperties.get("ro.boot.veritymode")});
        }
        SetupContentObserver setupContentObserver = this.mSetupContentObserver;
        DevicePolicyManagerService.this.mInjector.mContext.getContentResolver().registerContentObserver(setupContentObserver.mUserSetupComplete, false, setupContentObserver, -1);
        DevicePolicyManagerService.this.mInjector.mContext.getContentResolver().registerContentObserver(setupContentObserver.mDeviceProvisioned, false, setupContentObserver, -1);
        DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
        if (devicePolicyManagerService.mIsWatch) {
            devicePolicyManagerService.mInjector.mContext.getContentResolver().registerContentObserver(setupContentObserver.mPaired, false, setupContentObserver, -1);
        }
        DevicePolicyManagerService.this.mInjector.mContext.getContentResolver().registerContentObserver(setupContentObserver.mDefaultImeChanged, false, setupContentObserver, -1);
        updateUserSetupCompleteAndPaired();
        synchronized (getLockObject()) {
            ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
            list = deviceOwnerAdminLocked != null ? deviceOwnerAdminLocked.keepUninstalledPackages : null;
        }
        if (list != null) {
            this.mInjector.getClass();
            PackageManagerService packageManagerService = ((PackageManagerService.PackageManagerInternalImpl) Injector.getPackageManagerInternal()).mService;
            packageManagerService.setKeepUninstalledPackagesInternal(packageManagerService.snapshotComputer(), list);
        }
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOwnerAdminLocked2 = getDeviceOwnerAdminLocked();
                if (deviceOwnerAdminLocked2 != null) {
                    this.mUserManagerInternal.setForceEphemeralUsers(deviceOwnerAdminLocked2.forceEphemeralUsers);
                    this.mInjector.getClass();
                    ActivityManagerInternal activityManagerInternal = Injector.getActivityManagerInternal();
                    activityManagerInternal.setSwitchingFromSystemUserMessage(deviceOwnerAdminLocked2.startUserSessionMessage);
                    activityManagerInternal.setSwitchingToSystemUserMessage(deviceOwnerAdminLocked2.endUserSessionMessage);
                }
                revertTransferOwnershipIfNecessaryLocked();
                if (!Flags.policyEngineMigrationV2Enabled()) {
                    Context context = this.mContext;
                    ActiveAdmin deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();
                    updateUsbDataSignal(context, deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked == null || deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked.mUsbDataSignalingEnabled);
                }
            } finally {
            }
        }
        unsuspendWorkAppsIfNecessary();
    }

    public final void onProvisionFullyManagedDeviceCompleted(FullyManagedDeviceProvisioningParams fullyManagedDeviceProvisioningParams) {
        DualDarProvisioningHelper dualDarProvisioningHelper = this.mDualDarProvisioningHelper;
        if (DualDarProvisioningHelper.isDualDARConfigured(dualDarProvisioningHelper.mContext, fullyManagedDeviceProvisioningParams.getAdminExtras())) {
            Object obj = new Object();
            boolean[] zArr = {false};
            boolean[] zArr2 = new boolean[1];
            int[] iArr = new int[1];
            dualDarProvisioningHelper.mContext.registerReceiver(new DualDarProvisioningHelper.AnonymousClass1(dualDarProvisioningHelper, zArr2, iArr, obj, zArr, 3), GmsAlarmManager$$ExternalSyntheticOutline0.m("com.android.dualdar.completed.provisioning_success", "com.android.dualdar.completed.cancelled", "com.android.dualdar.completed.error"), 2);
            synchronized (obj) {
                try {
                    try {
                        Log.d("DualDarProvisioningHelper", "Starting Knox DUAL DAR DualDar Completed Service");
                        Intent intent = new Intent();
                        intent.setComponent(new ComponentName("com.samsung.android.knox.containercore", "com.samsung.android.knox.containercore.provisioning.DualDarCompletedService"));
                        intent.putExtra("android.intent.extra.user_handle", UserHandle.myUserId());
                        intent.putExtra("DUAL_DAR_PARAMS", DualDarProvisioningHelper.getDualDARConfigParams(dualDarProvisioningHelper.mContext, fullyManagedDeviceProvisioningParams.getAdminExtras()));
                        intent.putExtra("DUAL_DAR_ADMIN_PACKAGE", fullyManagedDeviceProvisioningParams.getDeviceAdminComponentName().getPackageName());
                        intent.putExtra("DUAL_DAR_INTENT_PROVISIONING", DualDarProvisioningHelper.isDualDARIntentProvisioned(fullyManagedDeviceProvisioningParams.getAdminExtras()));
                        intent.putExtra("DUAL_DAR_IS_MANAGED_DEVICE", true);
                        if (DualDarProvisioningHelper.isDualDARNativeCrypto(dualDarProvisioningHelper.mContext, fullyManagedDeviceProvisioningParams.getAdminExtras())) {
                            intent.putExtra("DUAL_DAR_CRYPTO_TYPE", 33554432);
                        } else {
                            intent.putExtra("DUAL_DAR_CRYPTO_TYPE", 67108864);
                        }
                        dualDarProvisioningHelper.startProvisionService(intent);
                        while (!zArr[0]) {
                            obj.wait();
                        }
                    } catch (Exception e) {
                        Log.d("DualDarProvisioningHelper", "Error during onProvisionFullyManagedDeviceCompleted" + e);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (zArr2[0]) {
                return;
            }
            throw new ServiceSpecificException(7, "onProvisionFullyManagedDeviceCompleted failed with result: " + iArr[0]);
        }
    }

    public final void onProvisionFullyManagedDeviceStarted(FullyManagedDeviceProvisioningParams fullyManagedDeviceProvisioningParams) {
        int i;
        DualDarProvisioningHelper dualDarProvisioningHelper = this.mDualDarProvisioningHelper;
        if (DualDarProvisioningHelper.isDualDARConfigured(dualDarProvisioningHelper.mContext, fullyManagedDeviceProvisioningParams.getAdminExtras())) {
            Object obj = new Object();
            boolean[] zArr = {false};
            boolean[] zArr2 = new boolean[1];
            int[] iArr = new int[1];
            dualDarProvisioningHelper.mContext.registerReceiver(new DualDarProvisioningHelper.AnonymousClass1(dualDarProvisioningHelper, zArr2, iArr, obj, zArr, 2), GmsAlarmManager$$ExternalSyntheticOutline0.m("com.android.dualdar.started.provisioning_success", "com.android.dualdar.started.cancelled", "com.android.dualdar.started.error"), 2);
            synchronized (obj) {
                try {
                    try {
                        Log.d("DualDarProvisioningHelper", "Starting Knox DUAL DAR DualDar Started Service");
                        Intent intent = new Intent();
                        intent.setComponent(new ComponentName("com.samsung.android.knox.containercore", "com.samsung.android.knox.containercore.provisioning.DualDarStartedService"));
                        intent.putExtra("android.intent.extra.user_handle", UserHandle.myUserId());
                        intent.putExtra("DUAL_DAR_PARAMS", DualDarProvisioningHelper.getDualDARConfigParams(dualDarProvisioningHelper.mContext, fullyManagedDeviceProvisioningParams.getAdminExtras()));
                        intent.putExtra("DualDARServiceEventFlag", 500);
                        intent.putExtra("DUAL_DAR_ADMIN_PACKAGE", fullyManagedDeviceProvisioningParams.getDeviceAdminComponentName().getPackageName());
                        intent.putExtra("DUAL_DAR_INTENT_PROVISIONING", DualDarProvisioningHelper.isDualDARIntentProvisioned(fullyManagedDeviceProvisioningParams.getAdminExtras()));
                        intent.putExtra("DUAL_DAR_IS_MANAGED_DEVICE", true);
                        if (DualDarProvisioningHelper.isDualDARNativeCrypto(dualDarProvisioningHelper.mContext, fullyManagedDeviceProvisioningParams.getAdminExtras())) {
                            i = 33554432;
                            intent.putExtra("DUAL_DAR_CRYPTO_TYPE", 33554432);
                        } else {
                            i = 67108864;
                            intent.putExtra("DUAL_DAR_CRYPTO_TYPE", 67108864);
                        }
                        if (dualDarProvisioningHelper.mUserManagerInternal.setDualDarInfo(0, i)) {
                            dualDarProvisioningHelper.startProvisionService(intent);
                            while (!zArr[0]) {
                                obj.wait();
                            }
                        } else {
                            Log.e("DualDarProvisioningHelper", "Failed to set dualdar crypto type to UserInfo");
                            zArr2[0] = false;
                            iArr[0] = intent.getIntExtra("ERROR_CODE", 5);
                        }
                    } catch (Exception e) {
                        Log.d("DualDarProvisioningHelper", "Error during onProvisionFullyManagedDeviceStarted" + e);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (zArr2[0]) {
                return;
            }
            throw new ServiceSpecificException(1, "onProvisionFullyManagedDeviceStarted failed with result: " + iArr[0]);
        }
    }

    /* JADX WARN: Multi-variable type inference failed */
    public final void onShellCommand(FileDescriptor fileDescriptor, FileDescriptor fileDescriptor2, FileDescriptor fileDescriptor3, String[] strArr, ShellCallback shellCallback, ResultReceiver resultReceiver) {
        new DevicePolicyManagerServiceShellCommand(this).exec(this, fileDescriptor, fileDescriptor2, fileDescriptor3, strArr, shellCallback, resultReceiver);
    }

    public final boolean packageHasActiveAdmins(String str, int i) {
        if (!this.mHasFeature) {
            return false;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userData = getUserData(i);
                int size = userData.mAdminList.size();
                for (int i2 = 0; i2 < size; i2++) {
                    if (((ActiveAdmin) userData.mAdminList.get(i2)).info.getPackageName().equals(str)) {
                        return true;
                    }
                }
                return false;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void prepareTransfer(ComponentName componentName, String str, ComponentName componentName2, PersistableBundle persistableBundle, int i) {
        saveTransferOwnershipBundleLocked(persistableBundle, i);
        TransferOwnershipMetadataManager transferOwnershipMetadataManager = this.mTransferOwnershipMetadataManager;
        Objects.requireNonNull(componentName);
        Objects.requireNonNull(componentName2);
        Preconditions.checkStringNotEmpty(str);
        transferOwnershipMetadataManager.getClass();
        transferOwnershipMetadataManager.mInjector.getClass();
        File file = new File(Environment.getDataSystemDirectory(), "owner-transfer-metadata.xml");
        AtomicFile atomicFile = new AtomicFile(file);
        FileOutputStream fileOutputStream = null;
        try {
            FileOutputStream startWrite = atomicFile.startWrite();
            try {
                TypedXmlSerializer resolveSerializer = Xml.resolveSerializer(startWrite);
                resolveSerializer.startDocument((String) null, Boolean.TRUE);
                String num = Integer.toString(i);
                resolveSerializer.startTag((String) null, "user-id");
                resolveSerializer.text(num);
                resolveSerializer.endTag((String) null, "user-id");
                String flattenToString = componentName.flattenToString();
                resolveSerializer.startTag((String) null, "source-component");
                resolveSerializer.text(flattenToString);
                resolveSerializer.endTag((String) null, "source-component");
                String flattenToString2 = componentName2.flattenToString();
                resolveSerializer.startTag((String) null, "target-component");
                resolveSerializer.text(flattenToString2);
                resolveSerializer.endTag((String) null, "target-component");
                resolveSerializer.startTag((String) null, "admin-type");
                resolveSerializer.text(str);
                resolveSerializer.endTag((String) null, "admin-type");
                resolveSerializer.endDocument();
                atomicFile.finishWrite(startWrite);
            } catch (IOException e) {
                e = e;
                fileOutputStream = startWrite;
                Slog.e("com.android.server.devicepolicy.TransferOwnershipMetadataManager", "Caught exception while trying to save Owner Transfer Params to file " + file, e);
                file.delete();
                atomicFile.failWrite(fileOutputStream);
            }
        } catch (IOException e2) {
            e = e2;
        }
    }

    /* JADX WARN: Code restructure failed: missing block: B:15:0x0074, code lost:
    
        if (getHeadlessDeviceOwnerModeForDeviceAdmin(android.os.UserHandle.getUserId(r6), r4) == 2) goto L17;
     */
    /* JADX WARN: Removed duplicated region for block: B:48:0x017d A[Catch: all -> 0x007a, Exception -> 0x007d, TryCatch #1 {Exception -> 0x007d, blocks: (B:11:0x0063, B:14:0x006c, B:17:0x0087, B:19:0x008d, B:22:0x009a, B:25:0x00b1, B:26:0x00b8, B:28:0x00b9, B:30:0x00c7, B:32:0x00db, B:39:0x00ec, B:40:0x00f3, B:43:0x00fb, B:45:0x0106, B:46:0x010e, B:51:0x0118, B:52:0x0130, B:54:0x013a, B:60:0x0155, B:56:0x0174, B:57:0x017c, B:65:0x0152, B:48:0x017d, B:49:0x0185, B:69:0x012d, B:71:0x0186, B:72:0x0198, B:74:0x0080), top: B:10:0x0063, outer: #3 }] */
    /* JADX WARN: Removed duplicated region for block: B:50:0x0118 A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void provisionFullyManagedDevice(android.app.admin.FullyManagedDeviceProvisioningParams r17, java.lang.String r18) {
        /*
            Method dump skipped, instructions count: 435
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.provisionFullyManagedDevice(android.app.admin.FullyManagedDeviceProvisioningParams, java.lang.String):void");
    }

    public final void pushMeteredDisabledPackages(int i) {
        wtfIfInLock();
        this.mInjector.getClass();
        NetworkPolicyManagerService.NetworkPolicyManagerInternalImpl networkPolicyManagerInternalImpl = (NetworkPolicyManagerService.NetworkPolicyManagerInternalImpl) LocalServices.getService(NetworkPolicyManagerService.NetworkPolicyManagerInternalImpl.class);
        NetworkPolicyManagerService.m687$$Nest$msetMeteredRestrictedPackagesInternal(NetworkPolicyManagerService.this, getMeteredDisabledPackages(i), i);
    }

    public final void reboot(ComponentName componentName) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
        checkCanExecuteOrThrowUnsafe(7);
        Bundle bundle = new Bundle();
        bundle.putInt("userId", UserHandle.getUserId(callerIdentity.mUid));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda51 devicePolicyManagerService$$ExternalSyntheticLambda51 = new DevicePolicyManagerService$$ExternalSyntheticLambda51(this, componentName, bundle);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda51);
    }

    public final void recordSecurityLogRetrievalTime() {
        synchronized (getLockObject()) {
            try {
                long currentTimeMillis = System.currentTimeMillis();
                DevicePolicyData userData = getUserData(0);
                if (currentTimeMillis > userData.mLastSecurityLogRetrievalTime) {
                    userData.mLastSecurityLogRetrievalTime = currentTimeMillis;
                    saveSettingsLocked(0, false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void removeActiveAdmin(ComponentName componentName, int i) {
        if (this.mHasFeature) {
            Preconditions.checkArgumentNonnegative(i, "Invalid userId");
            Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(hasCallingOrSelfPermission("android.permission.MANAGE_DEVICE_ADMINS") ? getCallerIdentity(null, null) : getCallerIdentity(componentName), i));
            checkCanExecuteOrThrowUnsafe(27);
            enforceUserUnlocked(i);
            this.mInjector.getClass();
            if (!this.mKnoxPolicyHelper.isAdminRemovableInternal(componentName, i)) {
                Log.d("DevicePolicyManager", "removeActiveAdmin() has failed because this admin doesn't allow to remove - " + componentName + ", userId = " + i);
                return;
            }
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    if (activeAdminUncheckedLocked == null) {
                        return;
                    }
                    if (!isDeviceOwner(i, componentName) && !isProfileOwner(i, componentName)) {
                        Injector injector = this.mInjector;
                        DevicePolicyManagerService$$ExternalSyntheticLambda30 devicePolicyManagerService$$ExternalSyntheticLambda30 = new DevicePolicyManagerService$$ExternalSyntheticLambda30(this, componentName, i, 2);
                        injector.getClass();
                        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda30);
                        this.mDevicePolicyEngine.removePoliciesForAdmin(EnforcingAdmin.createEnterpriseEnforcingAdmin(componentName, i, activeAdminUncheckedLocked));
                        return;
                    }
                    Slogf.e("DevicePolicyManager", "Device/profile owner cannot be removed: component=" + componentName);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r4v0, types: [com.android.server.devicepolicy.DevicePolicyManagerService$4] */
    public final void removeActiveAdminLocked(final int i, final ComponentName componentName) {
        ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
        DevicePolicyData userData = getUserData(i);
        if (activeAdminUncheckedLocked == null || userData.mRemovingAdmins.contains(componentName)) {
            return;
        }
        Slogf.d("DevicePolicyManager", "Adding " + componentName + " for user " + i + " to list of removing admins.");
        logStackTrace("removeActiveAdminLocked");
        userData.mRemovingAdmins.add(componentName);
        sendAdminCommandLocked(activeAdminUncheckedLocked, "android.app.action.DEVICE_ADMIN_DISABLED", null, new BroadcastReceiver() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService.4
            @Override // android.content.BroadcastReceiver
            public final void onReceive(Context context, Intent intent) {
                this.removeAdminArtifacts(i, componentName);
                DevicePolicyManagerService devicePolicyManagerService = this;
                String packageName = componentName.getPackageName();
                int i2 = i;
                if (!devicePolicyManagerService.packageHasActiveAdmins(packageName, i2)) {
                    devicePolicyManagerService.startUninstallIntent(i2, packageName);
                }
                this.mInjector.getClass();
                KnoxPolicyHelper knoxPolicyHelper = this.mKnoxPolicyHelper;
                ComponentName componentName2 = componentName;
                int i3 = i;
                if (knoxPolicyHelper.getIEDMService() == null) {
                    Log.i("KnoxPolicyHelper", "removeActiveAdminLocked() : passed EDMS.removeActiveAdminFromDpm() because edms is null");
                    return;
                }
                try {
                    knoxPolicyHelper.mEdmService.removeActiveAdminFromDpm(componentName2, i3);
                } catch (RemoteException e) {
                    Slogf.e("KnoxPolicyHelper", "failed to remove active admin from edm database " + e.getMessage());
                }
            }
        }, false);
    }

    public final void removeAdminArtifacts(int i, ComponentName componentName) {
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                if (activeAdminUncheckedLocked == null) {
                    return;
                }
                this.mInjector.getClass();
                KnoxPolicyHelper knoxPolicyHelper = this.mKnoxPolicyHelper;
                int uid = activeAdminUncheckedLocked.getUid();
                knoxPolicyHelper.getClass();
                long clearCallingIdentity = Binder.clearCallingIdentity();
                if (knoxPolicyHelper.mWifiService == null) {
                    knoxPolicyHelper.mWifiService = IWifiPolicy.Stub.asInterface(ServiceManager.getService("wifi_policy"));
                }
                IWifiPolicy iWifiPolicy = knoxPolicyHelper.mWifiService;
                if (iWifiPolicy != null) {
                    try {
                        try {
                            iWifiPolicy.resetAutomaticConnectionPolicy(uid);
                        } finally {
                        }
                    } catch (RemoteException e) {
                        Log.e("KnoxPolicyHelper", "Failed talking to Device Policy Manager service", e);
                    }
                }
                DevicePolicyData userData = getUserData(i);
                boolean usesPolicy = activeAdminUncheckedLocked.info.usesPolicy(5);
                userData.mAdminList.remove(activeAdminUncheckedLocked);
                userData.mAdminMap.remove(componentName);
                userData.validatePasswordOwner();
                if (usesPolicy) {
                    resetGlobalProxyLocked(userData);
                }
                int i2 = activeAdminUncheckedLocked.allowBluetoothMode;
                boolean z = activeAdminUncheckedLocked.allowWifi;
                boolean z2 = activeAdminUncheckedLocked.allowStorageCard;
                boolean z3 = activeAdminUncheckedLocked.allowInternetSharing;
                boolean z4 = activeAdminUncheckedLocked.allowDesktopSync;
                boolean z5 = i2 != semGetAllowBluetoothMode(null, i);
                boolean z6 = z != semGetAllowWifi(null, i);
                boolean z7 = z5 || z6 || (z2 != semGetAllowStorageCard(null, i)) || (z3 != semGetAllowInternetSharing(null, i)) || (z4 != semGetAllowDesktopSync(null, i));
                UsageStatsService.this.mAppStandby.setActiveAdminApps(getActiveAdminPackagesLocked(i), i);
                saveSettingsLocked(i, z5, z6, z7);
                updateMaximumTimeToLockLocked(i);
                Slogf.d("DevicePolicyManager", "Removing device admin " + componentName + " from user " + i);
                logStackTrace("removeAdminArtifacts");
                userData.mRemovingAdmins.remove(componentName);
                Slogf.d("DevicePolicyManager", "Current state of DevicePolicyData#mRemovingAdmins for user " + i + ": " + userData.mRemovingAdmins);
                Slogf.i("DevicePolicyManager", "Device admin " + componentName + " removed from user " + i);
                this.mInjector.getClass();
                AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                Object[] objArr = {componentName.getPackageName()};
                auditLogHelper.getClass();
                clearCallingIdentity = Binder.clearCallingIdentity();
                try {
                    AuditLog.logEventAsUser(i, 4, objArr);
                    pushMeteredDisabledPackages(i);
                } finally {
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final Set removeCaApprovalsIfNeeded(int i) {
        ArraySet arraySet = new ArraySet();
        for (UserInfo userInfo : this.mUserManager.getProfiles(i)) {
            boolean isSecure = this.mLockPatternUtils.isSecure(userInfo.id);
            if (userInfo.isManagedProfile()) {
                isSecure |= this.mLockPatternUtils.isSecure(getProfileParentId(userInfo.id));
            }
            if (!isSecure) {
                synchronized (getLockObject()) {
                    getUserData(userInfo.id).mAcceptedCaCertificates.clear();
                    arraySet.add(Integer.valueOf(userInfo.id));
                }
                CertificateMonitor certificateMonitor = this.mCertificateMonitor;
                certificateMonitor.getClass();
                certificateMonitor.mHandler.post(new CertificateMonitor$$ExternalSyntheticLambda0(certificateMonitor, i));
            }
        }
        return arraySet;
    }

    public final boolean removeCrossProfileWidgetProvider(ComponentName componentName, String str, String str2) {
        ActiveAdmin profileOwnerLocked;
        ActiveAdmin activeAdmin;
        ArrayList arrayList;
        CallerIdentity callerIdentity = isPermissionCheckFlagEnabled() ? getCallerIdentity(componentName, str) : getCallerIdentity(componentName);
        if (isPermissionCheckFlagEnabled()) {
            activeAdmin = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION", callerIdentity.mPackageName).mActiveAdmin;
        } else {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
            }
            activeAdmin = profileOwnerLocked;
        }
        synchronized (getLockObject()) {
            try {
                List list = activeAdmin.crossProfileWidgetProviders;
                if (list != null && !((ArrayList) list).isEmpty()) {
                    ArrayList arrayList2 = (ArrayList) activeAdmin.crossProfileWidgetProviders;
                    if (arrayList2.remove(str2)) {
                        arrayList = new ArrayList(arrayList2);
                        saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    } else {
                        arrayList = null;
                    }
                    DevicePolicyEventLogger.createEvent(117).setAdmin(callerIdentity.mPackageName).write();
                    if (arrayList == null) {
                        return false;
                    }
                    LocalService.m425$$Nest$mnotifyCrossProfileProvidersChanged(this.mLocalService, UserHandle.getUserId(callerIdentity.mUid), arrayList);
                    return true;
                }
                return false;
            } finally {
            }
        }
    }

    public final boolean removeKeyPair(ComponentName componentName, String str, String str2) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        boolean isCallerDelegate = isCallerDelegate(callerIdentity, "delegation-cert-install");
        boolean isCredentialManagementApp = isCredentialManagementApp(callerIdentity);
        boolean isPermissionCheckFlagEnabled = isPermissionCheckFlagEnabled();
        boolean z = true;
        String str3 = callerIdentity.mPackageName;
        int i = callerIdentity.mUid;
        if (isPermissionCheckFlagEnabled) {
            if (!hasPermission("android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES", str3, UserHandle.getUserId(i)) && !isCredentialManagementApp) {
                z = false;
            }
            Preconditions.checkCallAuthorization(z);
        } else {
            if ((!callerIdentity.hasAdminComponent() || (!isProfileOwner(callerIdentity) && !isDefaultDeviceOwner(callerIdentity))) && (!callerIdentity.hasPackage() || (!isCallerDelegate && !isCredentialManagementApp))) {
                z = false;
            }
            Preconditions.checkCallAuthorization(z);
        }
        if (isCredentialManagementApp) {
            Preconditions.checkCallAuthorization(isAliasInCredentialManagementAppPolicy(callerIdentity, str2), "The alias provided must be contained in the aliases specified in the credential management app's authentication policy");
        }
        checkCanExecuteOrThrowUnsafe(28);
        Bundle bundle = new Bundle();
        bundle.putInt("userId", UserHandle.getUserId(i));
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                try {
                    KeyChain.KeyChainConnection bindAsUser = KeyChain.bindAsUser(this.mContext, UserHandle.getUserHandleForUid(i));
                    try {
                        IKeyChainService service = bindAsUser.getService();
                        DevicePolicyEventLogger.createEvent(23).setAdmin(str3).setBoolean(isCallerDelegate).setStrings(new String[]{isCredentialManagementApp ? "credentialManagementApp" : "notCredentialManagementApp"}).setKnoxBundleValue(bundle).write();
                        boolean removeKeyPair = service.removeKeyPair(str2);
                        bindAsUser.close();
                        return removeKeyPair;
                    } catch (Throwable th) {
                        if (bindAsUser != null) {
                            try {
                                bindAsUser.close();
                            } catch (Throwable th2) {
                                th.addSuppressed(th2);
                            }
                        }
                        throw th;
                    }
                } catch (RemoteException | AssertionError e) {
                    Slogf.e("DevicePolicyManager", "Removing keypair", e);
                    return false;
                }
            } finally {
                Binder.restoreCallingIdentity(clearCallingIdentity);
            }
        } catch (InterruptedException e2) {
            Slogf.w("DevicePolicyManager", "Interrupted while removing keypair", e2);
            Thread.currentThread().interrupt();
        }
    }

    public final boolean removeNonRequiredAppsForManagedDevice(int i, ComponentName componentName, boolean z) {
        Set<String> emptySet = z ? Collections.emptySet() : this.mOverlayPackagesProvider.getNonRequiredApps(componentName, i, "android.app.action.PROVISION_MANAGED_DEVICE");
        HashSet hashSet = new HashSet();
        for (String str : emptySet) {
            if (!isPackageInstalledForUser(i, str)) {
                hashSet.add(str);
            }
        }
        emptySet.removeAll(hashSet);
        if (emptySet.isEmpty()) {
            Slogf.i("DevicePolicyManager", "No packages to delete on user " + i);
            return true;
        }
        Injector injector = this.mInjector;
        Context context = this.mContext;
        injector.getClass();
        if (DualDarManager.isOnDeviceOwnerEnabled()) {
            HashSet hashSet2 = new HashSet();
            String clientPackage = DualDarManager.getInstance(context).getClientPackage(i);
            if (clientPackage != null) {
                DualAppManagerService$$ExternalSyntheticOutline0.m("DualDar client pkg ", clientPackage, " should not be deleted during Managed Device Provisioning", "DevicePolicyManager::KnoxUtils");
                hashSet2.add(clientPackage);
                emptySet.removeAll(hashSet2);
            }
        }
        try {
            this.mInjector.getClass();
            SystemProperties.set("persist.sys.knox.non_required_apps_task", "true");
        } catch (Exception e) {
            e.printStackTrace();
        }
        IPackageDeleteObserver nonRequiredPackageDeleteObserver = new NonRequiredPackageDeleteObserver(emptySet.size());
        for (String str2 : emptySet) {
            Slogf.i("DevicePolicyManager", "Deleting package [" + str2 + "] as user " + i);
            this.mContext.getPackageManager().deletePackageAsUser(str2, nonRequiredPackageDeleteObserver, 4, i);
        }
        Slogf.i("DevicePolicyManager", "Waiting for non required apps to be deleted");
        try {
            if (!nonRequiredPackageDeleteObserver.mLatch.await(30L, TimeUnit.SECONDS)) {
                Slog.i("DevicePolicyManager", "Waiting time elapsed before all package deletion finished");
                return false;
            }
            if (!nonRequiredPackageDeleteObserver.mFailed) {
                Slog.i("DevicePolicyManager", "All non-required system apps with launcher icon, and all disallowed apps have been uninstalled.");
            }
            return !nonRequiredPackageDeleteObserver.mFailed;
        } catch (InterruptedException e2) {
            Log.w("DevicePolicyManager", "Interrupted while waiting for package deletion", e2);
            Thread.currentThread().interrupt();
            return false;
        }
    }

    public final boolean removeOverrideApn(ComponentName componentName, int i) {
        if (!this.mHasFeature || (!this.mHasTelephonyFeature && !this.mHasTelephonyDataFeature)) {
            return false;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        ApnSetting apnSetting = getApnSetting(i);
        if (apnSetting == null || apnSetting.getApnTypeBitmask() != 16384) {
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
        } else {
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isManagedProfileOwner(callerIdentity));
        }
        return removeOverrideApnUnchecked(i);
    }

    public final boolean removeOverrideApnUnchecked(int i) {
        if (i < 0) {
            return false;
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, i, 4);
        injector.getClass();
        return ((Integer) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6)).intValue() > 0;
    }

    public final boolean removeUser(ComponentName componentName, UserHandle userHandle) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        Objects.requireNonNull(userHandle, "UserHandle is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
        checkCanExecuteOrThrowUnsafe(6);
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda47 devicePolicyManagerService$$ExternalSyntheticLambda47 = new DevicePolicyManagerService$$ExternalSyntheticLambda47(this, userHandle, componentName, callerIdentity);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda47)).booleanValue();
    }

    public final void removeUserData(int i) {
        synchronized (getLockObject()) {
            try {
                if (i == 0) {
                    Slogf.w("DevicePolicyManager", "Tried to remove device policy file for user 0! Ignoring.");
                    return;
                }
                updatePasswordQualityCacheForUserGroup(i);
                this.mPolicyCache.onUserRemoved(i);
                if (isManagedProfile(i)) {
                    clearManagedProfileApnUnchecked();
                }
                boolean isProfileOwnerOfOrganizationOwnedDevice = this.mOwners.isProfileOwnerOfOrganizationOwnedDevice(i);
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(i);
                if (profileOwnerLocked != null) {
                    profileOwnerLocked.userRestrictions = null;
                    ActiveAdmin parentActiveAdmin = profileOwnerLocked.getParentActiveAdmin();
                    if (parentActiveAdmin != null) {
                        parentActiveAdmin.userRestrictions = null;
                    }
                }
                this.mOwners.removeProfileOwner(i);
                this.mOwners.writeProfileOwner(i);
                DevicePolicyData devicePolicyData = (DevicePolicyData) this.mUserData.get(i);
                if (devicePolicyData != null) {
                    this.mInjector.getClass();
                    this.mKnoxPolicyHelper.removeActiveAdminFromDpm(devicePolicyData.mAdminList, i);
                    this.mUserData.remove(i);
                }
                this.mPathProvider.getClass();
                File file = new File(Environment.getUserSystemDirectory(i), "device_policies.xml");
                file.delete();
                Slogf.i("DevicePolicyManager", "Removed device policy file " + file.getAbsolutePath());
                if (isProfileOwnerOfOrganizationOwnedDevice) {
                    UserInfo primaryUser = this.mUserManager.getPrimaryUser();
                    if (primaryUser != null) {
                        clearOrgOwnedProfileOwnerDeviceWidePolicies(primaryUser.id);
                    } else {
                        Slogf.wtf("DevicePolicyManager", "Was unable to get primary user.");
                    }
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void reportFailedBiometricAttempt(int i) {
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.BIND_DEVICE_ADMIN"));
        this.mInjector.getClass();
        if (SecurityLog.isLoggingEnabled()) {
            SecurityLog.writeEvent(210007, new Object[]{0, 0});
        }
        this.mInjector.getClass();
        if (i == 0 || !isManagedProfile(i)) {
            return;
        }
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            synchronized (getLockObject()) {
                getUserData(i).mFailedBiometricAttempts++;
                saveSettingsLocked(i, false, false, false);
            }
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final void reportFailedPasswordAttempt(int i, boolean z) {
        boolean z2;
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        ActiveAdmin activeAdmin = null;
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.BIND_DEVICE_ADMIN"));
        if (!isSeparateProfileChallengeEnabled(i)) {
            Preconditions.checkCallAuthorization(!isManagedProfile(i), "You can not report failed password attempt if separate profile challenge is not in place for a managed profile, userId = %d", new Object[]{Integer.valueOf(i)});
        }
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            synchronized (getLockObject()) {
                try {
                    DevicePolicyData userData = getUserData(i);
                    this.mInjector.getClass();
                    int i2 = userData.mFailedPasswordAttemptsFromGateKeeper;
                    if (i2 > 0) {
                        userData.mFailedPasswordAttempts = i2;
                        userData.mFailedPasswordAttemptsFromGateKeeper = -i2;
                    } else {
                        userData.mFailedPasswordAttempts++;
                    }
                    saveSettingsLocked(i, false, false, false);
                    if (this.mHasFeature) {
                        activeAdmin = getAdminWithMinimumFailedPasswordsForWipeLocked(i, false);
                        int i3 = activeAdmin != null ? activeAdmin.maximumFailedPasswordsForWipe : 0;
                        z2 = i3 > 0 && userData.mFailedPasswordAttempts >= i3;
                        sendAdminCommandForLockscreenPoliciesLocked(1, i, "android.app.action.ACTION_PASSWORD_FAILED");
                    } else {
                        z2 = false;
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (z2 && activeAdmin != null) {
                int userIdToWipeForFailedPasswords = getUserIdToWipeForFailedPasswords(activeAdmin);
                Slogf.i("DevicePolicyManager", "Max failed password attempts policy reached for admin: " + activeAdmin.info.getComponent().flattenToShortString() + ". Calling wipeData for user " + userIdToWipeForFailedPasswords);
                try {
                    this.mInjector.getClass();
                    wipeDataNoLock(activeAdmin.info.getComponent(), 0, "reportFailedPasswordAttempt() by " + activeAdmin.info.getComponent().flattenToShortString(), getUpdatableString("Core.WORK_PROFILE_DELETED_FAILED_PASSWORD_ATTEMPTS_MESSAGE", 17043636, new Object[0]), userIdToWipeForFailedPasswords, z, null);
                } catch (SecurityException e) {
                    Slogf.w("DevicePolicyManager", "Failed to wipe user " + userIdToWipeForFailedPasswords + " after max failed password attempts reached.", e);
                }
            }
            this.mInjector.getClass();
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210007, new Object[]{0, 1});
            }
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final void reportFailedPasswordAttemptWithFailureCount(int i, int i2, boolean z) {
        Preconditions.checkArgumentNonnegative(i2, "Failure count must be non-negative.");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.BIND_DEVICE_ADMIN"));
        if (!isSeparateProfileChallengeEnabled(i)) {
            Preconditions.checkCallAuthorization(!isManagedProfile(i), "You can not report failed password attempt if separate profile challenge is not in place for a managed profile, userId = %d", new Object[]{Integer.valueOf(i)});
        }
        synchronized (getLockObject()) {
            getUserData(i).mFailedPasswordAttemptsFromGateKeeper = i2;
        }
        reportFailedPasswordAttempt(i, z);
    }

    public final void reportKeyguardDismissed(int i) {
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.BIND_DEVICE_ADMIN"));
        this.mInjector.getClass();
        if (SecurityLog.isLoggingEnabled()) {
            SecurityLog.writeEvent(210006, new Object[0]);
        }
    }

    public final void reportKeyguardSecured(int i) {
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.BIND_DEVICE_ADMIN"));
        this.mInjector.getClass();
        if (SecurityLog.isLoggingEnabled()) {
            SecurityLog.writeEvent(210008, new Object[0]);
        }
    }

    public final void reportPasswordChanged(PasswordMetrics passwordMetrics, int i) {
        if (this.mHasFeature && this.mLockPatternUtils.hasSecureLockScreen()) {
            Preconditions.checkCallAuthorization(isSystemUid(getCallerIdentity(null, null)));
            if (!isSeparateProfileChallengeEnabled(i)) {
                Preconditions.checkCallAuthorization(!isManagedProfile(i), "You can not set the active password for a managed profile, userId = %d", new Object[]{Integer.valueOf(i)});
            }
            DevicePolicyData userData = getUserData(i);
            ArraySet arraySet = new ArraySet();
            synchronized (getLockObject()) {
                try {
                    userData.mFailedPasswordAttempts = 0;
                    userData.mFailedPasswordAttemptsFromGateKeeper = 0;
                    this.mInjector.getClass();
                    if (i != 0 && isManagedProfile(i)) {
                        userData.mFailedBiometricAttempts = 0;
                    }
                    arraySet.add(Integer.valueOf(i));
                    arraySet.addAll(updatePasswordValidityCheckpointLocked(i, false));
                    arraySet.addAll(updatePasswordExpirationsLocked(i));
                    setExpirationAlarmCheckLocked(this.mContext, i, false);
                    sendAdminCommandForLockscreenPoliciesLocked(0, i, "android.app.action.ACTION_PASSWORD_CHANGED");
                    arraySet.addAll(removeCaApprovalsIfNeeded(i));
                    Iterator it = arraySet.iterator();
                    while (it.hasNext()) {
                        saveSettingsLocked(((Integer) it.next()).intValue(), false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            this.mInjector.getClass();
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210036, new Object[]{Integer.valueOf(passwordMetrics.determineComplexity()), Integer.valueOf(i)});
            }
        }
    }

    public final void reportSuccessfulBiometricAttempt(int i) {
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.BIND_DEVICE_ADMIN"));
        this.mInjector.getClass();
        if (SecurityLog.isLoggingEnabled()) {
            SecurityLog.writeEvent(210007, new Object[]{1, 0});
        }
        this.mInjector.getClass();
        if (i == 0 || !isManagedProfile(i)) {
            return;
        }
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userData = getUserData(i);
                if (userData.mFailedBiometricAttempts != 0) {
                    Injector injector = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda28 devicePolicyManagerService$$ExternalSyntheticLambda28 = new DevicePolicyManagerService$$ExternalSyntheticLambda28(this, userData, i, 2);
                    injector.getClass();
                    Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda28);
                }
            } finally {
            }
        }
    }

    public final void reportSuccessfulPasswordAttempt(int i) {
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.BIND_DEVICE_ADMIN"));
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userData = getUserData(i);
                if (userData.mFailedPasswordAttempts == 0 && userData.mPasswordOwner < 0) {
                    this.mInjector.getClass();
                    if (userData.mFailedBiometricAttempts != 0) {
                    }
                }
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda28 devicePolicyManagerService$$ExternalSyntheticLambda28 = new DevicePolicyManagerService$$ExternalSyntheticLambda28(this, userData, i, 0);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda28);
            } catch (Throwable th) {
                throw th;
            }
        }
        this.mInjector.getClass();
        if (SecurityLog.isLoggingEnabled()) {
            SecurityLog.writeEvent(210007, new Object[]{1, 1});
        }
    }

    public final boolean requestBugreport(ComponentName componentName) {
        long nextLong;
        if (!this.mHasFeature) {
            return false;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        Preconditions.checkCallAuthorization(areAllUsersAffiliatedWithDeviceLocked(), "operation not allowed when device has unaffiliated users");
        checkCanExecuteOrThrowUnsafe(29);
        RemoteBugreportManager remoteBugreportManager = this.mBugreportCollectionManager;
        if (!remoteBugreportManager.mRemoteBugreportServiceIsActive.get() && remoteBugreportManager.mService.getDeviceOwnerRemoteBugreportUriAndHash() == null) {
            remoteBugreportManager.mInjector.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            do {
                try {
                    try {
                        nextLong = remoteBugreportManager.mRng.nextLong();
                    } catch (RemoteException e) {
                        Slogf.e("DevicePolicyManager", "Failed to make remote calls to start bugreportremote service", e);
                        Binder.restoreCallingIdentity(clearCallingIdentity);
                    }
                } catch (Throwable th) {
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    throw th;
                }
            } while (nextLong == 0);
            ActivityManager.getService().requestRemoteBugReport(nextLong);
            remoteBugreportManager.mRemoteBugreportNonce.set(nextLong);
            remoteBugreportManager.mRemoteBugreportServiceIsActive.set(true);
            remoteBugreportManager.mRemoteBugreportSharingAccepted.set(false);
            remoteBugreportManager.registerRemoteBugreportReceivers();
            remoteBugreportManager.notify(1);
            remoteBugreportManager.mHandler.postDelayed(remoteBugreportManager.mRemoteBugreportTimeoutRunnable, 600000L);
            Binder.restoreCallingIdentity(clearCallingIdentity);
            DevicePolicyEventLogger.createEvent(53).setAdmin(componentName).write();
            long currentTimeMillis = System.currentTimeMillis();
            synchronized (getLockObject()) {
                try {
                    DevicePolicyData userData = getUserData(0);
                    if (currentTimeMillis > userData.mLastBugReportRequestTime) {
                        userData.mLastBugReportRequestTime = currentTimeMillis;
                        saveSettingsLocked(0, false, false, false);
                    }
                } catch (Throwable th2) {
                    throw th2;
                }
            }
            return true;
        }
        Slogf.d("DevicePolicyManager", "Remote bugreport wasn't started because there's already one running");
        return false;
    }

    public final void resetDefaultCrossProfileIntentFilters(int i) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda29 devicePolicyManagerService$$ExternalSyntheticLambda29 = new DevicePolicyManagerService$$ExternalSyntheticLambda29(i, 5, this);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda29);
    }

    public final void resetDrawables(List list) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES"));
        Objects.requireNonNull(list, "drawableIds must be provided.");
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda25 devicePolicyManagerService$$ExternalSyntheticLambda25 = new DevicePolicyManagerService$$ExternalSyntheticLambda25(this, list, 0);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda25);
    }

    public final void resetGlobalProxyLocked(DevicePolicyData devicePolicyData) {
        int size = devicePolicyData.mAdminList.size();
        for (int i = 0; i < size; i++) {
            ActiveAdmin activeAdmin = (ActiveAdmin) devicePolicyData.mAdminList.get(i);
            if (activeAdmin.specifiesGlobalProxy) {
                saveGlobalProxyLocked(activeAdmin.globalProxySpec, activeAdmin.globalProxyExclusionList);
                return;
            }
        }
        saveGlobalProxyLocked(null, null);
    }

    public final void resetInactivePasswordRequirementsIfRPlus(int i, ActiveAdmin activeAdmin) {
        String packageName = activeAdmin.info.getPackageName();
        this.mInjector.getClass();
        if (Injector.isChangeEnabled(i, packageName, 123562444L)) {
            PasswordPolicy passwordPolicy = activeAdmin.mPasswordPolicy;
            int i2 = passwordPolicy.quality;
            if (i2 < 131072) {
                passwordPolicy.length = 0;
            }
            if (i2 < 393216) {
                passwordPolicy.letters = 1;
                passwordPolicy.upperCase = 0;
                passwordPolicy.lowerCase = 0;
                passwordPolicy.numeric = 1;
                passwordPolicy.symbols = 1;
                passwordPolicy.nonLetter = 0;
            }
        }
    }

    public final void resetInteractAcrossProfilesAppOps(int i) {
        this.mInjector.getCrossProfileApps(i).clearInteractAcrossProfilesAppOps();
        String permissionToOp = AppOpsManager.permissionToOp("android.permission.INTERACT_ACROSS_PROFILES");
        Stream stream = getDefaultCrossProfilePackages().stream();
        CrossProfileApps crossProfileApps = this.mInjector.getCrossProfileApps(i);
        Objects.requireNonNull(crossProfileApps);
        for (String str : (Set) stream.filter(new DevicePolicyManagerService$$ExternalSyntheticLambda118(1, crossProfileApps)).collect(Collectors.toSet())) {
            try {
                int unsafeCheckOpNoThrow = this.mInjector.getAppOpsManager().unsafeCheckOpNoThrow(permissionToOp, this.mContext.createContextAsUser(UserHandle.of(i), 0).getPackageManager().getPackageUid(str, 0), str);
                if (unsafeCheckOpNoThrow == 0 || unsafeCheckOpNoThrow == 3) {
                    this.mInjector.getCrossProfileApps(i).setInteractAcrossProfilesAppOp(str, 0);
                }
            } catch (PackageManager.NameNotFoundException unused) {
            }
        }
    }

    public final boolean resetPassword(String str, int i) {
        if (!this.mLockPatternUtils.hasSecureLockScreen()) {
            Slogf.w("DevicePolicyManager", "Cannot reset password when the device has no lock screen");
            return false;
        }
        if (str == null) {
            str = "";
        }
        String str2 = str;
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        if (hasCallingPermission("android.permission.RESET_PASSWORD")) {
            int userId2 = UserHandle.getUserId(callerIdentity.mUid);
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, userId2, 11);
            injector.getClass();
            if (((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6)).booleanValue()) {
                throw new SecurityException("Cannot change current password");
            }
            boolean resetPasswordInternal = resetPasswordInternal(str2, 0L, null, i, callerIdentity, UserHandle.getUserId(callerIdentity.mUid));
            if (resetPasswordInternal) {
                DevicePolicyEventLogger.createEvent(205).write();
            }
            return resetPasswordInternal;
        }
        if (isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity)) {
            synchronized (getLockObject()) {
                try {
                    if (getTargetSdk(userId, getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).info.getPackageName()) >= 26) {
                        throw new SecurityException("Device admin can no longer call resetPassword()");
                    }
                    Slogf.e("DevicePolicyManager", "DPC can no longer call resetPassword()");
                } finally {
                }
            }
            return false;
        }
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(null, null, 2, false);
                Preconditions.checkCallAuthorization(activeAdminOrCheckPermissionForCallerLocked != null, "Unauthorized caller cannot call resetPassword.");
                if (getTargetSdk(userId, activeAdminOrCheckPermissionForCallerLocked.info.getPackageName()) > 23) {
                    throw new SecurityException("Device admin can no longer call resetPassword()");
                }
                Slogf.e("DevicePolicyManager", "Device admin can no longer call resetPassword()");
            } finally {
            }
        }
        return false;
    }

    public final boolean resetPasswordInternal(String str, long j, byte[] bArr, int i, CallerIdentity callerIdentity, int i2) {
        PasswordMetrics passwordMinimumMetricsUnchecked;
        int aggregatedPasswordComplexityLocked;
        PowerManager.WakeLock wakeLock;
        boolean z;
        PowerManager.WakeLock newWakeLock;
        boolean z2;
        int i3 = callerIdentity.mUid;
        LockscreenCredential createPin = PasswordMetrics.isNumericOnly(str) ? LockscreenCredential.createPin(str) : LockscreenCredential.createPasswordOrNone(str);
        synchronized (getLockObject()) {
            try {
                passwordMinimumMetricsUnchecked = getPasswordMinimumMetricsUnchecked(i2, false);
                aggregatedPasswordComplexityLocked = getAggregatedPasswordComplexityLocked(i2, false);
                wakeLock = null;
            } catch (SecurityException e) {
                Log.d("DevicePolicyManager::KnoxUtils", "SecurityException : " + e);
            } finally {
            }
            if (createPin.isNone()) {
                this.mInjector.getClass();
                Context context = this.mContext;
                if (i2 == 0) {
                    z2 = EnterpriseDeviceManager.getInstance(context).getPasswordPolicy().isMultifactorAuthenticationEnabled();
                } else {
                    EnterpriseKnoxManager enterpriseKnoxManager = EnterpriseKnoxManager.getInstance();
                    KnoxContainerManager knoxContainerManager = enterpriseKnoxManager != null ? enterpriseKnoxManager.getKnoxContainerManager(context, i2) : null;
                    if (knoxContainerManager != null) {
                        z2 = knoxContainerManager.getPasswordPolicy().isMultifactorAuthenticationEnabled();
                    }
                    z2 = false;
                }
                if (z2) {
                    Log.w("DevicePolicyManager", "Failed to reset password due to constraint violation: password null does not meet multi-factor auth enforced");
                    return false;
                }
                this.mInjector.getClass();
                this.mInjector.getClass();
                this.mInjector.getClass();
                if (DualDarManager.isOnDeviceOwnerEnabled()) {
                    Log.w("DevicePolicyManager", "Failed to reset password due to constraint violation: password null does not meet DualDAR on Device Owner Enabled");
                    return false;
                }
            }
            List validateCredential = PasswordMetrics.validateCredential(passwordMinimumMetricsUnchecked, aggregatedPasswordComplexityLocked, createPin);
            if (!validateCredential.isEmpty()) {
                Slogf.w("DevicePolicyManager", "Failed to reset password due to constraint violation: %s", validateCredential.get(0));
                return false;
            }
            DevicePolicyData userData = getUserData(i2);
            int i4 = userData.mPasswordOwner;
            if (i4 >= 0 && i4 != i3) {
                Slogf.w("DevicePolicyManager", "resetPassword: already set by another uid and not entered by user");
                return false;
            }
            boolean isDefaultDeviceOwner = isDefaultDeviceOwner(callerIdentity);
            boolean z3 = (i & 2) != 0;
            if (isDefaultDeviceOwner && z3) {
                synchronized (getLockObject()) {
                    try {
                        DevicePolicyData userData2 = getUserData(0);
                        if (!userData2.mDoNotAskCredentialsOnBoot) {
                            userData2.mDoNotAskCredentialsOnBoot = true;
                            saveSettingsLocked(0, false, false, false);
                        }
                    } finally {
                    }
                }
            }
            this.mInjector.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                if (j != 0 && bArr != null) {
                    try {
                        newWakeLock = ((PowerManager) this.mInjector.mContext.getSystemService(PowerManager.class)).newWakeLock(1, "DevicePolicyManager");
                    } catch (Throwable th) {
                        th = th;
                    }
                    try {
                        if (newWakeLock != null) {
                            newWakeLock.acquire();
                            Log.d("DevicePolicyManager", "wakeLock acquired.");
                        } else {
                            Log.w("DevicePolicyManager", "wakeLock must not be null!");
                        }
                        if (!this.mLockPatternUtils.setLockCredentialWithToken(createPin, j, bArr, i2)) {
                            if (newWakeLock == null) {
                                Log.w("DevicePolicyManager", "wakeLock must not be null!");
                            } else if (newWakeLock.isHeld()) {
                                newWakeLock.release();
                                Log.d("DevicePolicyManager", "wakeLock released.");
                            } else {
                                Log.d("DevicePolicyManager", "wakeLock is not held.");
                            }
                            this.mInjector.getClass();
                            Binder.restoreCallingIdentity(clearCallingIdentity);
                            return false;
                        }
                        if (newWakeLock == null) {
                            Log.w("DevicePolicyManager", "wakeLock must not be null!");
                        } else if (newWakeLock.isHeld()) {
                            newWakeLock.release();
                            Log.d("DevicePolicyManager", "wakeLock released.");
                        } else {
                            Log.d("DevicePolicyManager", "wakeLock is not held.");
                        }
                    } catch (Throwable th2) {
                        th = th2;
                        wakeLock = newWakeLock;
                        if (wakeLock == null) {
                            Log.w("DevicePolicyManager", "wakeLock must not be null!");
                        } else if (wakeLock.isHeld()) {
                            wakeLock.release();
                            Log.d("DevicePolicyManager", "wakeLock released.");
                        } else {
                            Log.d("DevicePolicyManager", "wakeLock is not held.");
                        }
                        throw th;
                    }
                } else if (!this.mLockPatternUtils.setLockCredential(createPin, LockscreenCredential.createNone(), i2)) {
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    return false;
                }
                boolean z4 = (i & 1) != 0;
                if (z4) {
                    this.mLockPatternUtils.requireStrongAuth(2, -1);
                }
                synchronized (getLockObject()) {
                    int i5 = z4 ? i3 : -1;
                    try {
                        if (userData.mPasswordOwner != i5) {
                            userData.mPasswordOwner = i5;
                            z = true;
                        } else {
                            z = false;
                        }
                        if (userData.mLastResetPassword != i3) {
                            userData.mLastResetPassword = i3;
                            z = true;
                        }
                        if (z) {
                            saveSettingsLocked(i2, false, false, false);
                        }
                    } finally {
                    }
                }
                Intent intent = new Intent("com.samsung.knox.app.action.DEVICE_POLICY_MANAGER_PASSWORD_CHANGED");
                intent.setFlags(1073741824);
                this.mContext.sendBroadcastAsUser(intent, new UserHandle(i2));
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                return true;
            } catch (Throwable th3) {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                throw th3;
            }
        }
    }

    public final boolean resetPasswordWithToken(ComponentName componentName, String str, String str2, byte[] bArr, int i) {
        boolean z = false;
        if (!this.mHasFeature || !this.mLockPatternUtils.hasSecureLockScreen()) {
            return false;
        }
        Objects.requireNonNull(bArr);
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        this.mInjector.getClass();
        Injector.logUserForSDP(Injector.userHandleGetCallingUserId(), "Reset password with token for user ");
        this.mInjector.getClass();
        SDPLog.p("admin", componentName, "passwordOrNull", str2, KnoxCustomManagerService.SPCM_KEY_TOKEN, bArr, "flags", Integer.valueOf(i));
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        if (str2 == null) {
            str2 = "";
        }
        String str3 = str2;
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            long j = getUserData(userId).mPasswordTokenHandle;
            if (j != 0) {
                z = resetPasswordInternal(str3, j, bArr, i, callerIdentity, UserHandle.getUserId(callerIdentity.mUid));
            } else {
                Slogf.w("DevicePolicyManager", "No saved token handle");
            }
        }
        if (z) {
            DevicePolicyEventLogger.createEvent(206).setAdmin(callerIdentity.mComponentName).write();
        }
        return z;
    }

    public final boolean resetPasswordWithTokenMDM(ComponentName componentName, String str, byte[] bArr, int i, int i2) {
        Objects.requireNonNull(bArr);
        this.mInjector.getClass();
        Injector.logUserForSDP(Injector.userHandleGetCallingUserId(), "Set reset password MDM with token for user ");
        this.mInjector.getClass();
        SDPLog.p("admin", componentName, "passwordOrNull", str, KnoxCustomManagerService.SPCM_KEY_TOKEN, bArr, "flags", Integer.valueOf(i));
        synchronized (getLockObject()) {
            try {
                getActiveAdminForCallerLockedMDM(2, i2, componentName);
                long j = getUserData(i2).mPasswordTokenHandle;
                if (j == 0) {
                    Slogf.w("DevicePolicyManager", "No saved token handle");
                    return false;
                }
                if (str == null) {
                    str = "";
                }
                String str2 = str;
                this.mInjector.getClass();
                return resetPasswordInternal(str2, j, bArr, i, new CallerIdentity(null, Binder.getCallingUid(), null), i2);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void resetShouldAllowBypassingDevicePolicyManagementRoleQualificationState() {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_ROLE_HOLDERS"));
        setBypassDevicePolicyManagementRoleQualificationStateInternal(null, false);
    }

    public final void resetStrings(List list) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES"));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda25 devicePolicyManagerService$$ExternalSyntheticLambda25 = new DevicePolicyManagerService$$ExternalSyntheticLambda25(this, list, 2);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda25);
    }

    public final ComponentName resolveDelegateReceiver(int i, String str, String str2) {
        List delegatePackagesInternalLocked;
        synchronized (getLockObject()) {
            delegatePackagesInternalLocked = getDelegatePackagesInternalLocked(i, str);
        }
        ArrayList arrayList = (ArrayList) delegatePackagesInternalLocked;
        if (arrayList.size() == 0) {
            return null;
        }
        if (arrayList.size() > 1) {
            Slogf.wtf("DevicePolicyManager", "More than one delegate holds ".concat(str));
            return null;
        }
        String str3 = (String) arrayList.get(0);
        try {
            List list = this.mIPackageManager.queryIntentReceivers(ExplicitHealthCheckController$$ExternalSyntheticOutline0.m(str2, str3), (String) null, 0L, i).getList();
            int size = list.size();
            if (size >= 1) {
                if (size > 1) {
                    Slogf.w("DevicePolicyManager", str3 + " defines more than one delegate receiver for " + str2);
                }
                return ((ResolveInfo) list.get(0)).activityInfo.getComponentName();
            }
        } catch (RemoteException unused) {
        }
        return null;
    }

    public final List retrieveNetworkLogs(ComponentName componentName, String str, long j) {
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        boolean z = true;
        boolean z2 = isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid));
        Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && (isDefaultDeviceOwner(callerIdentity) || z2)) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-network-logging")));
        if (this.mOwners.hasDeviceOwner()) {
            Preconditions.checkCallAuthorization(areAllUsersAffiliatedWithDeviceLocked(), "operation not allowed when device has unaffiliated users");
        }
        synchronized (getLockObject()) {
            try {
                if (this.mNetworkLogger != null && isNetworkLoggingEnabledInternalLocked()) {
                    DevicePolicyEventLogger admin = DevicePolicyEventLogger.createEvent(120).setAdmin(callerIdentity.mPackageName);
                    if (componentName != null) {
                        z = false;
                    }
                    admin.setBoolean(z).setStrings(new String[]{z2 ? "profile-owner" : "device-owner"}).write();
                    long currentTimeMillis = System.currentTimeMillis();
                    DevicePolicyData userData = getUserData(UserHandle.getUserId(callerIdentity.mUid));
                    if (currentTimeMillis > userData.mLastNetworkLogsRetrievalTime) {
                        userData.mLastNetworkLogsRetrievalTime = currentTimeMillis;
                        saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    }
                    return this.mNetworkLogger.retrieveLogs(j);
                }
                return null;
            } finally {
            }
        }
    }

    public final ParceledListSlice retrievePreRebootSecurityLogs(ComponentName componentName, String str) {
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        boolean z = true;
        if (isPermissionCheckFlagEnabled()) {
            if (!isOrganizationOwnedDeviceWithManagedProfile() && !areAllUsersAffiliatedWithDeviceLocked()) {
                z = false;
            }
            Preconditions.checkCallAuthorization(z);
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING", callerIdentity.mPackageName, -1);
        } else {
            if (componentName != null) {
                Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
            } else {
                Preconditions.checkCallAuthorization(isCallerDelegate(callerIdentity, "delegation-security-logging"));
            }
            if (!isOrganizationOwnedDeviceWithManagedProfile() && !areAllUsersAffiliatedWithDeviceLocked()) {
                z = false;
            }
            Preconditions.checkCallAuthorization(z);
        }
        DevicePolicyEventLogger.createEvent(17).setAdmin(callerIdentity.mPackageName).write();
        if (this.mContext.getResources().getBoolean(R.bool.config_supportsSystemDecorsOnSecondaryDisplays)) {
            this.mInjector.getClass();
            if (SecurityLog.getLoggingEnabledProperty()) {
                recordSecurityLogRetrievalTime();
                ArrayList arrayList = new ArrayList();
                try {
                    SecurityLog.readPreviousEvents(arrayList);
                    int securityLoggingEnabledUser = getSecurityLoggingEnabledUser();
                    if (securityLoggingEnabledUser != -1) {
                        SecurityLog.redactEvents(arrayList, securityLoggingEnabledUser);
                    }
                    return new ParceledListSlice(arrayList);
                } catch (IOException e) {
                    Slogf.w("DevicePolicyManager", "Fail to read previous events", e);
                    return new ParceledListSlice(Collections.emptyList());
                }
            }
        }
        return null;
    }

    public final ParceledListSlice retrieveSecurityLogs(ComponentName componentName, String str) {
        ArrayList arrayList;
        if (!this.mHasFeature) {
            return null;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        boolean z = true;
        if (Flags.securityLogV2Enabled()) {
            EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING", callerIdentity.mPackageName);
            synchronized (getLockObject()) {
                try {
                    if (!isOrganizationOwnedDeviceWithManagedProfile() && !areAllUsersAffiliatedWithDeviceLocked()) {
                        z = false;
                    }
                    Preconditions.checkCallAuthorization(z);
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (!Boolean.TRUE.equals((Boolean) this.mDevicePolicyEngine.getGlobalPolicySetByAdmin(PolicyDefinition.SECURITY_LOGGING, enforcePermissionAndGetEnforcingAdmin))) {
                Slogf.e("DevicePolicyManager", "%s hasn't enabled security logging but tries to retrieve logs", callerIdentity.mPackageName);
                return null;
            }
        } else {
            if (componentName != null) {
                Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
            } else {
                Preconditions.checkCallAuthorization(isCallerDelegate(callerIdentity, "delegation-security-logging"));
            }
            if (!isOrganizationOwnedDeviceWithManagedProfile() && !areAllUsersAffiliatedWithDeviceLocked()) {
                z = false;
            }
            Preconditions.checkCallAuthorization(z);
            this.mInjector.getClass();
            if (!SecurityLog.getLoggingEnabledProperty()) {
                return null;
            }
        }
        recordSecurityLogRetrievalTime();
        SecurityLogMonitor securityLogMonitor = this.mSecurityLogMonitor;
        ((ReentrantLock) securityLogMonitor.mLock).lock();
        try {
            if (securityLogMonitor.mAllowedToRetrieve) {
                securityLogMonitor.mAllowedToRetrieve = false;
                securityLogMonitor.mNextAllowedRetrievalTimeMillis = SystemClock.elapsedRealtime() + SecurityLogMonitor.RATE_LIMIT_INTERVAL_MS;
                arrayList = securityLogMonitor.mPendingLogs;
                securityLogMonitor.mPendingLogs = new ArrayList();
                securityLogMonitor.mCriticalLevelLogged = false;
            } else {
                ((ReentrantLock) securityLogMonitor.mLock).unlock();
                arrayList = null;
            }
            DevicePolicyEventLogger.createEvent(16).setAdmin(callerIdentity.mPackageName).write();
            if (arrayList != null) {
                return new ParceledListSlice(arrayList);
            }
            return null;
        } finally {
            ((ReentrantLock) securityLogMonitor.mLock).unlock();
        }
    }

    public final void revertTransferOwnershipIfNecessaryLocked() {
        TransferOwnershipMetadataManager transferOwnershipMetadataManager = this.mTransferOwnershipMetadataManager;
        transferOwnershipMetadataManager.getClass();
        transferOwnershipMetadataManager.mInjector.getClass();
        if (new File(Environment.getDataSystemDirectory(), "owner-transfer-metadata.xml").exists()) {
            Slogf.e("DevicePolicyManager", "Owner transfer metadata file exists! Reverting transfer.");
            TransferOwnershipMetadataManager transferOwnershipMetadataManager2 = this.mTransferOwnershipMetadataManager;
            transferOwnershipMetadataManager2.getClass();
            transferOwnershipMetadataManager2.mInjector.getClass();
            File file = new File(Environment.getDataSystemDirectory(), "owner-transfer-metadata.xml");
            TransferOwnershipMetadataManager.Metadata metadata = null;
            if (file.exists()) {
                Slog.d("com.android.server.devicepolicy.TransferOwnershipMetadataManager", "Loading TransferOwnershipMetadataManager from " + file);
                try {
                    FileInputStream fileInputStream = new FileInputStream(file);
                    try {
                        TransferOwnershipMetadataManager.Metadata parseMetadataFile = TransferOwnershipMetadataManager.parseMetadataFile(Xml.resolvePullParser(fileInputStream));
                        fileInputStream.close();
                        metadata = parseMetadataFile;
                    } catch (Throwable th) {
                        try {
                            fileInputStream.close();
                        } catch (Throwable th2) {
                            th.addSuppressed(th2);
                        }
                        throw th;
                    }
                } catch (IOException | IllegalArgumentException | XmlPullParserException e) {
                    Slog.e("com.android.server.devicepolicy.TransferOwnershipMetadataManager", "Caught exception while trying to load the owner transfer params from file " + file, e);
                }
            }
            boolean equals = metadata.adminType.equals("profile-owner");
            int i = metadata.userId;
            if (equals) {
                transferProfileOwnershipLocked(metadata.targetComponent, metadata.sourceComponent, i);
                deleteTransferOwnershipMetadataFileLocked();
                deleteTransferOwnershipBundleLocked(i);
            } else if (metadata.adminType.equals("device-owner")) {
                transferDeviceOwnershipLocked(metadata.targetComponent, metadata.sourceComponent, i);
                deleteTransferOwnershipMetadataFileLocked();
                deleteTransferOwnershipBundleLocked(i);
            }
            updateSystemUpdateFreezePeriodsRecord(true);
        }
    }

    /* JADX WARN: Removed duplicated region for block: B:11:0x0034  */
    /* JADX WARN: Removed duplicated region for block: B:14:0x004c  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void saveGlobalProxyLocked(java.lang.String r5, java.lang.String r6) {
        /*
            r4 = this;
            java.lang.String r0 = ""
            if (r6 != 0) goto L5
            r6 = r0
        L5:
            if (r5 != 0) goto L8
            r5 = r0
        L8:
            java.lang.String r5 = r5.trim()
            java.lang.String r0 = ":"
            java.lang.String[] r5 = r5.split(r0)
            int r0 = r5.length
            r1 = 1
            if (r0 <= r1) goto L1d
            r0 = r5[r1]     // Catch: java.lang.NumberFormatException -> L1d
            int r0 = java.lang.Integer.parseInt(r0)     // Catch: java.lang.NumberFormatException -> L1d
            goto L1f
        L1d:
            r0 = 8080(0x1f90, float:1.1322E-41)
        L1f:
            java.lang.String r6 = r6.trim()
            r1 = 0
            r2 = r5[r1]
            java.util.List r3 = com.android.net.module.util.ProxyUtils.exclusionStringAsList(r6)
            android.net.ProxyInfo r2 = android.net.ProxyInfo.buildDirectProxy(r2, r0, r3)
            boolean r3 = r2.isValid()
            if (r3 != 0) goto L4c
            java.lang.StringBuilder r4 = new java.lang.StringBuilder
            java.lang.String r5 = "Invalid proxy properties, ignoring: "
            r4.<init>(r5)
            java.lang.String r5 = r2.toString()
            r4.append(r5)
            java.lang.String r4 = r4.toString()
            java.lang.String r5 = "DevicePolicyManager"
            com.android.server.utils.Slogf.e(r5, r4)
            return
        L4c:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r2 = r4.mInjector
            r5 = r5[r1]
            android.content.Context r1 = r2.mContext
            android.content.ContentResolver r1 = r1.getContentResolver()
            java.lang.String r2 = "global_http_proxy_host"
            android.provider.Settings.Global.putString(r1, r2, r5)
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r5 = r4.mInjector
            java.lang.String r1 = "global_http_proxy_port"
            r5.settingsGlobalPutInt(r1, r0)
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r4 = r4.mInjector
            android.content.Context r4 = r4.mContext
            android.content.ContentResolver r4 = r4.getContentResolver()
            java.lang.String r5 = "global_http_proxy_exclusion_list"
            android.provider.Settings.Global.putString(r4, r5, r6)
            return
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.saveGlobalProxyLocked(java.lang.String, java.lang.String):void");
    }

    public final void saveSettingsLocked(int i, boolean z, boolean z2, boolean z3) {
        File userSystemDirectory;
        FileOutputStream fileOutputStream;
        IOException e;
        if (DevicePolicyData.store(getUserData(i), makeJournaledFile(i, "device_policies.xml"))) {
            if (i == 0) {
                this.mPathProvider.getClass();
                userSystemDirectory = Environment.getDataSystemDirectory();
            } else {
                this.mPathProvider.getClass();
                userSystemDirectory = Environment.getUserSystemDirectory(i);
            }
            File file = new File(userSystemDirectory, "device_policies.xml");
            try {
                fileOutputStream = new FileOutputStream(file, true);
            } catch (IOException e2) {
                fileOutputStream = null;
                e = e2;
            }
            try {
                FileUtils.sync(fileOutputStream);
                fileOutputStream.close();
            } catch (IOException e3) {
                e = e3;
                Slogf.w("DevicePolicyManager", e, "failed writing file %s", file);
                if (fileOutputStream != null) {
                    try {
                        fileOutputStream.close();
                    } catch (IOException unused) {
                    }
                }
                if (z) {
                }
                sendChangedNotification(i, z, z2, z3);
                DevicePolicyManager.invalidateBinderCaches();
            }
            if (!z || z2 || z3) {
                sendChangedNotification(i, z, z2, z3);
            } else {
                sendChangedNotification(i, false, false, false);
            }
        }
        DevicePolicyManager.invalidateBinderCaches();
    }

    public void saveTransferOwnershipBundleLocked(PersistableBundle persistableBundle, int i) {
        this.mPathProvider.getClass();
        File file = new File(Environment.getUserSystemDirectory(i), "transfer-ownership-parameters.xml");
        AtomicFile atomicFile = new AtomicFile(file);
        FileOutputStream fileOutputStream = null;
        try {
            FileOutputStream startWrite = atomicFile.startWrite();
            try {
                TypedXmlSerializer resolveSerializer = Xml.resolveSerializer(startWrite);
                resolveSerializer.startDocument((String) null, Boolean.TRUE);
                resolveSerializer.startTag((String) null, "transfer-ownership-bundle");
                persistableBundle.saveToXml(resolveSerializer);
                resolveSerializer.endTag((String) null, "transfer-ownership-bundle");
                resolveSerializer.endDocument();
                atomicFile.finishWrite(startWrite);
            } catch (IOException | XmlPullParserException e) {
                e = e;
                fileOutputStream = startWrite;
                Slogf.e("DevicePolicyManager", "Caught exception while trying to save the owner transfer parameters to file " + file, e);
                file.delete();
                atomicFile.failWrite(fileOutputStream);
            }
        } catch (IOException | XmlPullParserException e2) {
            e = e2;
        }
    }

    /* JADX WARN: Code restructure failed: missing block: B:41:0x004b, code lost:
    
        r9 = move-exception;
     */
    /* JADX WARN: Code restructure failed: missing block: B:44:0x00e8, code lost:
    
        throw r9;
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void saveUserRestrictionsLocked(int r10) {
        /*
            r9 = this;
            java.lang.String r0 = "enable_device_policy_engine"
            java.lang.String r1 = "device_policy_manager"
            r2 = 1
            boolean r0 = android.provider.DeviceConfig.getBoolean(r1, r0, r2)
            if (r0 == 0) goto Le
            return
        Le:
            r0 = 0
            r9.saveSettingsLocked(r10, r0, r0, r0)
            java.lang.String r1 = "enable_device_policy_engine"
            java.lang.String r3 = "device_policy_manager"
            boolean r1 = android.provider.DeviceConfig.getBoolean(r3, r1, r2)
            if (r1 == 0) goto L20
            goto Le1
        L20:
            com.android.server.pm.RestrictionsSet r1 = new com.android.server.pm.RestrictionsSet
            r1.<init>()
            java.lang.Object r3 = r9.getLockObject()
            monitor-enter(r3)
            com.android.server.devicepolicy.Owners r4 = r9.mOwners     // Catch: java.lang.Throwable -> L4b
            com.android.server.devicepolicy.OwnersData r5 = r4.mData     // Catch: java.lang.Throwable -> L4b
            monitor-enter(r5)     // Catch: java.lang.Throwable -> L4b
            com.android.server.devicepolicy.OwnersData r4 = r4.mData     // Catch: java.lang.Throwable -> L3b
            com.android.server.devicepolicy.OwnersData$OwnerInfo r6 = r4.mDeviceOwner     // Catch: java.lang.Throwable -> L3b
            if (r6 == 0) goto L3e
            int r4 = r4.mDeviceOwnerUserId     // Catch: java.lang.Throwable -> L3b
            if (r4 != r10) goto L3e
            r4 = r2
            goto L3f
        L3b:
            r9 = move-exception
            goto Le5
        L3e:
            r4 = r0
        L3f:
            monitor-exit(r5)     // Catch: java.lang.Throwable -> L3b
            if (r4 == 0) goto L6e
            com.android.server.devicepolicy.ActiveAdmin r2 = r9.getDeviceOwnerAdminLocked()     // Catch: java.lang.Throwable -> L4b
            if (r2 != 0) goto L4e
            monitor-exit(r3)     // Catch: java.lang.Throwable -> L4b
            goto Le1
        L4b:
            r9 = move-exception
            goto Le7
        L4e:
            android.os.Bundle r4 = r2.getEffectiveRestrictions()     // Catch: java.lang.Throwable -> L4b
            com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1 r5 = new com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1     // Catch: java.lang.Throwable -> L4b
            r6 = 0
            r5.<init>()     // Catch: java.lang.Throwable -> L4b
            android.os.Bundle r4 = com.android.server.devicepolicy.ActiveAdmin.filterRestrictions(r4, r5)     // Catch: java.lang.Throwable -> L4b
            android.os.Bundle r2 = r2.getEffectiveRestrictions()     // Catch: java.lang.Throwable -> L4b
            com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1 r5 = new com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1     // Catch: java.lang.Throwable -> L4b
            r6 = 1
            r5.<init>()     // Catch: java.lang.Throwable -> L4b
            android.os.Bundle r2 = com.android.server.devicepolicy.ActiveAdmin.filterRestrictions(r2, r5)     // Catch: java.lang.Throwable -> L4b
            r1.updateRestrictions(r10, r2)     // Catch: java.lang.Throwable -> L4b
            goto Ldb
        L6e:
            com.android.server.devicepolicy.ActiveAdmin r4 = r9.getProfileOwnerAdminLocked(r10)     // Catch: java.lang.Throwable -> L4b
            if (r4 != 0) goto L76
            monitor-exit(r3)     // Catch: java.lang.Throwable -> L4b
            goto Le1
        L76:
            android.os.Bundle r5 = r4.getEffectiveRestrictions()     // Catch: java.lang.Throwable -> L4b
            com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1 r6 = new com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1     // Catch: java.lang.Throwable -> L4b
            r7 = 0
            r6.<init>()     // Catch: java.lang.Throwable -> L4b
            android.os.Bundle r5 = com.android.server.devicepolicy.ActiveAdmin.filterRestrictions(r5, r6)     // Catch: java.lang.Throwable -> L4b
            android.os.Bundle r6 = r4.getEffectiveRestrictions()     // Catch: java.lang.Throwable -> L4b
            com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1 r7 = new com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1     // Catch: java.lang.Throwable -> L4b
            r8 = 1
            r7.<init>()     // Catch: java.lang.Throwable -> L4b
            android.os.Bundle r2 = com.android.server.devicepolicy.ActiveAdmin.filterRestrictions(r6, r7)     // Catch: java.lang.Throwable -> L4b
            r1.updateRestrictions(r10, r2)     // Catch: java.lang.Throwable -> L4b
            android.os.UserHandle r2 = r4.getUserHandle()     // Catch: java.lang.Throwable -> L4b
            int r2 = r2.getIdentifier()     // Catch: java.lang.Throwable -> L4b
            boolean r2 = r9.isProfileOwnerOfOrganizationOwnedDevice(r2)     // Catch: java.lang.Throwable -> L4b
            if (r2 == 0) goto Lda
            com.android.server.devicepolicy.ActiveAdmin r2 = r4.getParentActiveAdmin()     // Catch: java.lang.Throwable -> L4b
            android.os.Bundle r2 = r2.getEffectiveRestrictions()     // Catch: java.lang.Throwable -> L4b
            com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1 r6 = new com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1     // Catch: java.lang.Throwable -> L4b
            r7 = 2
            r8 = 0
            r6.<init>()     // Catch: java.lang.Throwable -> L4b
            android.os.Bundle r2 = com.android.server.devicepolicy.ActiveAdmin.filterRestrictions(r2, r6)     // Catch: java.lang.Throwable -> L4b
            com.android.server.pm.UserRestrictionsUtils.merge(r5, r2)     // Catch: java.lang.Throwable -> L4b
            android.os.UserHandle r2 = r4.getUserHandle()     // Catch: java.lang.Throwable -> L4b
            int r2 = r2.getIdentifier()     // Catch: java.lang.Throwable -> L4b
            int r2 = r9.getProfileParentId(r2)     // Catch: java.lang.Throwable -> L4b
            com.android.server.devicepolicy.ActiveAdmin r4 = r4.getParentActiveAdmin()     // Catch: java.lang.Throwable -> L4b
            android.os.Bundle r4 = r4.getEffectiveRestrictions()     // Catch: java.lang.Throwable -> L4b
            com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1 r6 = new com.android.server.devicepolicy.ActiveAdmin$$ExternalSyntheticLambda1     // Catch: java.lang.Throwable -> L4b
            r8 = 1
            r6.<init>()     // Catch: java.lang.Throwable -> L4b
            android.os.Bundle r4 = com.android.server.devicepolicy.ActiveAdmin.filterRestrictions(r4, r6)     // Catch: java.lang.Throwable -> L4b
            r1.updateRestrictions(r2, r4)     // Catch: java.lang.Throwable -> L4b
        Lda:
            r4 = r5
        Ldb:
            monitor-exit(r3)     // Catch: java.lang.Throwable -> L4b
            com.android.server.pm.UserManagerInternal r2 = r9.mUserManagerInternal
            r2.setDevicePolicyUserRestrictions(r4, r1)
        Le1:
            r9.sendChangedNotification(r10, r0, r0, r0)
            return
        Le5:
            monitor-exit(r5)     // Catch: java.lang.Throwable -> L3b
            throw r9     // Catch: java.lang.Throwable -> L4b
        Le7:
            monitor-exit(r3)     // Catch: java.lang.Throwable -> L4b
            throw r9
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.saveUserRestrictionsLocked(int):void");
    }

    public final int semGetAllowBluetoothMode(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.allowBluetoothMode : 2;
                }
                DevicePolicyData userData = getUserData(0);
                int size = userData.mAdminList.size();
                int i2 = 2;
                for (int i3 = 0; i3 < size; i3++) {
                    ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminList.get(i3);
                    if (i2 == 2) {
                        i2 = activeAdmin.allowBluetoothMode;
                    }
                }
                if (i2 != 2) {
                    Slogf.e("DevicePolicyManager", "semGetAllowBluetoothMode - value_root retunrs : " + i2);
                    return i2;
                }
                DevicePolicyData userData2 = getUserData(i);
                int size2 = userData2.mAdminList.size();
                int i4 = 2;
                for (int i5 = 0; i5 < size2; i5++) {
                    ActiveAdmin activeAdmin2 = (ActiveAdmin) userData2.mAdminList.get(i5);
                    if (i4 == 2) {
                        i4 = activeAdmin2.allowBluetoothMode;
                    }
                }
                Slogf.e("DevicePolicyManager", "semGetAllowBluetoothMode - value retunrs : " + i4);
                return i4;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean semGetAllowBrowser(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.allowBrowser : true;
                }
                DevicePolicyData userData = getUserData(i);
                int size = userData.mAdminList.size();
                for (int i2 = 0; i2 < size; i2++) {
                    if (!((ActiveAdmin) userData.mAdminList.get(i2)).allowBrowser) {
                        return false;
                    }
                }
                return true;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean semGetAllowDesktopSync(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.allowDesktopSync : true;
                }
                DevicePolicyData userData = getUserData(0);
                int size = userData.mAdminList.size();
                for (int i2 = 0; i2 < size; i2++) {
                    if (!((ActiveAdmin) userData.mAdminList.get(i2)).allowDesktopSync) {
                        return false;
                    }
                }
                DevicePolicyData userData2 = getUserData(i);
                int size2 = userData2.mAdminList.size();
                for (int i3 = 0; i3 < size2; i3++) {
                    if (!((ActiveAdmin) userData2.mAdminList.get(i3)).allowDesktopSync) {
                        return false;
                    }
                }
                return true;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean semGetAllowInternetSharing(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.allowInternetSharing : true;
                }
                DevicePolicyData userData = getUserData(0);
                int size = userData.mAdminList.size();
                for (int i2 = 0; i2 < size; i2++) {
                    if (!((ActiveAdmin) userData.mAdminList.get(i2)).allowInternetSharing) {
                        return false;
                    }
                }
                DevicePolicyData userData2 = getUserData(i);
                int size2 = userData2.mAdminList.size();
                for (int i3 = 0; i3 < size2; i3++) {
                    if (!((ActiveAdmin) userData2.mAdminList.get(i3)).allowInternetSharing) {
                        return false;
                    }
                }
                return true;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean semGetAllowIrda(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.allowIrDA : true;
                }
                DevicePolicyData userData = getUserData(i);
                int size = userData.mAdminList.size();
                for (int i2 = 0; i2 < size; i2++) {
                    if (!((ActiveAdmin) userData.mAdminList.get(i2)).allowIrDA) {
                        return false;
                    }
                }
                return true;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean semGetAllowPopImapEmail(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.allowPOPIMAPEmail : true;
                }
                DevicePolicyData userData = getUserData(i);
                int size = userData.mAdminList.size();
                for (int i2 = 0; i2 < size; i2++) {
                    if (!((ActiveAdmin) userData.mAdminList.get(i2)).allowPOPIMAPEmail) {
                        return false;
                    }
                }
                return true;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean semGetAllowStorageCard(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.allowStorageCard : true;
                }
                DevicePolicyData userData = getUserData(0);
                int size = userData.mAdminList.size();
                boolean z = true;
                for (int i2 = 0; i2 < size; i2++) {
                    ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminList.get(i2);
                    if (z) {
                        z = activeAdmin.allowStorageCard;
                    }
                }
                if (!z) {
                    return z;
                }
                DevicePolicyData userData2 = getUserData(i);
                int size2 = userData2.mAdminList.size();
                boolean z2 = true;
                for (int i3 = 0; i3 < size2; i3++) {
                    ActiveAdmin activeAdmin2 = (ActiveAdmin) userData2.mAdminList.get(i3);
                    if (z2) {
                        z2 = activeAdmin2.allowStorageCard;
                    }
                }
                return z2;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean semGetAllowTextMessaging(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.allowTextMessaging : true;
                }
                DevicePolicyData userData = getUserData(i);
                int size = userData.mAdminList.size();
                for (int i2 = 0; i2 < size; i2++) {
                    if (!((ActiveAdmin) userData.mAdminList.get(i2)).allowTextMessaging) {
                        return false;
                    }
                }
                return true;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean semGetAllowWifi(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.allowWifi : true;
                }
                DevicePolicyData userData = getUserData(0);
                int size = userData.mAdminList.size();
                for (int i2 = 0; i2 < size; i2++) {
                    if (!((ActiveAdmin) userData.mAdminList.get(i2)).allowWifi) {
                        return false;
                    }
                }
                DevicePolicyData userData2 = getUserData(i);
                int size2 = userData2.mAdminList.size();
                for (int i3 = 0; i3 < size2; i3++) {
                    if (!((ActiveAdmin) userData2.mAdminList.get(i3)).allowWifi) {
                        return false;
                    }
                }
                return true;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean semGetRequireStorageCardEncryption(ComponentName componentName, int i, boolean z) {
        synchronized (getLockObject()) {
            try {
                int organizationOwnedProfileUserId = getOrganizationOwnedProfileUserId();
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = z ? getActiveAdminUncheckedLocked(organizationOwnedProfileUserId, componentName, true) : getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.requireStorageCardEncryption : false;
                }
                DevicePolicyData userData = getUserData(i);
                int size = userData.mAdminList.size();
                boolean z2 = false;
                for (int i2 = 0; i2 < size; i2++) {
                    ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminList.get(i2);
                    if (!z2) {
                        z2 = activeAdmin.requireStorageCardEncryption;
                    }
                }
                if (organizationOwnedProfileUserId != -10000) {
                    int profileParentId = getProfileParentId(organizationOwnedProfileUserId);
                    new ArrayList();
                    Iterator it = (isManagedProfile(profileParentId) ? getUserDataUnchecked(profileParentId).mAdminList : getActiveAdminsForUserAndItsManagedProfilesLocked(profileParentId, new DevicePolicyManagerService$$ExternalSyntheticLambda9(0))).iterator();
                    while (it.hasNext()) {
                        if (((ActiveAdmin) it.next()).requireStorageCardEncryption) {
                            z2 = true;
                        }
                    }
                }
                return z2;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final boolean semIsActivePasswordSufficient(int i) {
        boolean z;
        if (!this.mHasFeature) {
            return true;
        }
        Preconditions.checkArgumentNonnegative(i, "Invalid userId");
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i));
        enforceUserUnlocked(i);
        synchronized (getLockObject()) {
            try {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda29 devicePolicyManagerService$$ExternalSyntheticLambda29 = new DevicePolicyManagerService$$ExternalSyntheticLambda29(i, 4, this);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda29);
                int credentialOwner = getCredentialOwner(i, false);
                DevicePolicyData userDataUnchecked = getUserDataUnchecked(credentialOwner);
                PasswordMetrics userPasswordMetrics = this.mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);
                z = userDataUnchecked.mPasswordValidAtLastCheckpoint;
                this.mInjector.getClass();
                if (StorageManager.isFileEncrypted() || userPasswordMetrics != null) {
                    if (userPasswordMetrics == null) {
                        throw new IllegalStateException("isActivePasswordSufficient called on FBE-locked user");
                    }
                    z = isPasswordSufficientForUserWithoutCheckpointLocked(userPasswordMetrics, i);
                }
            } finally {
            }
        }
        return z;
    }

    public final boolean semIsSimplePasswordEnabled(ComponentName componentName, int i) {
        synchronized (getLockObject()) {
            try {
                if (componentName != null) {
                    ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                    return activeAdminUncheckedLocked != null ? activeAdminUncheckedLocked.simplePasswordEnabled : true;
                }
                Iterator it = this.mUserManager.getProfiles(i).iterator();
                while (it.hasNext()) {
                    DevicePolicyData userDataUnchecked = getUserDataUnchecked(((UserInfo) it.next()).id);
                    int size = userDataUnchecked.mAdminList.size();
                    int i2 = 0;
                    while (true) {
                        if (i2 >= size) {
                            break;
                        }
                        ActiveAdmin activeAdmin = (ActiveAdmin) userDataUnchecked.mAdminList.get(i2);
                        if (r1 && !activeAdmin.simplePasswordEnabled) {
                            r1 = false;
                            break;
                        }
                        i2++;
                    }
                    if (!r1) {
                        break;
                    }
                }
                return r1;
            } finally {
            }
        }
    }

    public final void semSetAllowBluetoothMode(ComponentName componentName, int i) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminForCallerLocked = getActiveAdminForCallerLocked(17, componentName);
                if (activeAdminForCallerLocked.allowBluetoothMode != i) {
                    activeAdminForCallerLocked.allowBluetoothMode = i;
                    saveSettingsLocked(userHandleGetCallingUserId, true, false, true);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetAllowBrowser(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminForCallerLocked = getActiveAdminForCallerLocked(15, componentName);
                if (activeAdminForCallerLocked.allowBrowser != z) {
                    activeAdminForCallerLocked.allowBrowser = z;
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetAllowDesktopSync(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminForCallerLocked = getActiveAdminForCallerLocked(18, componentName);
                if (activeAdminForCallerLocked.allowDesktopSync != z) {
                    activeAdminForCallerLocked.allowDesktopSync = z;
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, true);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetAllowInternetSharing(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminForCallerLocked = getActiveAdminForCallerLocked(16, componentName);
                if (activeAdminForCallerLocked.allowInternetSharing != z) {
                    activeAdminForCallerLocked.allowInternetSharing = z;
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, true);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetAllowIrda(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminForCallerLocked = getActiveAdminForCallerLocked(19, componentName);
                if (activeAdminForCallerLocked.allowIrDA != z) {
                    activeAdminForCallerLocked.allowIrDA = z;
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetAllowPopImapEmail(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminForCallerLocked = getActiveAdminForCallerLocked(14, componentName);
                if (activeAdminForCallerLocked.allowPOPIMAPEmail != z) {
                    activeAdminForCallerLocked.allowPOPIMAPEmail = z;
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetAllowStorageCard(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminForCallerLocked = getActiveAdminForCallerLocked(11, componentName);
                if (activeAdminForCallerLocked.allowStorageCard != z) {
                    activeAdminForCallerLocked.allowStorageCard = z;
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, true);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetAllowTextMessaging(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminForCallerLocked = getActiveAdminForCallerLocked(13, componentName);
                if (activeAdminForCallerLocked.allowTextMessaging != z) {
                    activeAdminForCallerLocked.allowTextMessaging = z;
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetAllowWifi(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminForCallerLocked = getActiveAdminForCallerLocked(12, componentName);
                if (activeAdminForCallerLocked.allowWifi != z) {
                    activeAdminForCallerLocked.allowWifi = z;
                    saveSettingsLocked(userHandleGetCallingUserId, false, true, true);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetChangeNotificationEnabled(ComponentName componentName, boolean z) {
        if (componentName == null) {
            return;
        }
        if (!isPackageSignedByPlatform(componentName.getPackageName())) {
            Slogf.e("DevicePolicyManager", "Not Samsung Package, not proceeding.");
            return;
        }
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                if (getActiveAdminUncheckedLocked(userHandleGetCallingUserId, componentName) == null) {
                    return;
                }
                boolean z2 = z && !this.mNotifyChanges;
                this.mNotifyChanges = z;
                if (z2) {
                    boolean semGetAllowWifi = semGetAllowWifi(null, userHandleGetCallingUserId);
                    StringBuilder m = BatteryService$$ExternalSyntheticOutline0.m("curAllowWifi = ", ", oldAllowWifi = ", semGetAllowWifi);
                    m.append(this.oldAllowWifi);
                    Slogf.d("DevicePolicyManager", m.toString());
                    sendChangedNotification(userHandleGetCallingUserId, false, this.oldAllowWifi != semGetAllowWifi, false);
                    this.oldAllowWifi = semGetAllowWifi;
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetKeyguardDisabledFeatures(ComponentName componentName, int i) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isAuthorizedSamsungPackage(componentName));
            this.mInjector.getClass();
            int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            synchronized (getLockObject()) {
                this.mInjector.getClass();
                long clearCallingIdentity = Binder.clearCallingIdentity();
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(9, userHandleGetCallingUserId, componentName);
                    if (isManagedProfile(userHandleGetCallingUserId)) {
                        i &= FrameworkStatsLog.APP_BACKGROUND_RESTRICTIONS_INFO;
                    }
                    if (activeAdminForCallerLockedMDM.disabledKeyguardFeatures != i) {
                        activeAdminForCallerLockedMDM.disabledKeyguardFeatures = i;
                        saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                    }
                } finally {
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210021, new Object[]{componentName.getPackageName(), Integer.valueOf(userHandleGetCallingUserId), Integer.valueOf(userHandleGetCallingUserId), Integer.valueOf(i)});
            }
            DevicePolicyEventLogger.createEvent(9).setAdmin(componentName).setInt(i).setStrings(new String[]{"notCalledFromParent"}).write();
        }
    }

    public final void semSetPasswordExpirationTimeout(final ComponentName componentName, final long j) {
        if (this.mHasFeature && this.mLockPatternUtils.hasSecureLockScreen()) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isAuthorizedSamsungPackage(componentName));
            Preconditions.checkArgumentNonnegative(j, "Timeout must be >= 0 ms");
            this.mInjector.getClass();
            final int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            synchronized (getLockObject()) {
                Injector injector = this.mInjector;
                FunctionalUtils.ThrowingRunnable throwingRunnable = new FunctionalUtils.ThrowingRunnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda100
                    public final void runOrThrow() {
                        DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                        ComponentName componentName2 = componentName;
                        int i = userHandleGetCallingUserId;
                        long j2 = j;
                        ActiveAdmin activeAdminForCallerLockedMDM = devicePolicyManagerService.getActiveAdminForCallerLockedMDM(0, i, componentName2);
                        long currentTimeMillis = j2 > 0 ? System.currentTimeMillis() + j2 : 0L;
                        activeAdminForCallerLockedMDM.passwordExpirationDate = currentTimeMillis;
                        activeAdminForCallerLockedMDM.passwordExpirationTimeout = j2;
                        if (j2 > 0) {
                            Slogf.w("DevicePolicyManager", "semSetPasswordExpirationTimeout(): password will expire on " + DateFormat.getDateTimeInstance(2, 2).format(new Date(currentTimeMillis)));
                        }
                        devicePolicyManagerService.saveSettingsLocked(i, false, false, false);
                        devicePolicyManagerService.setExpirationAlarmCheckLocked(devicePolicyManagerService.mContext, i, false);
                    }
                };
                injector.getClass();
                Binder.withCleanCallingIdentity(throwingRunnable);
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210016, new Object[]{componentName.getPackageName(), Integer.valueOf(userHandleGetCallingUserId), Integer.valueOf(userHandleGetCallingUserId), Long.valueOf(j)});
            }
        }
    }

    public final void semSetPasswordHistoryLength(ComponentName componentName, int i) {
        if (this.mHasFeature && this.mLockPatternUtils.hasSecureLockScreen()) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isAuthorizedSamsungPackage(componentName));
            this.mInjector.getClass();
            int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            synchronized (getLockObject()) {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda68 devicePolicyManagerService$$ExternalSyntheticLambda68 = new DevicePolicyManagerService$$ExternalSyntheticLambda68(this, componentName, userHandleGetCallingUserId, i, 3);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda68);
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210018, new Object[]{componentName.getPackageName(), Integer.valueOf(userHandleGetCallingUserId), Integer.valueOf(userHandleGetCallingUserId), Integer.valueOf(i)});
            }
        }
    }

    public final void semSetPasswordMinimumLength(ComponentName componentName, int i) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isAuthorizedSamsungPackage(componentName));
            this.mInjector.getClass();
            int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            synchronized (getLockObject()) {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda68 devicePolicyManagerService$$ExternalSyntheticLambda68 = new DevicePolicyManagerService$$ExternalSyntheticLambda68(this, componentName, userHandleGetCallingUserId, i, 5);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda68);
            }
            DevicePolicyEventLogger.createEvent(2).setAdmin(componentName).setInt(i).write();
        }
    }

    public final void semSetPasswordMinimumLowerCase(ComponentName componentName, int i) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isAuthorizedSamsungPackage(componentName));
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda68 devicePolicyManagerService$$ExternalSyntheticLambda68 = new DevicePolicyManagerService$$ExternalSyntheticLambda68(this, componentName, userHandleGetCallingUserId, i, 4);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda68);
        }
        DevicePolicyEventLogger.createEvent(6).setAdmin(componentName).setInt(i).write();
    }

    public final void semSetPasswordMinimumNonLetter(ComponentName componentName, int i) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isAuthorizedSamsungPackage(componentName));
            this.mInjector.getClass();
            int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            synchronized (getLockObject()) {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda68 devicePolicyManagerService$$ExternalSyntheticLambda68 = new DevicePolicyManagerService$$ExternalSyntheticLambda68(this, componentName, userHandleGetCallingUserId, i, 0);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda68);
            }
            DevicePolicyEventLogger.createEvent(4).setAdmin(componentName).setInt(i).write();
        }
    }

    public final void semSetPasswordMinimumUpperCase(ComponentName componentName, int i) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isAuthorizedSamsungPackage(componentName));
            this.mInjector.getClass();
            int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            synchronized (getLockObject()) {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda68 devicePolicyManagerService$$ExternalSyntheticLambda68 = new DevicePolicyManagerService$$ExternalSyntheticLambda68(this, componentName, userHandleGetCallingUserId, i, 1);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda68);
            }
            DevicePolicyEventLogger.createEvent(7).setAdmin(componentName).setInt(i).write();
        }
    }

    public final void semSetPasswordQuality(ComponentName componentName, int i) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            validateQualityConstant(i);
            Preconditions.checkCallAuthorization(isAuthorizedSamsungPackage(componentName));
            int userId = UserHandle.getUserId(getCallerIdentity(componentName).mUid);
            synchronized (getLockObject()) {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda68 devicePolicyManagerService$$ExternalSyntheticLambda68 = new DevicePolicyManagerService$$ExternalSyntheticLambda68(this, componentName, userId, i, 2);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda68);
            }
            DevicePolicyEventLogger.createEvent(1).setAdmin(componentName).setInt(i).setStrings(new String[]{"notCalledFromParent"}).write();
        }
    }

    public final void semSetRequireStorageCardEncryption(ComponentName componentName, boolean z, boolean z2) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                this.mInjector.getClass();
                this.mInjector.getClass();
                ActiveAdmin activeAdminForCallerLockedMDM = Binder.getCallingPid() == Process.myPid() ? !z2 ? getActiveAdminForCallerLockedMDM(20, userHandleGetCallingUserId, componentName) : getActiveAdminForCallerLockedMDM(getOrganizationOwnedProfileUserId(), componentName, z2) : getActiveAdminForCallerLocked(20, componentName);
                if (activeAdminForCallerLockedMDM.requireStorageCardEncryption != z) {
                    activeAdminForCallerLockedMDM.requireStorageCardEncryption = z;
                    if (z2) {
                        saveSettingsLocked(getOrganizationOwnedProfileUserId(), false, false, false);
                    } else {
                        saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                    }
                    this.mSecurityPolicyHelper.getClass();
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void semSetSimplePasswordEnabled(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda113 devicePolicyManagerService$$ExternalSyntheticLambda113 = new DevicePolicyManagerService$$ExternalSyntheticLambda113(this, componentName, userHandleGetCallingUserId, z);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda113);
        }
    }

    public final void sendActiveAdminCommand(String str, Bundle bundle, int i, ComponentName componentName, boolean z) {
        Intent intent = new Intent(str);
        intent.setComponent(componentName);
        if (bundle != null) {
            intent.putExtras(bundle);
        }
        if (z) {
            intent.addFlags(268435456);
        }
        this.mContext.sendBroadcastAsUser(intent, UserHandle.of(i));
    }

    public final void sendAdminCommandForLockscreenPoliciesLocked(int i, int i2, String str) {
        Bundle bundle = new Bundle();
        bundle.putParcelable("android.intent.extra.USER", UserHandle.of(i2));
        if (isSeparateProfileChallengeEnabled(i2)) {
            sendAdminCommandLocked(i, str, bundle, i2);
            return;
        }
        for (int i3 : this.mUserManager.getProfileIdsWithDisabled(i2)) {
            sendAdminCommandLocked(i, str, bundle, i3);
        }
    }

    public final void sendAdminCommandLocked(int i, String str, Bundle bundle, int i2) {
        DevicePolicyData userData = getUserData(i2);
        int size = userData.mAdminList.size();
        for (int i3 = 0; i3 < size; i3++) {
            ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminList.get(i3);
            if (activeAdmin.info.usesPolicy(i)) {
                sendAdminCommandLocked(activeAdmin, str, bundle, null, false);
            }
        }
    }

    public final boolean sendAdminCommandLocked(ActiveAdmin activeAdmin, String str, Bundle bundle, AnonymousClass4 anonymousClass4, boolean z) {
        Intent intent = new Intent(str);
        intent.setComponent(activeAdmin.info.getComponent());
        if (UserManager.isDeviceInDemoMode(this.mContext)) {
            intent.addFlags(268435456);
        }
        if (str.equals("android.app.action.ACTION_PASSWORD_EXPIRING")) {
            intent.putExtra("expiration", activeAdmin.passwordExpirationDate);
        }
        if (z) {
            intent.addFlags(268435456);
        }
        if (bundle != null) {
            intent.putExtras(bundle);
        }
        if (this.mInjector.mContext.getPackageManager().queryBroadcastReceiversAsUser(intent, 268435456, activeAdmin.getUserHandle()).isEmpty()) {
            return false;
        }
        BroadcastOptions makeBasic = BroadcastOptions.makeBasic();
        makeBasic.setBackgroundActivityStartsAllowed(true);
        if (anonymousClass4 != null) {
            this.mContext.sendOrderedBroadcastAsUser(intent, activeAdmin.getUserHandle(), null, -1, makeBasic.toBundle(), anonymousClass4, this.mHandler, -1, null, null);
        } else {
            this.mContext.sendBroadcastAsUser(intent, activeAdmin.getUserHandle(), null, makeBasic.toBundle());
        }
        return true;
    }

    public final void sendBugreportToDeviceOwner(Uri uri, String str) {
        synchronized (getLockObject()) {
            Intent intent = new Intent("android.app.action.BUGREPORT_SHARE");
            intent.setComponent(this.mOwners.getDeviceOwnerComponent());
            intent.setDataAndType(uri, "application/vnd.android.bugreport");
            intent.putExtra("android.app.extra.BUGREPORT_HASH", str);
            intent.setFlags(1);
            UriGrantsManagerInternal uriGrantsManagerInternal = (UriGrantsManagerInternal) LocalServices.getService(UriGrantsManagerInternal.class);
            UriGrantsManagerService.LocalService localService = (UriGrantsManagerService.LocalService) uriGrantsManagerInternal;
            ((UriGrantsManagerService.LocalService) uriGrantsManagerInternal).grantUriPermissionUncheckedFromIntent(localService.internalCheckGrantUriPermissionFromIntent(intent, 2000, this.mOwners.getDeviceOwnerComponent().getPackageName(), this.mOwners.getDeviceOwnerUserId(), null), null);
            this.mContext.sendBroadcastAsUser(intent, UserHandle.of(this.mOwners.getDeviceOwnerUserId()));
        }
    }

    public final void sendChangedNotification(int i, boolean z, boolean z2, boolean z3) {
        if (this.mNotifyChanges) {
            Intent intent = new Intent("android.app.action.DEVICE_POLICY_MANAGER_STATE_CHANGED");
            intent.setFlags(1073741824);
            if (z) {
                intent.putExtra("isBTChanged", z);
            }
            if (z2) {
                intent.putExtra("isWifiChanged", z2);
            }
            Bundle bundle = new BroadcastOptions().setDeliveryGroupPolicy(1).setDeferralPolicy(2).toBundle();
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda104 devicePolicyManagerService$$ExternalSyntheticLambda104 = new DevicePolicyManagerService$$ExternalSyntheticLambda104(this, z3, intent, i, bundle);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda104);
        }
    }

    public final void sendDelegationChangedBroadcast(int i, String str, ArrayList arrayList) {
        Intent intent = new Intent("android.app.action.APPLICATION_DELEGATION_SCOPES_CHANGED");
        intent.addFlags(1073741824);
        intent.setPackage(str);
        intent.putStringArrayListExtra("android.app.extra.DELEGATION_SCOPES", arrayList);
        this.mContext.sendBroadcastAsUser(intent, UserHandle.of(i));
    }

    public final void sendDeviceOwnerCommand(Bundle bundle, String str) {
        int deviceOwnerUserId;
        ComponentName deviceOwnerComponent;
        synchronized (getLockObject()) {
            deviceOwnerUserId = this.mOwners.getDeviceOwnerUserId();
            deviceOwnerComponent = this.mOwners.getDeviceOwnerComponent();
        }
        sendActiveAdminCommand(str, bundle, deviceOwnerUserId, deviceOwnerComponent, false);
    }

    /* JADX WARN: Removed duplicated region for block: B:11:0x0023  */
    /* JADX WARN: Removed duplicated region for block: B:14:0x0035  */
    /* JADX WARN: Removed duplicated region for block: B:16:0x0041  */
    /* JADX WARN: Removed duplicated region for block: B:20:0x003e  */
    /* JADX WARN: Removed duplicated region for block: B:21:0x002c  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void sendDeviceOwnerOrProfileOwnerCommand(int r9, java.lang.String r10, android.os.Bundle r11) {
        /*
            r8 = this;
            r0 = -1
            r1 = 0
            if (r9 != r0) goto L17
            boolean r9 = android.app.admin.flags.Flags.headlessDeviceOwnerDelegateSecurityLoggingBugFix()
            if (r9 == 0) goto L19
            int r9 = r8.getHeadlessDeviceOwnerModeForDeviceOwner()
            r0 = 2
            if (r9 != r0) goto L19
            com.android.server.devicepolicy.Owners r9 = r8.mOwners
            int r9 = r9.getDeviceOwnerUserId()
        L17:
            r5 = r9
            goto L1a
        L19:
            r5 = r1
        L1a:
            java.lang.String r9 = "android.app.action.NETWORK_LOGS_AVAILABLE"
            boolean r9 = r10.equals(r9)
            r0 = 1
            if (r9 == 0) goto L2c
            java.lang.String r9 = "delegation-network-logging"
            android.content.ComponentName r9 = r8.resolveDelegateReceiver(r5, r9, r10)
            r1 = r0
            goto L2d
        L2c:
            r9 = 0
        L2d:
            java.lang.String r2 = "android.app.action.SECURITY_LOGS_AVAILABLE"
            boolean r2 = r10.equals(r2)
            if (r2 == 0) goto L3e
            java.lang.String r9 = "delegation-security-logging"
            android.content.ComponentName r9 = r8.resolveDelegateReceiver(r5, r9, r10)
            r7 = r0
            goto L3f
        L3e:
            r7 = r1
        L3f:
            if (r9 != 0) goto L45
            android.content.ComponentName r9 = r8.getOwnerComponent(r5)
        L45:
            r6 = r9
            r2 = r8
            r3 = r10
            r4 = r11
            r2.sendActiveAdminCommand(r3, r4, r5, r6, r7)
            return
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.sendDeviceOwnerOrProfileOwnerCommand(int, java.lang.String, android.os.Bundle):void");
    }

    public final void sendLostModeLocationUpdate(AndroidFuture androidFuture) {
        if (!this.mHasFeature) {
            androidFuture.complete(Boolean.FALSE);
            return;
        }
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.TRIGGER_LOST_MODE"));
        synchronized (getLockObject()) {
            ActiveAdmin deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();
            Preconditions.checkState(deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked != null, "Lost mode location updates can only be sent on an organization-owned device.");
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda51 devicePolicyManagerService$$ExternalSyntheticLambda51 = new DevicePolicyManagerService$$ExternalSyntheticLambda51(this, deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked, androidFuture, 3);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda51);
        }
    }

    public final void sendOwnerChangedBroadcast(int i, String str) {
        this.mContext.sendBroadcastAsUser(new Intent(str).addFlags(16777216), UserHandle.of(i));
    }

    public final void sendProvisioningCompletedBroadcast(int i, String str, boolean z) {
        this.mContext.sendBroadcastAsUser(new Intent("android.app.action.PROVISIONING_COMPLETED").putExtra("android.intent.extra.user_handle", i).putExtra("android.intent.extra.USER", UserHandle.of(i)).putExtra("android.app.extra.PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED", z).putExtra("android.app.extra.PROVISIONING_ACTION", str).setPackage(this.mContext.getResources().getString(R.string.error_handwriting_unsupported)).addFlags(268435456), UserHandle.SYSTEM);
    }

    public final void sendResourceUpdatedBroadcast(int i, List list) {
        Intent intent = new Intent("android.app.action.DEVICE_POLICY_RESOURCE_UPDATED");
        intent.putExtra("android.app.extra.RESOURCE_IDS", (String[]) list.toArray(new DevicePolicyManagerService$$ExternalSyntheticLambda119(1)));
        intent.putExtra("android.app.extra.RESOURCE_TYPE", i);
        intent.setFlags(268435456);
        intent.setFlags(1073741824);
        List aliveUsers = this.mUserManager.getAliveUsers();
        for (int i2 = 0; i2 < aliveUsers.size(); i2++) {
            this.mContext.sendBroadcastAsUser(intent, ((UserInfo) aliveUsers.get(i2)).getUserHandle());
        }
    }

    public final void sendWipeProfileNotification(String str, UserHandle userHandle) {
        this.mInjector.getNotificationManager().notifyAsUser(null, 1001, new Notification.Builder(this.mContext, SystemNotificationChannels.DEVICE_ADMIN).setSmallIcon(R.drawable.stat_sys_warning).setContentTitle(getUpdatableString("Core.WORK_PROFILE_DELETED_TITLE", 17043633, new Object[0])).setContentText(str).setColor(this.mContext.getColor(R.color.system_notification_accent_color)).setStyle(new Notification.BigTextStyle().bigText(str)).build(), userHandle);
    }

    public final void setAccountManagementDisabled(ComponentName componentName, String str, String str2, boolean z, boolean z2) {
        if (this.mHasFeature) {
            if (!Flags.devicePolicySizeTrackingInternalBugFixEnabled()) {
                PolicySizeVerifier.enforceMaxStringLength(str2, "account type");
            }
            CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            synchronized (getLockObject()) {
                try {
                    int affectedUser = getAffectedUser(z2);
                    EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = enforcePermissionAndGetEnforcingAdmin(affectedUser, componentName, "android.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT", callerIdentity.mPackageName);
                    if (z) {
                        this.mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(str2), enforcePermissionAndGetEnforcingAdmin, new BooleanPolicyValue(z), affectedUser, false);
                    } else {
                        this.mDevicePolicyEngine.removeLocalPolicy(PolicyDefinition.ACCOUNT_MANAGEMENT_DISABLED(str2), enforcePermissionAndGetEnforcingAdmin, affectedUser);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    /* JADX WARN: Removed duplicated region for block: B:11:0x004e  */
    /* JADX WARN: Removed duplicated region for block: B:43:0x00bd  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void setActiveAdmin(final android.content.ComponentName r11, final boolean r12, final int r13) {
        /*
            r10 = this;
            boolean r0 = r10.mHasFeature
            if (r0 != 0) goto L5
            return
        L5:
            java.lang.String r0 = "Invalid userId"
            com.android.internal.util.Preconditions.checkArgumentNonnegative(r13, r0)
            r0 = 0
            com.android.server.devicepolicy.CallerIdentity r0 = r10.getCallerIdentity(r0, r0)
            java.lang.String r1 = "android.permission.MANAGE_DEVICE_ADMINS"
            boolean r1 = r10.hasCallingOrSelfPermission(r1)
            com.android.internal.util.Preconditions.checkCallAuthorization(r1)
            boolean r0 = r10.hasFullCrossUsersPermission(r0, r13)
            com.android.internal.util.Preconditions.checkCallAuthorization(r0)
            com.android.server.devicepolicy.DevicePolicyData r7 = r10.getUserData(r13)
            r0 = 1
            android.app.admin.DeviceAdminInfo r6 = r10.findAdmin(r13, r11, r0)
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r0 = r10.mInjector
            r0.getClass()
            com.android.server.devicepolicy.KnoxPolicyHelper r0 = r10.mKnoxPolicyHelper
            java.lang.String r1 = r11.getPackageName()
            r0.getClass()
            com.samsung.android.knox.restriction.IRestrictionPolicy r2 = r0.getService()     // Catch: android.os.RemoteException -> L43
            if (r2 == 0) goto L4b
            com.samsung.android.knox.restriction.IRestrictionPolicy r0 = r0.mRestrictionService     // Catch: android.os.RemoteException -> L43
            boolean r0 = r0.checkAdminActivationEnabled(r13, r1)     // Catch: android.os.RemoteException -> L43
            goto L4c
        L43:
            r0 = move-exception
            java.lang.String r1 = "KnoxPolicyHelper"
            java.lang.String r2 = "Failed talking with Restriction Policy"
            android.util.Log.w(r1, r2, r0)
        L4b:
            r0 = 0
        L4c:
            if (r0 == 0) goto Lbd
            java.lang.Object r0 = r10.getLockObject()
            monitor-enter(r0)
            checkActiveAdminPrecondition(r11, r6, r7)     // Catch: java.lang.Throwable -> Lba
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r8 = r10.mInjector     // Catch: java.lang.Throwable -> Lba
            com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda56 r9 = new com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda56     // Catch: java.lang.Throwable -> Lba
            r1 = r9
            r2 = r10
            r3 = r11
            r4 = r13
            r5 = r12
            r1.<init>()     // Catch: java.lang.Throwable -> Lba
            r8.getClass()     // Catch: java.lang.Throwable -> Lba
            android.os.Binder.withCleanCallingIdentity(r9)     // Catch: java.lang.Throwable -> Lba
            monitor-exit(r0)     // Catch: java.lang.Throwable -> Lba
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r12 = r10.mInjector
            r12.getClass()
            com.android.server.devicepolicy.KnoxPolicyHelper r12 = r10.mKnoxPolicyHelper
            r12.getClass()
            long r0 = android.os.Binder.clearCallingIdentity()
            com.samsung.android.knox.IEnterpriseDeviceManager r2 = r12.getIEDMService()     // Catch: java.lang.Throwable -> L85
            java.lang.String r3 = "KnoxPolicyHelper"
            if (r2 == 0) goto L8f
            com.samsung.android.knox.IEnterpriseDeviceManager r12 = r12.mEdmService     // Catch: java.lang.Throwable -> L85 java.lang.Exception -> L87
            r12.reconcileAdmin(r11, r13)     // Catch: java.lang.Throwable -> L85 java.lang.Exception -> L87
            goto L95
        L85:
            r10 = move-exception
            goto Lb6
        L87:
            r12 = move-exception
            java.lang.String r2 = "setActiveAdmin() : failed to call EDMS.reconcileAdmin()"
            android.util.Log.e(r3, r2, r12)     // Catch: java.lang.Throwable -> L85
            goto L95
        L8f:
            java.lang.String r12 = "setActiveAdmin() : passed EDMS.reconcileAdmin() because edms is null"
            android.util.Log.i(r3, r12)     // Catch: java.lang.Throwable -> L85
        L95:
            android.os.Binder.restoreCallingIdentity(r0)
            com.android.server.devicepolicy.AuditLogHelper r10 = r10.mAuditLogHelper
            java.lang.String r11 = r11.getPackageName()
            java.lang.Object[] r11 = new java.lang.Object[]{r11}
            r10.getClass()
            long r0 = android.os.Binder.clearCallingIdentity()
            r10 = 5
            android.sec.enterprise.auditlog.AuditLog.logEventAsUser(r13, r10, r11)     // Catch: java.lang.Throwable -> Lb1
            android.os.Binder.restoreCallingIdentity(r0)
            return
        Lb1:
            r10 = move-exception
            android.os.Binder.restoreCallingIdentity(r0)
            throw r10
        Lb6:
            android.os.Binder.restoreCallingIdentity(r0)
            throw r10
        Lba:
            r10 = move-exception
            monitor-exit(r0)     // Catch: java.lang.Throwable -> Lba
            throw r10
        Lbd:
            java.lang.IllegalArgumentException r10 = new java.lang.IllegalArgumentException
            java.lang.String r11 = "Admin cannot be activated"
            r10.<init>(r11)
            throw r10
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.setActiveAdmin(android.content.ComponentName, boolean, int):void");
    }

    public final void setAdminCanGrantSensorsPermissionForUserUnchecked(int i, boolean z) {
        Slogf.d("DevicePolicyManager", "setAdminCanGrantSensorsPermissionForUserUnchecked(%d, %b)", Integer.valueOf(i), Boolean.valueOf(z));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(i);
                Preconditions.checkState(isDeviceOwner(deviceOrProfileOwnerAdminLocked) && deviceOrProfileOwnerAdminLocked.getUserHandle().getIdentifier() == i, "May only be set on a the user of a device owner.");
                deviceOrProfileOwnerAdminLocked.mAdminCanGrantSensorsPermissions = z;
                this.mPolicyCache.mCanGrantSensorsPermissions = z;
                saveSettingsLocked(i, false, false, false);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setAffiliationIds(ComponentName componentName, List list) {
        boolean z;
        if (this.mHasFeature) {
            if (list == null) {
                throw new IllegalArgumentException("ids must not be null");
            }
            Iterator it = list.iterator();
            while (true) {
                z = true;
                if (!it.hasNext()) {
                    break;
                }
                String str = (String) it.next();
                Preconditions.checkArgument(true ^ TextUtils.isEmpty(str), "ids must not have empty string");
                PolicySizeVerifier.enforceMaxStringLength(str, "affiliation id");
            }
            ArraySet arraySet = new ArraySet(list);
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            if (!isProfileOwner(callerIdentity) && !isDefaultDeviceOwner(callerIdentity)) {
                z = false;
            }
            Preconditions.checkCallAuthorization(z);
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            synchronized (getLockObject()) {
                try {
                    getUserData(userId).mAffiliationIds = arraySet;
                    saveSettingsLocked(userId, false, false, false);
                    this.mStateCache.setHasAffiliationWithDevice(userId, Boolean.valueOf(isUserAffiliatedWithDeviceLocked(userId)));
                    if (userId == 0) {
                        Injector injector = this.mInjector;
                        DevicePolicyManagerService$$ExternalSyntheticLambda57 devicePolicyManagerService$$ExternalSyntheticLambda57 = new DevicePolicyManagerService$$ExternalSyntheticLambda57(6, this);
                        injector.getClass();
                        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda57);
                    } else if (userId != 0 && isDeviceOwner(userId, componentName)) {
                        getUserData(0).mAffiliationIds = arraySet;
                        this.mStateCache.setHasAffiliationWithDevice(0, Boolean.TRUE);
                        saveSettingsLocked(0, false, false, false);
                    }
                    maybePauseDeviceWideLoggingLocked();
                    boolean areAllUsersAffiliatedWithDeviceLocked = areAllUsersAffiliatedWithDeviceLocked();
                    boolean isOrganizationOwnedDeviceWithManagedProfile = isOrganizationOwnedDeviceWithManagedProfile();
                    Injector injector2 = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda158 devicePolicyManagerService$$ExternalSyntheticLambda158 = new DevicePolicyManagerService$$ExternalSyntheticLambda158(this, areAllUsersAffiliatedWithDeviceLocked, isOrganizationOwnedDeviceWithManagedProfile);
                    injector2.getClass();
                    Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda158);
                    Injector injector3 = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda57 devicePolicyManagerService$$ExternalSyntheticLambda572 = new DevicePolicyManagerService$$ExternalSyntheticLambda57(11, this);
                    injector3.getClass();
                    Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda572);
                    updateAdminCanGrantSensorsPermissionCache(userId);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final boolean setAlwaysOnVpnPackage(ComponentName componentName, String str, boolean z, List list) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        checkCanExecuteOrThrowUnsafe(30);
        if (str == null) {
            synchronized (getLockObject()) {
                try {
                    String str2 = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).mAlwaysOnVpnPackage;
                    if (TextUtils.isEmpty(str2)) {
                        return true;
                    }
                    int userId = UserHandle.getUserId(callerIdentity.mUid);
                    Injector injector = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda21 devicePolicyManagerService$$ExternalSyntheticLambda21 = new DevicePolicyManagerService$$ExternalSyntheticLambda21(this, str2, userId, 1);
                    injector.getClass();
                    Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda21);
                } finally {
                }
            }
        }
        int userId2 = UserHandle.getUserId(callerIdentity.mUid);
        Injector injector2 = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda104 devicePolicyManagerService$$ExternalSyntheticLambda104 = new DevicePolicyManagerService$$ExternalSyntheticLambda104(this, str, userId2, z, list);
        injector2.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda104);
        DevicePolicyEventLogger.createEvent(26).setAdmin(callerIdentity.mComponentName).setStrings(new String[]{str}).setBoolean(z).setInt(list != null ? list.size() : 0).write();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                if (TextUtils.equals(str, profileOwnerOrDeviceOwnerLocked.mAlwaysOnVpnPackage)) {
                    if (z != profileOwnerOrDeviceOwnerLocked.mAlwaysOnVpnLockdown) {
                    }
                }
                profileOwnerOrDeviceOwnerLocked.mAlwaysOnVpnPackage = str;
                profileOwnerOrDeviceOwnerLocked.mAlwaysOnVpnLockdown = z;
                saveSettingsLocked(userId2, false, false, false);
            } finally {
            }
        }
        return true;
    }

    public final void setApplicationExemptions(String str, final String str2, final int[] iArr) {
        boolean z;
        if (this.mHasFeature) {
            Preconditions.checkStringNotEmpty(str2, "Package name cannot be empty.");
            Objects.requireNonNull(iArr, "Application exemptions must not be null.");
            int length = iArr.length;
            int i = 0;
            while (true) {
                if (i >= length) {
                    z = true;
                    break;
                }
                if (!((ArrayMap) APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS).containsKey(Integer.valueOf(iArr[i]))) {
                    z = false;
                    break;
                }
                i++;
            }
            Preconditions.checkArgument(z, "Invalid application exemption constant found in application exemptions set.");
            Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_DEVICE_POLICY_APP_EXEMPTIONS"));
            CallerIdentity callerIdentity = getCallerIdentity(null, str);
            final AppOpsManager appOpsManager = this.mInjector.getAppOpsManager();
            this.mInjector.getClass();
            PackageManagerInternal packageManagerInternal = Injector.getPackageManagerInternal();
            int i2 = callerIdentity.mUid;
            final ApplicationInfo applicationInfo = packageManagerInternal.getApplicationInfo(i2, UserHandle.getUserId(i2), 0L, str2);
            if (applicationInfo == null) {
                throw new ServiceSpecificException(1, "Package name not found.");
            }
            final int i3 = applicationInfo.uid;
            Injector injector = this.mInjector;
            FunctionalUtils.ThrowingRunnable throwingRunnable = new FunctionalUtils.ThrowingRunnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda157
                public final void runOrThrow() {
                    final AppOpsManager appOpsManager2 = appOpsManager;
                    final int i4 = i3;
                    final String str3 = str2;
                    final int[] iArr2 = iArr;
                    final ApplicationInfo applicationInfo2 = applicationInfo;
                    ((ArrayMap) DevicePolicyManagerService.APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS).forEach(new BiConsumer() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda197
                        @Override // java.util.function.BiConsumer
                        public final void accept(Object obj, Object obj2) {
                            AppOpsManager appOpsManager3 = appOpsManager2;
                            int i5 = i4;
                            String str4 = str3;
                            int[] iArr3 = iArr2;
                            ApplicationInfo applicationInfo3 = applicationInfo2;
                            Integer num = (Integer) obj;
                            String str5 = (String) obj2;
                            int unsafeCheckOpNoThrow = appOpsManager3.unsafeCheckOpNoThrow(str5, i5, str4);
                            int i6 = ArrayUtils.contains(iArr3, num.intValue()) ? 0 : 3;
                            if (unsafeCheckOpNoThrow != i6) {
                                appOpsManager3.setMode(str5, i5, str4, i6);
                                if (Flags.powerExemptionBgUsageFix() && num.intValue() == 4 && i6 == 0) {
                                    appOpsManager3.setMode(70, applicationInfo3.uid, applicationInfo3.packageName, 0);
                                    if (applicationInfo3.targetSdkVersion < 26) {
                                        appOpsManager3.setMode(63, applicationInfo3.uid, applicationInfo3.packageName, 0);
                                    }
                                }
                            }
                        }
                    });
                }
            };
            injector.getClass();
            Binder.withCleanCallingIdentity(throwingRunnable);
            String[] strArr = new String[iArr.length];
            for (int i4 = 0; i4 < iArr.length; i4++) {
                strArr[i4] = (String) ((ArrayMap) APPLICATION_EXEMPTION_CONSTANTS_TO_APP_OPS).get(Integer.valueOf(iArr[i4]));
            }
            DevicePolicyEventLogger.createEvent(FrameworkStatsLog.DEVICE_POLICY_EVENT__EVENT_ID__SET_APPLICATION_EXEMPTIONS).setAdmin(callerIdentity.mPackageName).setStrings(str2, strArr).write();
        }
    }

    public final boolean setApplicationHidden(ComponentName componentName, String str, final String str2, final boolean z, boolean z2) {
        boolean booleanValue;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        final int profileParentId = z2 ? getProfileParentId(UserHandle.getUserId(callerIdentity.mUid)) : UserHandle.getUserId(callerIdentity.mUid);
        enforcePermission("android.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE", callerIdentity.mPackageName, profileParentId);
        if (((ArrayList) listPolicyExemptAppsUnchecked(this.mContext)).contains(str2)) {
            Slogf.d("DevicePolicyManager", "setApplicationHidden(): ignoring %s as it's on policy-exempt list", str2);
            return false;
        }
        synchronized (getLockObject()) {
            if (z2) {
                try {
                    Injector injector = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda21 devicePolicyManagerService$$ExternalSyntheticLambda21 = new DevicePolicyManagerService$$ExternalSyntheticLambda21(this, str2, profileParentId, 2);
                    injector.getClass();
                    Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda21);
                } catch (Throwable th) {
                    throw th;
                }
            }
            checkCanExecuteOrThrowUnsafe(15);
            EnforcingAdmin enforcingAdminForCaller = getEnforcingAdminForCaller(componentName, str);
            DevicePolicyEngine devicePolicyEngine = this.mDevicePolicyEngine;
            PolicyDefinition policyDefinition = PolicyDefinition.GENERIC_APPLICATION_HIDDEN;
            if (str2 != null) {
                policyDefinition = policyDefinition.createPolicyDefinition(new PackagePolicyKey("applicationHidden", str2));
            }
            devicePolicyEngine.setLocalPolicy(policyDefinition, enforcingAdminForCaller, new BooleanPolicyValue(z), profileParentId, false);
            Injector injector2 = this.mInjector;
            FunctionalUtils.ThrowingSupplier throwingSupplier = new FunctionalUtils.ThrowingSupplier() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda115
                public final Object getOrThrow() {
                    DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                    String str3 = str2;
                    int i = profileParentId;
                    boolean z3 = z;
                    devicePolicyManagerService.getClass();
                    try {
                        devicePolicyManagerService.mInjector.getClass();
                        return Boolean.valueOf(AppGlobals.getPackageManager().getPackageInfo(str3, 8192L, i) != null && devicePolicyManagerService.mIPackageManager.getApplicationHiddenSettingAsUser(str3, i) == z3);
                    } catch (RemoteException unused) {
                        return Boolean.FALSE;
                    }
                }
            };
            injector2.getClass();
            booleanValue = ((Boolean) Binder.withCleanCallingIdentity(throwingSupplier)).booleanValue();
        }
        DevicePolicyEventLogger.createEvent(63).setAdmin(callerIdentity.mPackageName).setBoolean(isCallerDelegate(callerIdentity)).setStrings(new String[]{str2, z ? "hidden" : "not_hidden", z2 ? "calledFromParent" : "notCalledFromParent"}).write();
        return booleanValue;
    }

    public final void setApplicationRestrictions(ComponentName componentName, String str, String str2, Bundle bundle, boolean z) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        checkCanExecuteOrThrowUnsafe(16);
        String validateName = FrameworkParsingPackageUtils.validateName(str2, false, false);
        if (validateName != null) {
            throw new IllegalArgumentException("Invalid package name: ".concat(validateName));
        }
        boolean z2 = true;
        if (Flags.dmrhSetAppRestrictions()) {
            if (componentName != null) {
                if (!isProfileOwner(callerIdentity) && !isDefaultDeviceOwner(callerIdentity)) {
                    z2 = false;
                }
                Preconditions.checkCallAuthorization(z2);
                Preconditions.checkCallAuthorization(!z, "DO or PO cannot call this on parent");
            } else {
                boolean doesCallerHoldRole = doesCallerHoldRole(callerIdentity, "android.app.role.DEVICE_POLICY_MANAGEMENT");
                if (z) {
                    Preconditions.checkCallAuthorization(doesCallerHoldRole);
                    Preconditions.checkState(isOrganizationOwnedDeviceWithManagedProfile(), "Role Holder can only operate parent app restriction on COPE devices");
                } else {
                    Preconditions.checkCallAuthorization(doesCallerHoldRole || isCallerDelegate(callerIdentity, "delegation-app-restrictions"));
                }
                r0 = doesCallerHoldRole;
            }
            if (r0) {
                EnforcingAdmin enforcingAdminForCaller = getEnforcingAdminForCaller(null, callerIdentity.mPackageName);
                int i = callerIdentity.mUid;
                int profileParentId = z ? getProfileParentId(UserHandle.getUserId(i)) : UserHandle.getUserId(i);
                if (bundle == null || bundle.isEmpty()) {
                    this.mDevicePolicyEngine.removeLocalPolicy(PolicyDefinition.APPLICATION_RESTRICTIONS(str2), enforcingAdminForCaller, profileParentId);
                } else {
                    this.mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.APPLICATION_RESTRICTIONS(str2), enforcingAdminForCaller, new BundlePolicyValue(bundle), profileParentId, false);
                }
            } else {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda44 devicePolicyManagerService$$ExternalSyntheticLambda44 = new DevicePolicyManagerService$$ExternalSyntheticLambda44(this, str2, bundle, callerIdentity, 0);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda44);
            }
        } else {
            if ((callerIdentity.hasAdminComponent() && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-app-restrictions"))) {
                r0 = true;
            }
            Preconditions.checkCallAuthorization(r0);
            Injector injector2 = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda44 devicePolicyManagerService$$ExternalSyntheticLambda442 = new DevicePolicyManagerService$$ExternalSyntheticLambda44(this, str2, bundle, callerIdentity, 1);
            injector2.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda442);
        }
        DevicePolicyEventLogger.createEvent(62).setAdmin(callerIdentity.mPackageName).setBoolean(isCallerDelegate(callerIdentity)).setStrings(new String[]{str2}).write();
    }

    public final void setApplicationRestrictionsMDM(ComponentName componentName, String str, Bundle bundle, int i) {
        String str2;
        String str3;
        KnoxPolicyHelper knoxPolicyHelper = this.mKnoxPolicyHelper;
        knoxPolicyHelper.getClass();
        ContextInfo contextInfo = new ContextInfo(Binder.getCallingUid(), i);
        knoxPolicyHelper.getEDM().enforceComponentCheck(contextInfo, componentName);
        knoxPolicyHelper.getEDM().enforceActiveAdminPermissionByContext(contextInfo, new ArrayList(Arrays.asList("com.samsung.android.knox.permission.KNOX_APP_MGMT")));
        int callingPid = Binder.getCallingPid();
        String str4 = "unidentified";
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                List runningAppProcesses = ActivityManager.getService().getRunningAppProcesses();
                if (runningAppProcesses != null && runningAppProcesses.size() > 0) {
                    Iterator it = runningAppProcesses.iterator();
                    while (true) {
                        if (!it.hasNext()) {
                            break;
                        }
                        ActivityManager.RunningAppProcessInfo runningAppProcessInfo = (ActivityManager.RunningAppProcessInfo) it.next();
                        if (runningAppProcessInfo.pid == callingPid && (str3 = runningAppProcessInfo.processName) != null) {
                            str4 = str3;
                            break;
                        }
                    }
                }
                str2 = str4.split(":")[0];
                Binder.restoreCallingIdentity(clearCallingIdentity);
            } catch (Exception e) {
                e.printStackTrace();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                str2 = str4;
            }
            clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                if (EdmConstants.APP_MANAGEMENT_SERVICE_PACKAGES.contains(str2) && EdmConstants.APP_RESTRICTIONS_PACKAGES.containsKey(str) && bundle.isEmpty()) {
                    KnoxsdkFileLog.d("KnoxPolicyHelper", "cPN: " + str2 + " may try to revoke an app restrictions to tPN: " + str);
                    ((ApplicationRestrictionsInternal) LocalServices.getService(ApplicationRestrictionsInternal.class)).setApplicationRestrictionsInternal(str, bundle, 0, true);
                }
                knoxPolicyHelper.mUserManager.setApplicationRestrictions(str, bundle, new UserHandle(i));
                Binder.restoreCallingIdentity(clearCallingIdentity);
            } finally {
            }
        } finally {
        }
    }

    public final boolean setApplicationRestrictionsManagingPackage(ComponentName componentName, String str) {
        try {
            setDelegatedScopePreO(componentName, str, "delegation-app-restrictions");
            return true;
        } catch (IllegalArgumentException unused) {
            return false;
        }
    }

    public final void setAuditLogEnabled(String str, boolean z) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(null, str);
            if (!Flags.securityLogV2Enabled()) {
                throw new UnsupportedOperationException("Audit log not enabled");
            }
            String str2 = callerIdentity.mPackageName;
            int i = callerIdentity.mUid;
            EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(i), null, "android.permission.MANAGE_DEVICE_POLICY_AUDIT_LOGGING", str2);
            if (z) {
                this.mDevicePolicyEngine.setGlobalPolicy(PolicyDefinition.AUDIT_LOGGING, enforcePermissionAndGetEnforcingAdmin, new BooleanPolicyValue(true));
            } else {
                this.mDevicePolicyEngine.removeGlobalPolicy(PolicyDefinition.AUDIT_LOGGING, enforcePermissionAndGetEnforcingAdmin);
                this.mSecurityLogMonitor.setAuditLogEventsCallback(i, null);
            }
        }
    }

    public final void setAuditLogEventsCallback(String str, IAuditLogEventsCallback iAuditLogEventsCallback) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(null, str);
            String str2 = callerIdentity.mPackageName;
            int i = callerIdentity.mUid;
            if (!Boolean.TRUE.equals((Boolean) this.mDevicePolicyEngine.getGlobalPolicySetByAdmin(PolicyDefinition.AUDIT_LOGGING, enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(i), null, "android.permission.MANAGE_DEVICE_POLICY_AUDIT_LOGGING", str2)))) {
                throw new IllegalStateException("Managing app has to enable audit log before setting events callback");
            }
            this.mSecurityLogMonitor.setAuditLogEventsCallback(i, iAuditLogEventsCallback);
        }
    }

    public final void setAutoTimeEnabled(ComponentName componentName, String str, boolean z) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda3 devicePolicyManagerService$$ExternalSyntheticLambda3 = new DevicePolicyManagerService$$ExternalSyntheticLambda3(2, this, z);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda3);
            DevicePolicyEventLogger.createEvent(127).setAdmin(callerIdentity.mPackageName).setBoolean(z).write();
        }
    }

    public final void setAutoTimeRequired(ComponentName componentName, boolean z) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                Preconditions.checkCallAuthorization(true ^ isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)), "Managed profile cannot set auto time required");
                setGlobalUserRestrictionInternal(getEnforcingAdminForCaller(componentName, componentName.getPackageName()), "no_config_date_time", z);
            }
            if (z) {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda57 devicePolicyManagerService$$ExternalSyntheticLambda57 = new DevicePolicyManagerService$$ExternalSyntheticLambda57(1, this);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda57);
            }
            DevicePolicyEventLogger.createEvent(36).setAdmin(componentName).setBoolean(z).write();
            this.mInjector.getClass();
            AuditLogHelper auditLogHelper = this.mAuditLogHelper;
            String format = String.format(z ? "Admin %s has enabled required automatic time." : "Admin %s has disabled required automatic time.", componentName.getPackageName());
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            auditLogHelper.getClass();
            AuditLogHelper.makeAuditLogGroupSecurity(userId, format);
        }
    }

    public final void setAutoTimeZoneEnabled(ComponentName componentName, String str, boolean z) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda3 devicePolicyManagerService$$ExternalSyntheticLambda3 = new DevicePolicyManagerService$$ExternalSyntheticLambda3(0, this, z);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda3);
            DevicePolicyEventLogger.createEvent(128).setAdmin(callerIdentity.mPackageName).setBoolean(z).write();
        }
    }

    public final void setBackupServiceEnabled(ComponentName componentName, boolean z) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity) || isFinancedDeviceOwner(callerIdentity));
            if (Flags.headlessSingleUserFixes() && isDeviceOwner(callerIdentity) && getHeadlessDeviceOwnerModeForDeviceOwner() == 2) {
                toggleBackupServiceActive(0, z);
            }
            toggleBackupServiceActive(UserHandle.getUserId(callerIdentity.mUid), z);
            if (Flags.backupServiceSecurityLogEventEnabled() && SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210044, new Object[]{callerIdentity.mPackageName, Integer.valueOf(UserHandle.getUserId(callerIdentity.mUid)), Integer.valueOf(z ? 1 : 0)});
            }
        }
    }

    public final void setBackwardCompatibleUserRestriction(CallerIdentity callerIdentity, EnforcingAdmin enforcingAdmin, String str, boolean z, boolean z2) {
        int i;
        synchronized (getLockObject()) {
            try {
                if (isDeviceOwner(callerIdentity)) {
                    i = 0;
                } else if (isProfileOwnerOfOrganizationOwnedDevice(callerIdentity)) {
                    i = 2;
                } else {
                    if (!isProfileOwner(callerIdentity)) {
                        throw new IllegalStateException("Non-DO/Non-PO cannot set restriction " + str + " while targetSdkVersion is less than UPSIDE_DOWN_CAKE");
                    }
                    i = 1;
                }
                setBackwardCompatibleUserRestrictionLocked(i, enforcingAdmin, UserHandle.getUserId(callerIdentity.mUid), str, z, z2);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setBackwardCompatibleUserRestrictionLocked(int i, EnforcingAdmin enforcingAdmin, int i2, String str, boolean z, boolean z2) {
        if (i == 0) {
            if (UserRestrictionsUtils.isGlobal(0, str)) {
                setGlobalUserRestrictionInternal(enforcingAdmin, str, z);
                return;
            } else {
                setLocalUserRestrictionInternal(enforcingAdmin, str, z, i2);
                return;
            }
        }
        if (i != 1 && i != 2) {
            throw new IllegalStateException(XmlUtils$$ExternalSyntheticOutline0.m("Non-DO/Non-PO cannot set restriction ", str, " while targetSdkVersion is less than UPSIDE_DOWN_CAKE"));
        }
        if (UserRestrictionsUtils.isGlobal(1, str) || (z2 && i == 2 && UserRestrictionsUtils.isGlobal(2, str))) {
            setGlobalUserRestrictionInternal(enforcingAdmin, str, z);
            return;
        }
        if (z2) {
            i2 = getProfileParentId(i2);
        }
        setLocalUserRestrictionInternal(enforcingAdmin, str, z, i2);
    }

    public final void setBluetoothContactSharingDisabled(ComponentName componentName, boolean z) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                    if (profileOwnerOrDeviceOwnerLocked.disableBluetoothContactSharing != z) {
                        profileOwnerOrDeviceOwnerLocked.disableBluetoothContactSharing = z;
                        saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            DevicePolicyEventLogger.createEvent(47).setAdmin(componentName).setBoolean(z).write();
        }
    }

    public final void setBypassDevicePolicyManagementRoleQualificationStateInternal(String str, boolean z) {
        boolean z2;
        DevicePolicyData userData = getUserData(0);
        boolean z3 = true;
        if (userData.mBypassDevicePolicyManagementRoleQualifications != z) {
            userData.mBypassDevicePolicyManagementRoleQualifications = z;
            z2 = true;
        } else {
            z2 = false;
        }
        if (Objects.equals(str, userData.mCurrentRoleHolder)) {
            z3 = z2;
        } else {
            userData.mCurrentRoleHolder = str;
        }
        if (z3) {
            synchronized (getLockObject()) {
                saveSettingsLocked(0, false, false, false);
            }
        }
    }

    public final void setCameraDisabled(ComponentName componentName, String str, boolean z, boolean z2) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            checkCanExecuteOrThrowUnsafe(31);
            int profileParentUserIfRequested = getProfileParentUserIfRequested(userId, z2);
            String str2 = callerIdentity.mPackageName;
            try {
                setBackwardCompatibleUserRestriction(callerIdentity, enforcePermissionAndGetEnforcingAdmin(profileParentUserIfRequested, componentName, "android.permission.MANAGE_DEVICE_POLICY_CAMERA", str2), "no_camera", z, z2);
                int profileParentId = z2 ? getProfileParentId(userId) : userId;
                if (SecurityLog.isLoggingEnabled() && componentName != null) {
                    SecurityLog.writeEvent(210034, new Object[]{componentName.getPackageName(), Integer.valueOf(userId), Integer.valueOf(profileParentId), Integer.valueOf(z ? 1 : 0)});
                }
                DevicePolicyEventLogger.createEvent(30).setAdmin(str2).setBoolean(z).setStrings(new String[]{z2 ? "calledFromParent" : "notCalledFromParent"}).write();
            } catch (IllegalStateException unused) {
                throw new IllegalStateException("Please use addUserRestriction or addUserRestrictionGlobally using the key UserManager.DISALLOW_CAMERA to disable the camera locally or globally, respectively");
            }
        }
    }

    public final void setCertInstallerPackage(ComponentName componentName, String str) {
        setDelegatedScopePreO(componentName, str, "delegation-cert-install");
        DevicePolicyEventLogger.createEvent(25).setAdmin(componentName).setStrings(new String[]{str}).write();
    }

    public final void setCommonCriteriaModeEnabled(ComponentName componentName, String str, boolean z) {
        ActiveAdmin profileOwnerOrDeviceOwnerLocked;
        ActiveAdmin activeAdmin;
        CallerIdentity callerIdentity = isPermissionCheckFlagEnabled() ? getCallerIdentity(componentName, str) : getCallerIdentity(componentName);
        boolean z2 = false;
        if (isPermissionCheckFlagEnabled()) {
            activeAdmin = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE", callerIdentity.mPackageName).mActiveAdmin;
        } else {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity), "Common Criteria mode can only be controlled by a device owner or a profile owner on an organization-owned device.");
            synchronized (getLockObject()) {
                profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
            }
            activeAdmin = profileOwnerOrDeviceOwnerLocked;
        }
        synchronized (getLockObject()) {
            activeAdmin.mCommonCriteriaMode = z;
            saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
        }
        DevicePolicyEventLogger.createEvent(131).setAdmin(callerIdentity.mPackageName).setBoolean(z).write();
        this.mInjector.getClass();
        this.mSecurityPolicyHelper.getClass();
        if (!MdfUtils.isMdfSupported()) {
            Log.d("DevicePolicyManager", "This model has not been certified MDFPP");
            return;
        }
        KnoxPolicyHelper knoxPolicyHelper = this.mKnoxPolicyHelper;
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        if (knoxPolicyHelper.getService() != null) {
            ContextInfo contextInfo = new ContextInfo(Binder.getCallingUid(), userId);
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                try {
                    z2 = knoxPolicyHelper.mRestrictionService.setCCModeOnlyForCallerSystem(contextInfo, z);
                } catch (RemoteException e) {
                    Log.e("KnoxPolicyHelper", "error. setCCModeOnlyForCallerSystem = " + e);
                }
                Log.d("KnoxPolicyHelper", "retSetCCMode = " + z2 + " userId = " + userId);
            } finally {
                Binder.restoreCallingIdentity(clearCallingIdentity);
            }
        }
    }

    public final void setConfiguredNetworksLockdownState(ComponentName componentName, String str, boolean z) {
        CallerIdentity callerIdentity;
        if (this.mHasFeature) {
            if (isPermissionCheckFlagEnabled()) {
                callerIdentity = getCallerIdentity(componentName, str);
                enforcePermission("android.permission.MANAGE_DEVICE_POLICY_WIFI", callerIdentity.mPackageName, -1);
            } else {
                CallerIdentity callerIdentity2 = getCallerIdentity(componentName);
                Preconditions.checkNotNull(componentName, "ComponentName is null");
                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity2) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity2));
                callerIdentity = callerIdentity2;
            }
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda3 devicePolicyManagerService$$ExternalSyntheticLambda3 = new DevicePolicyManagerService$$ExternalSyntheticLambda3(1, this, z);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda3);
            DevicePolicyEventLogger.createEvent(132).setAdmin(callerIdentity.mPackageName).setBoolean(z).write();
        }
    }

    public final void setContentProtectionPolicy(ComponentName componentName, String str, int i) {
        if (com.android.internal.hidden_from_bootclasspath.android.view.contentprotection.flags.Flags.manageDevicePolicyEnabled()) {
            int userId = UserHandle.getUserId(getCallerIdentity(componentName, str).mUid);
            checkCanExecuteOrThrowUnsafe(41);
            EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = enforcePermissionAndGetEnforcingAdmin(userId, componentName, "android.permission.MANAGE_DEVICE_POLICY_CONTENT_PROTECTION", str);
            if (i == 1) {
                this.mDevicePolicyEngine.removeLocalPolicy(PolicyDefinition.CONTENT_PROTECTION, enforcePermissionAndGetEnforcingAdmin, userId);
            } else {
                this.mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.CONTENT_PROTECTION, enforcePermissionAndGetEnforcingAdmin, new IntegerPolicyValue(i), userId, false);
            }
        }
    }

    public final void setCredentialManagerPolicy(PackagePolicy packagePolicy) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(null, null);
            Preconditions.checkCallAuthorization(canWriteCredentialManagerPolicy(callerIdentity));
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                    if (Objects.equals(profileOwnerOrDeviceOwnerLocked.mCredentialManagerPolicy, packagePolicy)) {
                        return;
                    }
                    profileOwnerOrDeviceOwnerLocked.mCredentialManagerPolicy = packagePolicy;
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setCrossProfileAppToIgnored(int i, String str) {
        this.mInjector.getClass();
        if (Binder.getCallingUid() != 1000) {
            return;
        }
        setCrossProfileAppToIgnored(str, i);
    }

    public final void setCrossProfileAppToIgnored(String str, int i) {
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                this.mInjector.getClass();
                this.mInjector.getClass();
            } catch (RemoteException unused) {
                Slogf.d("DevicePolicyManager", "RemoteException : setCrossProfileAppToIgnored " + str + " for user " + i);
            }
            if (SemPersonaManager.isSecureFolderId(i)) {
                return;
            }
            if (this.mUserManager.isManagedProfile(i)) {
                if (this.mIPackageManager.getPackageInfo(str, 0L, i) == null) {
                    return;
                }
                if (str != null && !str.contains("google")) {
                    ((CrossProfileApps) this.mInjector.mContext.getSystemService(CrossProfileApps.class)).setInteractAcrossProfilesAppOp(str, 1);
                }
            }
        } finally {
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final void setCrossProfileCalendarPackages(ComponentName componentName, List list) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).mCrossProfileCalendarPackages = list;
                saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
            }
            DevicePolicyEventLogger.createEvent(70).setAdmin(componentName).setStrings(list == null ? null : (String[]) list.toArray(new String[list.size()])).write();
        }
    }

    public final void setCrossProfileCallerIdDisabled(ComponentName componentName, boolean z) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                    if (z) {
                        profileOwnerLocked.mManagedProfileCallerIdAccess = new PackagePolicy(3);
                    } else {
                        profileOwnerLocked.mManagedProfileCallerIdAccess = new PackagePolicy(1);
                    }
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                } catch (Throwable th) {
                    throw th;
                }
            }
            DevicePolicyEventLogger.createEvent(46).setAdmin(componentName).setBoolean(z).write();
        }
    }

    public final void setCrossProfileContactsSearchDisabled(ComponentName componentName, boolean z) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                    if (z) {
                        profileOwnerLocked.mManagedProfileContactsAccess = new PackagePolicy(3);
                    } else {
                        profileOwnerLocked.mManagedProfileContactsAccess = new PackagePolicy(1);
                    }
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                } catch (Throwable th) {
                    throw th;
                }
            }
            DevicePolicyEventLogger.createEvent(45).setAdmin(componentName).setBoolean(z).write();
        }
    }

    public final void setCrossProfilePackages(ComponentName componentName, List list) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Objects.requireNonNull(list, "Package names is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                    List list2 = profileOwnerLocked.mCrossProfilePackages;
                    if (list.equals(list2)) {
                        return;
                    }
                    profileOwnerLocked.mCrossProfilePackages = list;
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    DevicePolicyEventLogger.createEvent(138).setAdmin(componentName).setStrings((String[]) list.toArray(new String[list.size()])).write();
                    CrossProfileApps crossProfileApps = (CrossProfileApps) this.mContext.createContextAsUser(UserHandle.getUserHandleForUid(callerIdentity.mUid), 0).getSystemService(CrossProfileApps.class);
                    Injector injector = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda51 devicePolicyManagerService$$ExternalSyntheticLambda51 = new DevicePolicyManagerService$$ExternalSyntheticLambda51(crossProfileApps, list2, list, 4);
                    injector.getClass();
                    Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda51);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setDefaultDialerApplication(String str) {
        if (this.mHasFeature && this.mHasTelephonyFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(null, null);
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda21 devicePolicyManagerService$$ExternalSyntheticLambda21 = new DevicePolicyManagerService$$ExternalSyntheticLambda21(this, str, userId, 4);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda21);
            synchronized (getLockObject()) {
                try {
                    if (isManagedProfile(userId)) {
                        Injector injector2 = this.mInjector;
                        DevicePolicyManagerService$$ExternalSyntheticLambda57 devicePolicyManagerService$$ExternalSyntheticLambda57 = new DevicePolicyManagerService$$ExternalSyntheticLambda57(10, this);
                        injector2.getClass();
                        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda57);
                    }
                    ActiveAdmin profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(userId);
                    if (!Objects.equals(profileOwnerOrDeviceOwnerLocked.mDialerPackage, str)) {
                        profileOwnerOrDeviceOwnerLocked.mDialerPackage = str;
                        saveSettingsLocked(userId, false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setDefaultSmsApplication(ComponentName componentName, String str, String str2, boolean z) {
        int userHandleGetCallingUserId;
        CallerIdentity callerIdentity = isPermissionCheckFlagEnabled() ? getCallerIdentity(componentName, str) : getCallerIdentity(componentName);
        if (isPermissionCheckFlagEnabled()) {
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_DEFAULT_SMS", callerIdentity.mPackageName, getAffectedUser(z));
        } else {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        }
        if (!z && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)) && getManagedSubscriptionsPolicy().getPolicyType() != 1) {
            throw new IllegalStateException("Default sms application can only be set on the profile, when ManagedSubscriptions policy is set");
        }
        if (z) {
            this.mInjector.getClass();
            userHandleGetCallingUserId = getProfileParentId(Injector.userHandleGetCallingUserId());
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda21 devicePolicyManagerService$$ExternalSyntheticLambda21 = new DevicePolicyManagerService$$ExternalSyntheticLambda21(this, str2, userHandleGetCallingUserId, 6);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda21);
        } else {
            this.mInjector.getClass();
            userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        }
        Injector injector2 = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda21 devicePolicyManagerService$$ExternalSyntheticLambda212 = new DevicePolicyManagerService$$ExternalSyntheticLambda21(this, str2, userHandleGetCallingUserId, 7);
        injector2.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda212);
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                Objects.requireNonNull(profileOwnerOrDeviceOwnerLocked);
                if (z) {
                    profileOwnerOrDeviceOwnerLocked = profileOwnerOrDeviceOwnerLocked.getParentActiveAdmin();
                }
                if (isManagedProfile(userHandleGetCallingUserId)) {
                    Injector injector3 = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda57 devicePolicyManagerService$$ExternalSyntheticLambda57 = new DevicePolicyManagerService$$ExternalSyntheticLambda57(13, this);
                    injector3.getClass();
                    Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda57);
                }
                if (!Objects.equals(profileOwnerOrDeviceOwnerLocked.mSmsPackage, str2)) {
                    profileOwnerOrDeviceOwnerLocked.mSmsPackage = str2;
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setDelegatedScopePreO(ComponentName componentName, String str, String str2) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userData = getUserData(UserHandle.getUserId(callerIdentity.mUid));
                if (str != null) {
                    List list = (List) userData.mDelegationMap.get(str);
                    if (list == null) {
                        list = new ArrayList();
                    }
                    if (!list.contains(str2)) {
                        list.add(str2);
                        setDelegatedScopes(componentName, str, list);
                    }
                }
                for (int i = 0; i < userData.mDelegationMap.size(); i++) {
                    String str3 = (String) userData.mDelegationMap.keyAt(i);
                    List list2 = (List) userData.mDelegationMap.valueAt(i);
                    if (!str3.equals(str) && list2.contains(str2)) {
                        ArrayList arrayList = new ArrayList(list2);
                        arrayList.remove(str2);
                        setDelegatedScopes(componentName, str3, arrayList);
                    }
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    /* JADX WARN: Removed duplicated region for block: B:23:0x00c9 A[Catch: all -> 0x00de, TryCatch #0 {all -> 0x00de, blocks: (B:16:0x008f, B:19:0x00b9, B:21:0x00bf, B:23:0x00c9, B:24:0x00e6, B:26:0x00eb, B:28:0x00f1, B:30:0x00fa, B:32:0x0110, B:34:0x0116, B:36:0x011c, B:37:0x0121, B:39:0x0129, B:43:0x012c, B:44:0x012f, B:47:0x00e0, B:48:0x0131, B:49:0x0147, B:50:0x009c, B:52:0x00a2, B:55:0x00b2), top: B:15:0x008f }] */
    /* JADX WARN: Removed duplicated region for block: B:26:0x00eb A[Catch: all -> 0x00de, TryCatch #0 {all -> 0x00de, blocks: (B:16:0x008f, B:19:0x00b9, B:21:0x00bf, B:23:0x00c9, B:24:0x00e6, B:26:0x00eb, B:28:0x00f1, B:30:0x00fa, B:32:0x0110, B:34:0x0116, B:36:0x011c, B:37:0x0121, B:39:0x0129, B:43:0x012c, B:44:0x012f, B:47:0x00e0, B:48:0x0131, B:49:0x0147, B:50:0x009c, B:52:0x00a2, B:55:0x00b2), top: B:15:0x008f }] */
    /* JADX WARN: Removed duplicated region for block: B:30:0x00fa A[Catch: all -> 0x00de, TryCatch #0 {all -> 0x00de, blocks: (B:16:0x008f, B:19:0x00b9, B:21:0x00bf, B:23:0x00c9, B:24:0x00e6, B:26:0x00eb, B:28:0x00f1, B:30:0x00fa, B:32:0x0110, B:34:0x0116, B:36:0x011c, B:37:0x0121, B:39:0x0129, B:43:0x012c, B:44:0x012f, B:47:0x00e0, B:48:0x0131, B:49:0x0147, B:50:0x009c, B:52:0x00a2, B:55:0x00b2), top: B:15:0x008f }] */
    /* JADX WARN: Removed duplicated region for block: B:47:0x00e0 A[Catch: all -> 0x00de, TryCatch #0 {all -> 0x00de, blocks: (B:16:0x008f, B:19:0x00b9, B:21:0x00bf, B:23:0x00c9, B:24:0x00e6, B:26:0x00eb, B:28:0x00f1, B:30:0x00fa, B:32:0x0110, B:34:0x0116, B:36:0x011c, B:37:0x0121, B:39:0x0129, B:43:0x012c, B:44:0x012f, B:47:0x00e0, B:48:0x0131, B:49:0x0147, B:50:0x009c, B:52:0x00a2, B:55:0x00b2), top: B:15:0x008f }] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void setDelegatedScopes(android.content.ComponentName r8, java.lang.String r9, java.util.List r10) {
        /*
            Method dump skipped, instructions count: 338
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.setDelegatedScopes(android.content.ComponentName, java.lang.String, java.util.List):void");
    }

    public final void setDemoDeviceStateUnchecked(int i, boolean z) {
        Slogf.d("DevicePolicyManager", "setDemoDeviceStateUnchecked(%d, %b)", Integer.valueOf(i), Boolean.valueOf(z));
        if (z) {
            synchronized (getLockObject()) {
                Injector injector = this.mInjector;
                Settings.Global.putStringForUser(injector.mContext.getContentResolver(), "device_demo_mode", Integer.toString(1), i);
            }
            setUserProvisioningState(3, i);
        }
    }

    public final boolean setDeviceOwner(ComponentName componentName, int i, boolean z) {
        int currentForegroundUserId;
        if (!this.mHasFeature) {
            logMissingFeatureAction("Cannot set " + ComponentName.flattenToShortString(componentName) + " as device owner for user " + i);
            return false;
        }
        Preconditions.checkArgument(componentName != null);
        this.mInjector.getClass();
        this.mInjector.getClass();
        if (!Injector.verifyDeviceIntegrity()) {
            Log.e("DevicePolicyManager", "Failed in device integrity check");
            return false;
        }
        this.mInjector.getClass();
        if (SystemProperties.getInt("ro.product.first_api_level", 0) >= 35) {
            Log.d("DevicePolicyManager::KnoxUtils", "DRK is not supported from V OS");
        } else {
            this.mInjector.getClass();
            if (!Injector.isDeviceRootKeyInstalled()) {
                Log.e("DevicePolicyManager", "Failed in (DRK)Device Root Key check");
                return false;
            }
        }
        if (!KnoxGuardManager.getInstance().isKGAllowDO()) {
            Log.e("DevicePolicyManager", "set device owner disabled by Knox Guard.");
            return false;
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        boolean z2 = !isAdb(callerIdentity) || hasIncompatibleAccountsOnAnyUser();
        if (!z2) {
            synchronized (getLockObject()) {
                try {
                    if (!isAdminTestOnlyLocked(i, componentName) && hasAccountsOnAnyUser()) {
                        Slogf.w("DevicePolicyManager", "Non test-only owner can't be installed with existing accounts.");
                        return false;
                    }
                } finally {
                }
            }
        }
        synchronized (getLockObject()) {
            try {
                enforceCanSetDeviceOwnerLocked(callerIdentity, componentName, i, z2);
                Preconditions.checkArgument(isPackageInstalledForUser(i, componentName.getPackageName()), "Invalid component " + componentName + " for device owner");
                ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                Preconditions.checkArgument((activeAdminUncheckedLocked == null || getUserData(i).mRemovingAdmins.contains(componentName)) ? false : true, "Not active admin: " + componentName);
                toggleBackupServiceActive(0, false);
                if (isAdb(callerIdentity)) {
                    MetricsLogger.action(this.mContext, 617, "device-owner");
                    DevicePolicyEventLogger.createEvent(82).setAdmin(componentName).setStrings(new String[]{"device-owner"}).write();
                }
                this.mOwners.setDeviceOwner(i, componentName);
                this.mOwners.writeDeviceOwner();
                setDeviceOwnershipSystemPropertyLocked();
                this.mInjector.getClass();
                if (isAdb(callerIdentity)) {
                    activeAdminUncheckedLocked.mAdminCanGrantSensorsPermissions = true;
                    this.mPolicyCache.mCanGrantSensorsPermissions = true;
                    saveSettingsLocked(i, false, false, false);
                }
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda30 devicePolicyManagerService$$ExternalSyntheticLambda30 = new DevicePolicyManagerService$$ExternalSyntheticLambda30(this, i, componentName, 1);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda30);
                this.mDeviceAdminServiceController.startServiceForAdmin(i, componentName.getPackageName());
                Slogf.i("DevicePolicyManager", "Device owner set: " + componentName + " on user " + i);
            } finally {
            }
        }
        if (z) {
            this.mInjector.getClass();
            if (UserManager.isHeadlessSystemUserMode() && getHeadlessDeviceOwnerModeForDeviceOwner() == 1) {
                synchronized (getLockObject()) {
                    currentForegroundUserId = getCurrentForegroundUserId();
                }
                Slogf.i("DevicePolicyManager", "setDeviceOwner(): setting " + componentName + " as profile owner on user " + currentForegroundUserId);
                manageUserUnchecked(componentName, componentName, currentForegroundUserId, null, false);
            }
        }
        return true;
    }

    public final void setDeviceOwnerLockScreenInfo(ComponentName componentName, CharSequence charSequence) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda46 devicePolicyManagerService$$ExternalSyntheticLambda46 = new DevicePolicyManagerService$$ExternalSyntheticLambda46(5, this, charSequence);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda46);
            DevicePolicyEventLogger.createEvent(42).setAdmin(callerIdentity.mComponentName).write();
        }
    }

    public final void setDeviceOwnerRemoteBugreportUriAndHash(String str, String str2) {
        synchronized (getLockObject()) {
            Owners owners = this.mOwners;
            synchronized (owners.mData) {
                try {
                    OwnersData.OwnerInfo ownerInfo = owners.mData.mDeviceOwner;
                    if (ownerInfo != null) {
                        ownerInfo.remoteBugreportUri = str;
                        ownerInfo.remoteBugreportHash = str2;
                    }
                    owners.writeDeviceOwner();
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setDeviceOwnerType(ComponentName componentName, int i) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        synchronized (getLockObject()) {
            setDeviceOwnerTypeLocked(i, componentName);
        }
    }

    public final void setDeviceOwnerTypeLocked(int i, ComponentName componentName) {
        String packageName = componentName.getPackageName();
        Preconditions.checkState(this.mOwners.hasDeviceOwner(), "there is no device owner");
        Preconditions.checkState(this.mOwners.getDeviceOwnerComponent().equals(componentName), "admin is not the device owner");
        boolean isAdminTestOnlyLocked = isAdminTestOnlyLocked(this.mOwners.getDeviceOwnerUserId(), componentName);
        Preconditions.checkState(isAdminTestOnlyLocked || !this.mOwners.isDeviceOwnerTypeSetForDeviceOwner(packageName), "Test only admins can only set the device owner type more than once");
        Owners owners = this.mOwners;
        synchronized (owners.mData) {
            try {
                if (!owners.hasDeviceOwner()) {
                    Slog.e("DevicePolicyManagerService", "Attempting to set a device owner type when there is no device owner");
                } else if (isAdminTestOnlyLocked || !owners.isDeviceOwnerTypeSetForDeviceOwner(packageName)) {
                    owners.mData.mDeviceOwnerTypes.put(packageName, Integer.valueOf(i));
                    owners.writeDeviceOwner();
                } else {
                    Slog.e("DevicePolicyManagerService", "Setting the device owner type more than once is only allowed for test only admins");
                }
            } finally {
            }
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda29 devicePolicyManagerService$$ExternalSyntheticLambda29 = new DevicePolicyManagerService$$ExternalSyntheticLambda29(i, 2, this);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda29);
    }

    public final void setDeviceOwnershipSystemPropertyLocked() {
        boolean z = this.mInjector.settingsGlobalGetInt("device_provisioned") != 0;
        boolean hasDeviceOwner = this.mOwners.hasDeviceOwner();
        boolean isOrganizationOwnedDeviceWithManagedProfile = isOrganizationOwnedDeviceWithManagedProfile();
        if (hasDeviceOwner || isOrganizationOwnedDeviceWithManagedProfile || z) {
            String bool = Boolean.toString(hasDeviceOwner || isOrganizationOwnedDeviceWithManagedProfile);
            this.mInjector.getClass();
            String str = SystemProperties.get("ro.organization_owned", (String) null);
            if (TextUtils.isEmpty(str)) {
                Slogf.i("DevicePolicyManager", "Set ro.organization_owned property to " + bool);
                this.mInjector.getClass();
                SystemProperties.set("ro.organization_owned", bool);
            } else if (!bool.equals(str)) {
                Slogf.w("DevicePolicyManager", "Cannot change existing ro.organization_owned to ".concat(bool));
            }
            this.mInjector.getClass();
            if (TextUtils.isEmpty(SystemProperties.get("persist.sys.knox.device_owner", (String) null))) {
                if (this.mOwners.hasDeviceOwner()) {
                    this.mInjector.getClass();
                    SystemProperties.set("persist.sys.knox.device_owner", "true");
                    this.mInjector.settingsGlobalPutInt("do_setup_complete", 1);
                    Slogf.i("DevicePolicyManager", "Set persist.sys.knox.device_owner property to true");
                    return;
                }
                this.mInjector.getClass();
                SystemProperties.set("persist.sys.knox.device_owner", "false");
                this.mInjector.settingsGlobalPutInt("do_setup_complete", 0);
                Slogf.i("DevicePolicyManager", "Set persist.sys.knox.device_owner property to false");
            }
        }
    }

    public final void setDevicePolicySafetyCheckerUnchecked(DevicePolicySafetyChecker devicePolicySafetyChecker) {
        Slogf.i("DevicePolicyManager", "Setting DevicePolicySafetyChecker as %s", devicePolicySafetyChecker);
        this.mSafetyChecker = devicePolicySafetyChecker;
        this.mInjector.mSafetyChecker = devicePolicySafetyChecker;
    }

    public final void setDeviceProvisioningConfigApplied() {
        getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
        synchronized (getLockObject()) {
            getUserData(0).mDeviceProvisioningConfigApplied = true;
            saveSettingsLocked(0, false, false, false);
        }
    }

    public final void setDpcDownloaded(boolean z) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, z ? 1 : 0, 9);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6);
    }

    public final void setDrawables(List list) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES"));
        Objects.requireNonNull(list, "drawables must be provided.");
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda25 devicePolicyManagerService$$ExternalSyntheticLambda25 = new DevicePolicyManagerService$$ExternalSyntheticLambda25(this, list, 1);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda25);
    }

    public final void setEndUserSessionMessage(ComponentName componentName, CharSequence charSequence) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
            String charSequence2 = charSequence != null ? charSequence.toString() : null;
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
                    if (TextUtils.equals(deviceOwnerAdminLocked.endUserSessionMessage, charSequence)) {
                        return;
                    }
                    deviceOwnerAdminLocked.endUserSessionMessage = charSequence2;
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    this.mInjector.getClass();
                    Injector.getActivityManagerInternal().setSwitchingToSystemUserMessage(charSequence2);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setExpirationAlarmCheckLocked(final Context context, final int i, final boolean z) {
        long j;
        final long j2;
        long passwordExpirationLocked = getPasswordExpirationLocked(i, null, z);
        long currentTimeMillis = System.currentTimeMillis();
        long j3 = passwordExpirationLocked - currentTimeMillis;
        if (passwordExpirationLocked == 0) {
            j2 = 0;
        } else {
            if (j3 <= 0) {
                j = MS_PER_DAY;
            } else {
                j = MS_PER_DAY;
                long j4 = j3 % j;
                if (j4 != 0) {
                    j = j4;
                }
            }
            j2 = currentTimeMillis + j;
        }
        Injector injector = this.mInjector;
        FunctionalUtils.ThrowingRunnable throwingRunnable = new FunctionalUtils.ThrowingRunnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda110
            public final void runOrThrow() {
                DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                boolean z2 = z;
                int i2 = i;
                Context context2 = context;
                long j5 = j2;
                if (z2) {
                    i2 = devicePolicyManagerService.getProfileParentId(i2);
                }
                AlarmManager alarmManager = (AlarmManager) devicePolicyManagerService.mInjector.mContext.getSystemService(AlarmManager.class);
                PendingIntent broadcastAsUser = PendingIntent.getBroadcastAsUser(context2, 5571, new Intent("com.android.server.ACTION_EXPIRED_PASSWORD_NOTIFICATION"), 1275068416, UserHandle.of(i2));
                alarmManager.cancel(broadcastAsUser);
                if (j5 != 0) {
                    alarmManager.set(1, j5, broadcastAsUser);
                }
            }
        };
        injector.getClass();
        Binder.withCleanCallingIdentity(throwingRunnable);
    }

    public final void setFactoryResetProtectionPolicy(ComponentName componentName, String str, FactoryResetProtectionPolicy factoryResetProtectionPolicy) {
        if (this.mHasFeature) {
            if (!isPermissionCheckFlagEnabled()) {
                Preconditions.checkNotNull(componentName, "ComponentName is null");
            }
            CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            if (!isPermissionCheckFlagEnabled()) {
                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
            }
            checkCanExecuteOrThrowUnsafe(32);
            int frpManagementAgentUid = getFrpManagementAgentUid();
            if (frpManagementAgentUid == -1) {
                throw new UnsupportedOperationException("The persistent data block service is not supported on this device");
            }
            synchronized (getLockObject()) {
                try {
                    (isPermissionCheckFlagEnabled() ? enforcePermissionAndGetEnforcingAdmin(-1, componentName, "android.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET", callerIdentity.mPackageName).mActiveAdmin : getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid))).mFactoryResetProtectionPolicy = factoryResetProtectionPolicy;
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                } catch (Throwable th) {
                    throw th;
                }
            }
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda29 devicePolicyManagerService$$ExternalSyntheticLambda29 = new DevicePolicyManagerService$$ExternalSyntheticLambda29(frpManagementAgentUid, 6, this);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda29);
            DevicePolicyEventLogger.createEvent(130).setAdmin(callerIdentity.mPackageName).write();
        }
    }

    public final void setForceEphemeralUsers(ComponentName componentName, boolean z) {
        throw new UnsupportedOperationException("This method was used by split system user only.");
    }

    public final int setGlobalPrivateDns(ComponentName componentName, int i, String str) {
        if (!this.mHasFeature) {
            return 2;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        Preconditions.checkCallAuthorization(areAllUsersAffiliatedWithDeviceLocked(), "operation not allowed when device has unaffiliated users");
        checkCanExecuteOrThrowUnsafe(33);
        if (i == 2) {
            if (!TextUtils.isEmpty(str)) {
                throw new IllegalArgumentException("Host provided for opportunistic mode, but is not needed.");
            }
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda21 devicePolicyManagerService$$ExternalSyntheticLambda21 = new DevicePolicyManagerService$$ExternalSyntheticLambda21(2, this, null);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda21);
            return 0;
        }
        if (i != 3) {
            throw new IllegalArgumentException(String.format("Provided mode, %d, is not a valid mode.", Integer.valueOf(i)));
        }
        if (TextUtils.isEmpty(str) || !NetworkUtilsInternal.isWeaklyValidatedHostname(str)) {
            throw new IllegalArgumentException(XmlUtils$$ExternalSyntheticOutline0.m("Provided hostname ", str, " is not valid"));
        }
        Injector injector2 = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda21 devicePolicyManagerService$$ExternalSyntheticLambda212 = new DevicePolicyManagerService$$ExternalSyntheticLambda21(3, this, str);
        injector2.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda212);
        return 0;
    }

    public final ComponentName setGlobalProxy(ComponentName componentName, String str, String str2) {
        if (!this.mHasFeature) {
            return null;
        }
        synchronized (getLockObject()) {
            try {
                Objects.requireNonNull(componentName, "ComponentName is null");
                DevicePolicyData userData = getUserData(0);
                ActiveAdmin activeAdminForCallerLocked = getActiveAdminForCallerLocked(5, componentName);
                for (ComponentName componentName2 : userData.mAdminMap.keySet()) {
                    if (((ActiveAdmin) userData.mAdminMap.get(componentName2)).specifiesGlobalProxy && !componentName2.equals(componentName)) {
                        return componentName2;
                    }
                }
                if (UserHandle.getCallingUserId() != 0) {
                    Slogf.w("DevicePolicyManager", "Only the owner is allowed to set the global proxy. User " + UserHandle.getCallingUserId() + " is not permitted.");
                    return null;
                }
                if (str == null) {
                    activeAdminForCallerLocked.specifiesGlobalProxy = false;
                    activeAdminForCallerLocked.globalProxySpec = null;
                    activeAdminForCallerLocked.globalProxyExclusionList = null;
                } else {
                    activeAdminForCallerLocked.specifiesGlobalProxy = true;
                    activeAdminForCallerLocked.globalProxySpec = str;
                    activeAdminForCallerLocked.globalProxyExclusionList = str2;
                }
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda46 devicePolicyManagerService$$ExternalSyntheticLambda46 = new DevicePolicyManagerService$$ExternalSyntheticLambda46(7, this, userData);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda46);
                return null;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setGlobalSetting(ComponentName componentName, final String str, final String str2) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        if ("allow_work_profile_telephony_for_non_dpm_role_holders".equals(str)) {
            Preconditions.checkCallAuthorization(doesCallerHoldRole(callerIdentity, "android.app.role.DEVICE_POLICY_MANAGEMENT"));
            Injector injector = this.mInjector;
            final int i = 0;
            FunctionalUtils.ThrowingRunnable throwingRunnable = new FunctionalUtils.ThrowingRunnable(this) { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda13
                public final /* synthetic */ DevicePolicyManagerService f$0;

                {
                    this.f$0 = this;
                }

                public final void runOrThrow() {
                    switch (i) {
                        case 0:
                            DevicePolicyManagerService devicePolicyManagerService = this.f$0;
                            Settings.Global.putString(devicePolicyManagerService.mInjector.mContext.getContentResolver(), str, str2);
                            break;
                        default:
                            DevicePolicyManagerService devicePolicyManagerService2 = this.f$0;
                            Settings.Global.putString(devicePolicyManagerService2.mInjector.mContext.getContentResolver(), str, str2);
                            break;
                    }
                }
            };
            injector.getClass();
            Binder.withCleanCallingIdentity(throwingRunnable);
            return;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
        DevicePolicyEventLogger.createEvent(111).setAdmin(componentName).setStrings(new String[]{str, str2}).write();
        synchronized (getLockObject()) {
            try {
                if (((ArraySet) GLOBAL_SETTINGS_DEPRECATED).contains(str)) {
                    Slogf.i("DevicePolicyManager", "Global setting no longer supported: %s", str);
                    return;
                }
                if (!((ArraySet) GLOBAL_SETTINGS_ALLOWLIST).contains(str) && !UserManager.isDeviceInDemoMode(this.mContext)) {
                    throw new SecurityException(String.format("Permission denial: device owners cannot update %1$s", str));
                }
                if ("stay_on_while_plugged_in".equals(str)) {
                    this.mInjector.getClass();
                    long maximumTimeToLock = getMaximumTimeToLock(componentName, Injector.userHandleGetCallingUserId(), false);
                    if (maximumTimeToLock > 0 && maximumTimeToLock < Long.MAX_VALUE) {
                        return;
                    }
                }
                Injector injector2 = this.mInjector;
                final int i2 = 1;
                FunctionalUtils.ThrowingRunnable throwingRunnable2 = new FunctionalUtils.ThrowingRunnable(this) { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda13
                    public final /* synthetic */ DevicePolicyManagerService f$0;

                    {
                        this.f$0 = this;
                    }

                    public final void runOrThrow() {
                        switch (i2) {
                            case 0:
                                DevicePolicyManagerService devicePolicyManagerService = this.f$0;
                                Settings.Global.putString(devicePolicyManagerService.mInjector.mContext.getContentResolver(), str, str2);
                                break;
                            default:
                                DevicePolicyManagerService devicePolicyManagerService2 = this.f$0;
                                Settings.Global.putString(devicePolicyManagerService2.mInjector.mContext.getContentResolver(), str, str2);
                                break;
                        }
                    }
                };
                injector2.getClass();
                Binder.withCleanCallingIdentity(throwingRunnable2);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setGlobalUserRestrictionInternal(EnforcingAdmin enforcingAdmin, String str, boolean z) {
        PolicyDefinition policyDefinitionForUserRestriction = PolicyDefinition.getPolicyDefinitionForUserRestriction(str);
        if (z) {
            this.mDevicePolicyEngine.setGlobalPolicy(PolicyDefinition.getPolicyDefinitionForUserRestriction(str), enforcingAdmin, new BooleanPolicyValue(true));
        } else {
            this.mDevicePolicyEngine.removeGlobalPolicy(policyDefinitionForUserRestriction, enforcingAdmin);
        }
    }

    public final void setKeepUninstalledPackages(ComponentName componentName, String str, List list) {
        if (this.mHasFeature) {
            Objects.requireNonNull(list, "packageList is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && isDefaultDeviceOwner(callerIdentity)) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-keep-uninstalled-packages")));
            checkCanExecuteOrThrowUnsafe(17);
            synchronized (getLockObject()) {
                getDeviceOwnerAdminLocked().keepUninstalledPackages = list;
                saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                this.mInjector.getClass();
                PackageManagerService packageManagerService = ((PackageManagerService.PackageManagerInternalImpl) Injector.getPackageManagerInternal()).mService;
                packageManagerService.setKeepUninstalledPackagesInternal(packageManagerService.snapshotComputer(), list);
            }
            DevicePolicyEventLogger.createEvent(61).setAdmin(callerIdentity.mPackageName).setBoolean(componentName == null).setStrings((String[]) list.toArray(new String[0])).write();
        }
    }

    public final boolean setKeyChainGrantInternal(String str, boolean z, int i, UserHandle userHandle) {
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                KeyChain.KeyChainConnection bindAsUser = KeyChain.bindAsUser(this.mContext, userHandle);
                try {
                    boolean grant = bindAsUser.getService().setGrant(i, str, z);
                    bindAsUser.close();
                    return grant;
                } catch (Throwable th) {
                    if (bindAsUser != null) {
                        try {
                            bindAsUser.close();
                        } catch (Throwable th2) {
                            th.addSuppressed(th2);
                        }
                    }
                    throw th;
                }
            } catch (RemoteException | AssertionError e) {
                Slogf.e("DevicePolicyManager", "Setting grant for package.", e);
                return false;
            }
        } catch (InterruptedException e2) {
            Slogf.w("DevicePolicyManager", "Interrupted while setting key grant", e2);
            Thread.currentThread().interrupt();
            return false;
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final boolean setKeyGrantForApp(ComponentName componentName, String str, String str2, String str3, boolean z) {
        Preconditions.checkStringNotEmpty(str2, "Alias to grant cannot be empty");
        Preconditions.checkStringNotEmpty(str3, "Package to grant to cannot be empty");
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        boolean hasAdminComponent = callerIdentity.hasAdminComponent();
        int i = callerIdentity.mUid;
        boolean z2 = true;
        Preconditions.checkCallAuthorization((hasAdminComponent && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-cert-selection")));
        try {
            this.mInjector.getClass();
            ApplicationInfo applicationInfo = AppGlobals.getPackageManager().getApplicationInfo(str3, 0L, UserHandle.getUserId(i));
            if (applicationInfo == null) {
                z2 = false;
            }
            Preconditions.checkArgument(z2, "Provided package %s is not installed", new Object[]{str3});
            try {
                return setKeyChainGrantInternal(str2, z, applicationInfo.uid, UserHandle.getUserHandleForUid(i));
            } catch (IllegalArgumentException e) {
                Injector injector = this.mInjector;
                int userId = UserHandle.getUserId(i);
                injector.getClass();
                if (Injector.isChangeEnabled(userId, str, 175101461L)) {
                    throw e;
                }
                return false;
            }
        } catch (RemoteException e2) {
            throw new IllegalStateException("Failure getting grantee uid", e2);
        }
    }

    public final boolean setKeyGrantToWifiAuth(String str, String str2, boolean z) {
        Preconditions.checkStringNotEmpty(str2, "Alias to grant cannot be empty");
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        Preconditions.checkCallAuthorization(canChooseCertificates(callerIdentity));
        try {
            return setKeyChainGrantInternal(str2, z, 1010, UserHandle.getUserHandleForUid(callerIdentity.mUid));
        } catch (IllegalArgumentException e) {
            Injector injector = this.mInjector;
            String str3 = callerIdentity.mPackageName;
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            injector.getClass();
            if (Injector.isChangeEnabled(userId, str3, 175101461L)) {
                throw e;
            }
            return false;
        }
    }

    public final boolean setKeyPairCertificate(ComponentName componentName, String str, String str2, byte[] bArr, byte[] bArr2, boolean z) {
        Injector injector;
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        boolean isCallerDelegate = isCallerDelegate(callerIdentity, "delegation-cert-install");
        boolean isCredentialManagementApp = isCredentialManagementApp(callerIdentity);
        boolean isPermissionCheckFlagEnabled = isPermissionCheckFlagEnabled();
        String str3 = callerIdentity.mPackageName;
        int i = callerIdentity.mUid;
        if (isPermissionCheckFlagEnabled) {
            Preconditions.checkCallAuthorization(hasPermission("android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES", str3, UserHandle.getUserId(i)) || isCredentialManagementApp);
        } else {
            Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && (isCallerDelegate || isCredentialManagementApp)));
        }
        if (isCredentialManagementApp) {
            Preconditions.checkCallAuthorization(isAliasInCredentialManagementAppPolicy(callerIdentity, str2), "The alias provided must be contained in the aliases specified in the credential management app's authentication policy");
        }
        Bundle bundle = new Bundle();
        bundle.putInt("userId", UserHandle.getUserId(i));
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                try {
                    KeyChain.KeyChainConnection bindAsUser = KeyChain.bindAsUser(this.mContext, UserHandle.getUserHandleForUid(i));
                    try {
                        IKeyChainService service = bindAsUser.getService();
                        if (!service.setKeyPairCertificate(str2, bArr, bArr2)) {
                            bindAsUser.close();
                            return false;
                        }
                        service.setUserSelectable(str2, z);
                        DevicePolicyEventLogger.createEvent(60).setAdmin(str3).setBoolean(isCallerDelegate).setStrings(new String[]{isCredentialManagementApp ? "credentialManagementApp" : "notCredentialManagementApp"}).setKnoxBundleValue(bundle).write();
                        bindAsUser.close();
                        return true;
                    } catch (Throwable th) {
                        if (bindAsUser != null) {
                            try {
                                bindAsUser.close();
                            } catch (Throwable th2) {
                                th.addSuppressed(th2);
                            }
                        }
                        throw th;
                    }
                } catch (RemoteException | AssertionError e) {
                    Slogf.e("DevicePolicyManager", "Failed setting keypair certificate", e);
                    injector = this.mInjector;
                    injector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    return false;
                }
            } catch (InterruptedException e2) {
                Slogf.w("DevicePolicyManager", "Interrupted while setting keypair certificate", e2);
                Thread.currentThread().interrupt();
                injector = this.mInjector;
                injector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                return false;
            }
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final boolean setKeyguardDisabled(ComponentName componentName, boolean z) {
        Injector injector;
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        synchronized (getLockObject()) {
            Preconditions.checkCallAuthorization(isUserAffiliatedWithDeviceLocked(userId), "Admin " + componentName + " is neither the device owner or affiliated user's profile owner.");
        }
        if (isManagedProfile(userId)) {
            throw new SecurityException("Managed profile cannot disable keyguard");
        }
        checkCanExecuteOrThrowUnsafe(12);
        Bundle bundle = new Bundle();
        bundle.putInt("userId", userId);
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        if (z) {
            try {
                if (this.mLockPatternUtils.isSecure(userId)) {
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    return false;
                }
            } catch (RemoteException unused) {
                injector = this.mInjector;
            } catch (Throwable th) {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                throw th;
            }
        }
        this.mLockPatternUtils.setLockScreenDisabled(z, userId);
        if (z) {
            this.mInjector.getClass();
            IWindowManager.Stub.asInterface(ServiceManager.getService("window")).dismissKeyguard((IKeyguardDismissCallback) null, (CharSequence) null);
        }
        DevicePolicyEventLogger.createEvent(37).setAdmin(componentName).setBoolean(z).setKnoxBundleValue(bundle).write();
        injector = this.mInjector;
        injector.getClass();
        Binder.restoreCallingIdentity(clearCallingIdentity);
        return true;
    }

    public final void setKeyguardDisabledFeatures(ComponentName componentName, String str, int i, boolean z) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Objects.requireNonNull(componentName, "ComponentName is null");
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            int profileParentId = z ? getProfileParentId(userId) : userId;
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 9, z);
                    if (isManagedProfile(userId)) {
                        i = z ? isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) ? i & 951 : i & FrameworkStatsLog.HOTWORD_DETECTION_SERVICE_RESTARTED : i & FrameworkStatsLog.APP_BACKGROUND_RESTRICTIONS_INFO;
                    }
                    if (activeAdminOrCheckPermissionForCallerLocked.disabledKeyguardFeatures != i) {
                        activeAdminOrCheckPermissionForCallerLocked.disabledKeyguardFeatures = i;
                        saveSettingsLocked(userId, false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210021, new Object[]{callerIdentity.mPackageName, Integer.valueOf(userId), Integer.valueOf(profileParentId), Integer.valueOf(i)});
            }
            DevicePolicyEventLogger.createEvent(9).setAdmin(callerIdentity.mPackageName).setInt(i).setStrings(new String[]{z ? "calledFromParent" : "notCalledFromParent"}).write();
        }
    }

    public final void setKeyguardDisabledFeaturesMDM(ComponentName componentName, int i, int i2) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(9, i2, componentName);
                    if (activeAdminForCallerLockedMDM.disabledKeyguardFeatures != i) {
                        activeAdminForCallerLockedMDM.disabledKeyguardFeatures = i;
                        saveSettingsLocked(i2, false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210021, new Object[]{componentName.getPackageName(), Integer.valueOf(i2), Integer.valueOf(i2), Integer.valueOf(i)});
            }
        }
    }

    public final void setLocalUserRestrictionInternal(EnforcingAdmin enforcingAdmin, String str, boolean z, int i) {
        PolicyDefinition policyDefinitionForUserRestriction = PolicyDefinition.getPolicyDefinitionForUserRestriction(str);
        if (z) {
            this.mDevicePolicyEngine.setLocalPolicy(policyDefinitionForUserRestriction, enforcingAdmin, new BooleanPolicyValue(true), i, false);
        } else {
            this.mDevicePolicyEngine.removeLocalPolicy(policyDefinitionForUserRestriction, enforcingAdmin, i);
        }
    }

    public final void setLocationEnabled(ComponentName componentName, final boolean z) {
        Preconditions.checkNotNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
        final UserHandle userHandleForUid = UserHandle.getUserHandleForUid(callerIdentity.mUid);
        if (this.mIsAutomotive && !z) {
            Slogf.i("DevicePolicyManager", "setLocationEnabled(%s, %b): ignoring for user %s on automotive build", componentName.flattenToShortString(), Boolean.valueOf(z), userHandleForUid);
            return;
        }
        Injector injector = this.mInjector;
        FunctionalUtils.ThrowingRunnable throwingRunnable = new FunctionalUtils.ThrowingRunnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda41
            public final void runOrThrow() {
                DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                UserHandle userHandle = userHandleForUid;
                boolean z2 = z;
                boolean isLocationEnabledForUser = ((LocationManager) devicePolicyManagerService.mInjector.mContext.getSystemService(LocationManager.class)).isLocationEnabledForUser(userHandle);
                Slogf.v("DevicePolicyManager", "calling locationMgr.setLocationEnabledForUser(%b, %s) when it was %b", Boolean.valueOf(z2), userHandle, Boolean.valueOf(isLocationEnabledForUser));
                ((LocationManager) devicePolicyManagerService.mInjector.mContext.getSystemService(LocationManager.class)).setLocationEnabledForUser(z2, userHandle);
                if (!z2 || isLocationEnabledForUser) {
                    return;
                }
                devicePolicyManagerService.showLocationSettingsEnabledNotification(userHandle);
            }
        };
        injector.getClass();
        Binder.withCleanCallingIdentity(throwingRunnable);
        DevicePolicyEventLogger.createEvent(14).setAdmin(componentName).setStrings(new String[]{"location_mode", Integer.toString(z ? 3 : 0)}).write();
    }

    public final void setLockTaskFeatures(ComponentName componentName, String str, int i) {
        EnforcingAdmin enforceCanCallLockTaskLocked;
        LockTaskPolicy lockTaskPolicy;
        boolean z = (i & 4) != 0;
        Preconditions.checkArgument(z || !((i & 8) != 0), "Cannot use LOCK_TASK_FEATURE_OVERVIEW without LOCK_TASK_FEATURE_HOME");
        Preconditions.checkArgument(z || !((i & 2) != 0), "Cannot use LOCK_TASK_FEATURE_NOTIFICATIONS without LOCK_TASK_FEATURE_HOME");
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        synchronized (getLockObject()) {
            checkCanExecuteOrThrowUnsafe(18);
        }
        synchronized (getLockObject()) {
            enforceCanCallLockTaskLocked = enforceCanCallLockTaskLocked(componentName, callerIdentity.mPackageName);
            if (isFinancedDeviceOwner(callerIdentity) && (i & (-120)) != 0) {
                throw new SecurityException("Permitted lock task features when managing a financed device: LOCK_TASK_FEATURE_SYSTEM_INFO, LOCK_TASK_FEATURE_KEYGUARD, LOCK_TASK_FEATURE_HOME, LOCK_TASK_FEATURE_GLOBAL_ACTIONS, LOCK_TASK_FEATURE_NOTIFICATIONS or LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK");
            }
        }
        DevicePolicyEngine devicePolicyEngine = this.mDevicePolicyEngine;
        PolicyDefinition policyDefinition = PolicyDefinition.LOCK_TASK;
        LockTaskPolicy lockTaskPolicy2 = (LockTaskPolicy) devicePolicyEngine.getLocalPolicySetByAdmin(policyDefinition, enforceCanCallLockTaskLocked, UserHandle.getUserId(callerIdentity.mUid));
        if (lockTaskPolicy2 == null) {
            lockTaskPolicy = new LockTaskPolicy(i);
        } else {
            LockTaskPolicy lockTaskPolicy3 = new LockTaskPolicy(lockTaskPolicy2);
            lockTaskPolicy3.setFlags(i);
            lockTaskPolicy = lockTaskPolicy3;
        }
        if (lockTaskPolicy.getPackages().isEmpty() && lockTaskPolicy.getFlags() == 0) {
            this.mDevicePolicyEngine.removeLocalPolicy(policyDefinition, enforceCanCallLockTaskLocked, UserHandle.getUserId(callerIdentity.mUid));
        } else {
            this.mDevicePolicyEngine.setLocalPolicy(policyDefinition, enforceCanCallLockTaskLocked, lockTaskPolicy, UserHandle.getUserId(callerIdentity.mUid), false);
        }
    }

    public final void setLockTaskPackages(ComponentName componentName, String str, String[] strArr) {
        EnforcingAdmin enforceCanCallLockTaskLocked;
        LockTaskPolicy lockTaskPolicy;
        Objects.requireNonNull(strArr, "packages is null");
        if (!Flags.devicePolicySizeTrackingInternalBugFixEnabled()) {
            for (String str2 : strArr) {
                PolicySizeVerifier.enforceMaxPackageNameLength(str2);
            }
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        checkCanExecuteOrThrowUnsafe(19);
        synchronized (getLockObject()) {
            enforceCanCallLockTaskLocked = enforceCanCallLockTaskLocked(componentName, callerIdentity.mPackageName);
        }
        DevicePolicyEngine devicePolicyEngine = this.mDevicePolicyEngine;
        PolicyDefinition policyDefinition = PolicyDefinition.LOCK_TASK;
        LockTaskPolicy lockTaskPolicy2 = (LockTaskPolicy) devicePolicyEngine.getLocalPolicySetByAdmin(policyDefinition, enforceCanCallLockTaskLocked, UserHandle.getUserId(callerIdentity.mUid));
        if (lockTaskPolicy2 == null) {
            lockTaskPolicy = new LockTaskPolicy(Set.of((Object[]) strArr));
        } else {
            LockTaskPolicy lockTaskPolicy3 = new LockTaskPolicy(lockTaskPolicy2);
            lockTaskPolicy3.setPackages(Set.of((Object[]) strArr));
            lockTaskPolicy = lockTaskPolicy3;
        }
        if (lockTaskPolicy.getPackages().isEmpty()) {
            this.mDevicePolicyEngine.removeLocalPolicy(policyDefinition, enforceCanCallLockTaskLocked, UserHandle.getUserId(callerIdentity.mUid));
        } else {
            this.mDevicePolicyEngine.setLocalPolicy(policyDefinition, enforceCanCallLockTaskLocked, lockTaskPolicy, UserHandle.getUserId(callerIdentity.mUid), false);
        }
    }

    public final void setLoggingConfiguration(boolean z, boolean z2) {
        int securityLoggingEnabledUser = getSecurityLoggingEnabledUser();
        SecurityLogMonitor securityLogMonitor = this.mSecurityLogMonitor;
        Slogf.i("SecurityLogMonitor", "Setting logging params, user = %d -> %d, legacy: %b -> %b, audit %b -> %b", Integer.valueOf(securityLogMonitor.mEnabledUser), Integer.valueOf(securityLoggingEnabledUser), Boolean.valueOf(securityLogMonitor.mLegacyLogEnabled), Boolean.valueOf(z), Boolean.valueOf(securityLogMonitor.mAuditLogEnabled), Boolean.valueOf(z2));
        ((ReentrantLock) securityLogMonitor.mLock).lock();
        try {
            securityLogMonitor.mEnabledUser = securityLoggingEnabledUser;
            Thread thread = securityLogMonitor.mMonitorThread;
            if (thread == null && (z || z2)) {
                securityLogMonitor.startMonitorThreadLocked();
            } else if (thread != null && !z && !z2) {
                securityLogMonitor.stopMonitorThreadLocked();
            }
            if (securityLogMonitor.mLegacyLogEnabled != z) {
                securityLogMonitor.resetLegacyBufferLocked();
                securityLogMonitor.mLegacyLogEnabled = z;
            }
            if (securityLogMonitor.mAuditLogEnabled != z2) {
                securityLogMonitor.mAuditLogEventBuffer.clear();
                securityLogMonitor.mAuditLogCallbacks.clear();
                securityLogMonitor.mAuditLogEnabled = z2;
            }
            ((ReentrantLock) securityLogMonitor.mLock).unlock();
            if (z || z2) {
                synchronized (getLockObject()) {
                    maybePauseDeviceWideLoggingLocked();
                }
            }
        } catch (Throwable th) {
            ((ReentrantLock) securityLogMonitor.mLock).unlock();
            throw th;
        }
    }

    public final void setLogoutEnabled(ComponentName componentName, boolean z) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
            checkCanExecuteOrThrowUnsafe(34);
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
                    if (deviceOwnerAdminLocked.isLogoutEnabled == z) {
                        return;
                    }
                    deviceOwnerAdminLocked.isLogoutEnabled = z;
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setLogoutUserIdLocked(int i) {
        if (i == -2) {
            i = getCurrentForegroundUserId();
        }
        Slogf.d("DevicePolicyManager", "setLogoutUserId(): %d -> %d", Integer.valueOf(this.mLogoutUserId), Integer.valueOf(i));
        this.mLogoutUserId = i;
    }

    public final void setLongSupportMessage(ComponentName componentName, CharSequence charSequence) {
        if (this.mHasFeature) {
            CharSequence truncateIfLonger = PolicySizeVerifier.truncateIfLonger(charSequence, 20000);
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForUidLocked = getActiveAdminForUidLocked(callerIdentity.mUid, componentName);
                    if (!TextUtils.equals(activeAdminForUidLocked.longSupportMessage, truncateIfLonger)) {
                        activeAdminForUidLocked.longSupportMessage = truncateIfLonger;
                        saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            DevicePolicyEventLogger.createEvent(44).setAdmin(componentName).write();
        }
    }

    public final void setManagedProfileCallerIdAccessPolicy(PackagePolicy packagePolicy) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(null, null);
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)));
            synchronized (getLockObject()) {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                profileOwnerLocked.disableCallerId = false;
                profileOwnerLocked.mManagedProfileCallerIdAccess = packagePolicy;
                saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
            }
        }
    }

    public final void setManagedProfileContactsAccessPolicy(PackagePolicy packagePolicy) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(null, null);
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)));
            synchronized (getLockObject()) {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                profileOwnerLocked.disableContactsSearch = false;
                profileOwnerLocked.mManagedProfileContactsAccess = packagePolicy;
                saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
            }
        }
    }

    public final void setManagedProfileMaximumTimeOff(ComponentName componentName, long j) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkArgumentNonnegative(j, "Timeout must be non-negative.");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 6);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7);
        Preconditions.checkState(true);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(userId);
                if (j > 0) {
                    long j2 = MANAGED_PROFILE_MAXIMUM_TIME_OFF_THRESHOLD;
                    if (j < j2 && !isAdminTestOnlyLocked(userId, componentName)) {
                        j = j2;
                    }
                }
                if (profileOwnerLocked.mProfileMaximumTimeOffMillis == j) {
                    return;
                }
                profileOwnerLocked.mProfileMaximumTimeOffMillis = j;
                saveSettingsLocked(userId, false, false, false);
                Injector injector2 = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, userId, 8);
                injector2.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6);
                DevicePolicyEventLogger.createEvent(136).setAdmin(callerIdentity.mComponentName).setTimePeriod(j).write();
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setManagedSubscriptionsPolicy(ManagedSubscriptionsPolicy managedSubscriptionsPolicy) {
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        if (!doesCallerHoldRole(callerIdentity, "android.app.role.DEVICE_POLICY_MANAGEMENT") && !Objects.equals(Settings.Global.getString(this.mInjector.mContext.getContentResolver(), "allow_work_profile_telephony_for_non_dpm_role_holders"), "1")) {
            throw new UnsupportedOperationException("This api is not enabled");
        }
        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(callerIdentity), "This policy can only be set by a profile owner on an organization-owned device.");
        int profileParentId = getProfileParentId(UserHandle.getUserId(callerIdentity.mUid));
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                if (hasUserSetupCompleted(profileParentId)) {
                    if (!isAdminTestOnlyLocked(UserHandle.getUserId(callerIdentity.mUid), profileOwnerLocked.info.getComponent())) {
                        throw new IllegalStateException("Not allowed to apply this policy after setup");
                    }
                }
                if (Objects.equals(managedSubscriptionsPolicy, profileOwnerLocked.mManagedSubscriptionsPolicy)) {
                    return;
                }
                profileOwnerLocked.mManagedSubscriptionsPolicy = managedSubscriptionsPolicy;
                saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                applyManagedSubscriptionsPolicyIfRequired();
                int policyType = getManagedSubscriptionsPolicy().getPolicyType();
                this.mInjector.getClass();
                long clearCallingIdentity = Binder.clearCallingIdentity();
                try {
                    if (policyType == 1) {
                        int userId = UserHandle.getUserId(callerIdentity.mUid);
                        try {
                            String systemDialerPackage = ((TelecomManager) this.mContext.getSystemService(TelecomManager.class)).getSystemDialerPackage();
                            String string = this.mContext.getString(R.string.config_defaultSms);
                            if (systemDialerPackage != null) {
                                this.mIPackageManager.installExistingPackageAsUser(systemDialerPackage, userId, 4194304, 1, (List) null);
                            } else {
                                Slogf.w("DevicePolicyManager", "Couldn't install dialer app, dialer app package is null");
                            }
                            if (string != null) {
                                this.mIPackageManager.installExistingPackageAsUser(string, userId, 4194304, 1, (List) null);
                            } else {
                                Slogf.w("DevicePolicyManager", "Couldn't install sms app, sms app package is null");
                            }
                            updateDialerAndSmsManagedShortcutsOverrideCache();
                        } catch (RemoteException e) {
                            Slogf.wtf("DevicePolicyManager", "Failed to install dialer/sms app", e);
                        }
                        updateTelephonyCrossProfileIntentFilters(profileParentId, UserHandle.getUserId(callerIdentity.mUid), true);
                    } else if (policyType == 0) {
                        updateTelephonyCrossProfileIntentFilters(profileParentId, UserHandle.getUserId(callerIdentity.mUid), false);
                    }
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                } catch (Throwable th) {
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    throw th;
                }
            } finally {
            }
        }
    }

    public final void setMasterVolumeMuted(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        checkCanExecuteOrThrowUnsafe(35);
        synchronized (getLockObject()) {
            setUserRestriction(componentName, componentName.getPackageName(), "disallow_unmute_device", z, false);
            DevicePolicyEventLogger.createEvent(35).setAdmin(componentName).setBoolean(z).write();
        }
    }

    public final void setMaxPolicyStorageLimit(String str, int i) {
        if (Flags.devicePolicySizeTrackingInternalBugFixEnabled()) {
            CallerIdentity callerIdentity = getCallerIdentity(null, str);
            enforcePermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS", callerIdentity.mPackageName, UserHandle.getUserId(callerIdentity.mUid));
            if (i < -1 && i != -1) {
                throw new IllegalArgumentException("Can't set a size limit less than the minimum allowed size.");
            }
            this.mDevicePolicyEngine.mPolicySizeLimit = i;
        }
    }

    public final void setMaximumFailedPasswordsForWipe(ComponentName componentName, String str, int i, boolean z) {
        ActiveAdmin activeAdminOrCheckPermissionForCallerLocked;
        if (this.mHasFeature && this.mLockPatternUtils.hasSecureLockScreen()) {
            if (!isPermissionCheckFlagEnabled()) {
                Objects.requireNonNull(componentName, "ComponentName is null");
            }
            this.mInjector.getClass();
            int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            int profileParentId = z ? getProfileParentId(userHandleGetCallingUserId) : userHandleGetCallingUserId;
            synchronized (getLockObject()) {
                try {
                    if (isPermissionCheckFlagEnabled()) {
                        String str2 = getCallerIdentity(componentName, str).mPackageName;
                        if (!hasAdminPolicy(4, str2)) {
                            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_WIPE_DATA", str2, profileParentId);
                        }
                        activeAdminOrCheckPermissionForCallerLocked = getEnforcingAdminForCaller(componentName, str2).mActiveAdmin;
                    } else {
                        getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 4, z);
                        activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 1, z);
                    }
                    if (activeAdminOrCheckPermissionForCallerLocked.maximumFailedPasswordsForWipe != i) {
                        activeAdminOrCheckPermissionForCallerLocked.maximumFailedPasswordsForWipe = i;
                        saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210020, new Object[]{str, Integer.valueOf(userHandleGetCallingUserId), Integer.valueOf(profileParentId), Integer.valueOf(i)});
            }
        }
    }

    public final void setMaximumFailedPasswordsForWipeMDM(ComponentName componentName, int i, int i2) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                try {
                    getActiveAdminForCallerLockedMDM(4, i2, componentName);
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(1, i2, componentName);
                    if (activeAdminForCallerLockedMDM.maximumFailedPasswordsForWipe != i) {
                        activeAdminForCallerLockedMDM.maximumFailedPasswordsForWipe = i;
                        saveSettingsLocked(i2, false, false, false);
                        AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                        String format = String.format("Admin %s has changed maximum failed passwords for wipe to %d", componentName.getPackageName(), Integer.valueOf(i));
                        auditLogHelper.getClass();
                        AuditLogHelper.makeAuditLogGroupSecurity(i2, format);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210020, new Object[]{componentName.getPackageName(), Integer.valueOf(i2), Integer.valueOf(i2), Integer.valueOf(i)});
            }
        }
    }

    public final void setMaximumTimeToLock(ComponentName componentName, String str, final long j, boolean z) {
        ActiveAdmin activeAdminOrCheckPermissionForCallerLocked;
        if (this.mHasFeature) {
            if (!isPermissionCheckFlagEnabled()) {
                Objects.requireNonNull(componentName, "ComponentName is null");
            }
            this.mInjector.getClass();
            final int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            int profileParentId = z ? getProfileParentId(userHandleGetCallingUserId) : userHandleGetCallingUserId;
            synchronized (getLockObject()) {
                try {
                    if (isPermissionCheckFlagEnabled()) {
                        String str2 = getCallerIdentity(componentName, str).mPackageName;
                        if (!hasAdminPolicy(3, str2)) {
                            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_LOCK", str2, profileParentId);
                        }
                        activeAdminOrCheckPermissionForCallerLocked = getEnforcingAdminForCaller(componentName, str2).mActiveAdmin;
                    } else {
                        activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 3, z);
                    }
                    if (activeAdminOrCheckPermissionForCallerLocked.maximumTimeToUnlock != j) {
                        activeAdminOrCheckPermissionForCallerLocked.maximumTimeToUnlock = j;
                        saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                        updateMaximumTimeToLockLocked(userHandleGetCallingUserId);
                        this.mInjector.getClass();
                        Context context = this.mContext;
                        final PersonaManagerService personaManagerService = (PersonaManagerService) ServiceManager.getService("persona");
                        if (personaManagerService != null && SemPersonaManager.isKnoxId(userHandleGetCallingUserId)) {
                            new Handler(context.getMainLooper()).postDelayed(new Runnable() { // from class: com.android.server.devicepolicy.KnoxUtils.1
                                public final /* synthetic */ long val$timeMs;
                                public final /* synthetic */ int val$userHandle;

                                public AnonymousClass1(final long j2, final int userHandleGetCallingUserId2) {
                                    r2 = j2;
                                    r4 = userHandleGetCallingUserId2;
                                }

                                @Override // java.lang.Runnable
                                public final void run() {
                                    Log.i("DevicePolicyManager::KnoxUtils", "notify persona to may log analytics");
                                    PersonaManagerService personaManagerService2 = PersonaManagerService.this;
                                    long j2 = r2;
                                    int i = r4;
                                    personaManagerService2.getClass();
                                    long intForUser = SemPersonaManager.isSecureFolderId(i) ? Settings.System.getIntForUser(personaManagerService2.mContext.getContentResolver(), "knox_screen_off_timeout", -1, i) : Settings.Secure.getIntForUser(personaManagerService2.mContext.getContentResolver(), "knox_screen_off_timeout", -1, i);
                                    boolean z2 = j2 > 0;
                                    if ((!z2 || intForUser <= j2) && ((!z2 || intForUser > 0) && ((!z2 || intForUser <= 0 || intForUser > j2 || !personaManagerService2.mKALockscreenTimeoutAdminFlag) && (z2 || !personaManagerService2.mKALockscreenTimeoutAdminFlag)))) {
                                        return;
                                    }
                                    KnoxAnalyticsContainer.AnalyticsHandler analyticsHandler = personaManagerService2.mKnoxAnalyticsContainer.analyticsHandler;
                                    analyticsHandler.sendMessage(analyticsHandler.obtainMessage(2, i, 0));
                                    if (!z2 || intForUser <= j2) {
                                        personaManagerService2.mKALockscreenTimeoutAdminFlag = false;
                                    } else {
                                        personaManagerService2.mKALockscreenTimeoutAdminFlag = true;
                                    }
                                }
                            }, 300L);
                        }
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210019, new Object[]{str, Integer.valueOf(userHandleGetCallingUserId2), Integer.valueOf(profileParentId), Long.valueOf(j2)});
            }
        }
    }

    public final void setMaximumTimeToLockMDM(ComponentName componentName, long j, int i) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(3, i, componentName);
                    if (activeAdminForCallerLockedMDM.maximumTimeToUnlock != j) {
                        activeAdminForCallerLockedMDM.maximumTimeToUnlock = j;
                        saveSettingsLocked(i, false, false, false);
                        updateMaximumTimeToLockLocked(i);
                        AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                        Object[] objArr = {componentName.getPackageName(), Long.valueOf(j)};
                        auditLogHelper.getClass();
                        long clearCallingIdentity = Binder.clearCallingIdentity();
                        try {
                            AuditLog.logEventAsUser(i, 52, objArr);
                            Binder.restoreCallingIdentity(clearCallingIdentity);
                        } catch (Throwable th) {
                            Binder.restoreCallingIdentity(clearCallingIdentity);
                            throw th;
                        }
                    }
                } catch (Throwable th2) {
                    throw th2;
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210019, new Object[]{componentName.getPackageName(), Integer.valueOf(i), Integer.valueOf(i), Long.valueOf(j)});
            }
        }
    }

    public final List setMeteredDataDisabledPackages(ComponentName componentName, List list) {
        Objects.requireNonNull(componentName);
        Objects.requireNonNull(list);
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity), "Admin %s does not own the profile", new Object[]{callerIdentity.mComponentName});
        if (!this.mHasFeature) {
            return list;
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda153 devicePolicyManagerService$$ExternalSyntheticLambda153 = new DevicePolicyManagerService$$ExternalSyntheticLambda153(this, callerIdentity, list, 0);
        injector.getClass();
        return (List) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda153);
    }

    public final void setMinimumRequiredWifiSecurityLevel(String str, int i) {
        CallerIdentity callerIdentity;
        boolean z = true;
        if (isPermissionCheckFlagEnabled()) {
            callerIdentity = getCallerIdentity(null, str);
        } else {
            callerIdentity = getCallerIdentity(null, null);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity), "Wi-Fi minimum security level can only be controlled by a device owner or a profile owner on an organization-owned device.");
        }
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerOrDeviceOwnerLocked = isPermissionCheckFlagEnabled() ? enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), null, "android.permission.MANAGE_DEVICE_POLICY_WIFI", callerIdentity.mPackageName).mActiveAdmin : getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                if (profileOwnerOrDeviceOwnerLocked.mWifiMinimumSecurityLevel != i) {
                    profileOwnerOrDeviceOwnerLocked.mWifiMinimumSecurityLevel = i;
                    saveSettingsLocked(profileOwnerOrDeviceOwnerLocked.getUserHandle().getIdentifier(), false, false, false);
                } else {
                    z = false;
                }
                this.mInjector.getClass();
                if (z) {
                    i = getStrictestMinimumRequiredWifiSecurityLevelLocked();
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        if (z) {
            notifyMinimumRequiredWifiSecurityLevelChanged(i);
        }
    }

    public final void setMtePolicy(int i, String str) {
        Preconditions.checkArgument(Set.of(0, 2, 1).contains(Integer.valueOf(i)), "Provided mode is not one of the allowed values.");
        this.mInjector.getClass();
        if (!SystemProperties.getBoolean("ro.arm64.memtag.bootctl_device_policy_manager", SystemProperties.getBoolean("ro.arm64.memtag.bootctl_settings_toggle", false))) {
            throw new UnsupportedOperationException("device does not support MTE");
        }
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        if (i == 2) {
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
        }
        if (isPermissionCheckFlagEnabled()) {
            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_MTE", callerIdentity.mPackageName, -1);
        } else {
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        }
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();
                if (deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked != null) {
                    if (i == 1) {
                        this.mInjector.getClass();
                        SystemProperties.set("arm64.memtag.bootctl", "memtag");
                    } else if (i == 2) {
                        this.mInjector.getClass();
                        SystemProperties.set("arm64.memtag.bootctl", "memtag-off");
                    } else if (i == 0 && deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked.mtePolicy != 0) {
                        this.mInjector.getClass();
                        SystemProperties.set("arm64.memtag.bootctl", "default");
                    }
                    deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked.mtePolicy = i;
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    DevicePolicyEventLogger.createEvent(FrameworkStatsLog.DEVICE_POLICY_EVENT__EVENT_ID__SET_MTE_POLICY).setInt(i).setAdmin(callerIdentity.mPackageName).write();
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setNearbyAppStreamingPolicy(int i) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(null, null);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                    if (profileOwnerOrDeviceOwnerLocked.mNearbyAppStreamingPolicy != i) {
                        profileOwnerOrDeviceOwnerLocked.mNearbyAppStreamingPolicy = i;
                        saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setNearbyNotificationStreamingPolicy(int i) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(null, null);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                    if (profileOwnerOrDeviceOwnerLocked.mNearbyNotificationStreamingPolicy != i) {
                        profileOwnerOrDeviceOwnerLocked.mNearbyNotificationStreamingPolicy = i;
                        saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setNetworkLoggingActiveInternal(boolean z) {
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda3 devicePolicyManagerService$$ExternalSyntheticLambda3 = new DevicePolicyManagerService$$ExternalSyntheticLambda3(3, this, z);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda3);
    }

    /* JADX WARN: Multi-variable type inference failed */
    public final void setNetworkLoggingEnabled(ComponentName componentName, String str, boolean z) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            boolean z2 = true;
            byte b = isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid));
            Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && (isDefaultDeviceOwner(callerIdentity) || b == true)) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-network-logging")));
            synchronized (getLockObject()) {
                try {
                    if (z == isNetworkLoggingEnabledInternalLocked()) {
                        return;
                    }
                    ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(UserHandle.getUserId(callerIdentity.mUid));
                    deviceOrProfileOwnerAdminLocked.isNetworkLoggingEnabled = z;
                    if (!z) {
                        deviceOrProfileOwnerAdminLocked.numNetworkLoggingNotifications = 0;
                        deviceOrProfileOwnerAdminLocked.lastNetworkLoggingNotificationTimeMs = 0L;
                    }
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    setNetworkLoggingActiveInternal(z);
                    DevicePolicyEventLogger admin = DevicePolicyEventLogger.createEvent(119).setAdmin(callerIdentity.mPackageName);
                    if (componentName != null) {
                        z2 = false;
                    }
                    admin.setBoolean(z2).setInt(z ? 1 : 0).setStrings(new String[]{b != false ? "profile-owner" : "device-owner"}).write();
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setNextOperationSafety(int i, int i2) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_DEVICE_ADMINS"));
        Slogf.i("DevicePolicyManager", "setNextOperationSafety(%s, %s)", DevicePolicyManager.operationToString(i), DevicePolicyManager.operationSafetyReasonToString(i2));
        this.mSafetyChecker = new OneTimeSafetyChecker(this, i, i2);
    }

    public final void setOrganizationColor(ComponentName componentName, int i) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallingUser(isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)));
            Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
            synchronized (getLockObject()) {
                getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).organizationColor = i;
                saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
            }
            DevicePolicyEventLogger.createEvent(39).setAdmin(callerIdentity.mComponentName).write();
        }
    }

    public final void setOrganizationColorForUser(int i, int i2) {
        if (this.mHasFeature) {
            Preconditions.checkArgumentNonnegative(i2, "Invalid userId");
            Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(getCallerIdentity(null, null), i2));
            Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_USERS"));
            Preconditions.checkCallAuthorization(isManagedProfile(i2), "You can not set organization color outside a managed profile, userId = %d", new Object[]{Integer.valueOf(i2)});
            synchronized (getLockObject()) {
                getProfileOwnerAdminLocked(i2).organizationColor = i;
                saveSettingsLocked(i2, false, false, false);
            }
        }
    }

    public final void setOrganizationIdForUser(String str, String str2, int i) {
        String packageName;
        if (this.mHasFeature) {
            Objects.requireNonNull(str);
            CallerIdentity callerIdentity = getCallerIdentity(null, str);
            boolean z = true;
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity), "Only a Device Owner or Profile Owner may set the Enterprise ID.");
            Preconditions.checkArgument(!TextUtils.isEmpty(str2), "Enterprise ID may not be empty.");
            Slogf.i("DevicePolicyManager", "Setting Enterprise ID to %s for user %d", str2, Integer.valueOf(i));
            synchronized (this.mESIDInitilizationLock) {
                try {
                    if (this.mEsidCalculator == null) {
                        Injector injector = this.mInjector;
                        DevicePolicyManagerService$$ExternalSyntheticLambda57 devicePolicyManagerService$$ExternalSyntheticLambda57 = new DevicePolicyManagerService$$ExternalSyntheticLambda57(0, this);
                        injector.getClass();
                        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda57);
                    }
                } finally {
                }
            }
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(i);
                    Preconditions.checkCallAuthorization(deviceOrProfileOwnerAdminLocked != null && deviceOrProfileOwnerAdminLocked.getUserHandle().getIdentifier() == i, String.format("The Profile Owner or Device Owner may only set the Enterprise ID on its own user, called on user %d but owner user is %d", Integer.valueOf(i), Integer.valueOf(deviceOrProfileOwnerAdminLocked.getUserHandle().getIdentifier())));
                    packageName = deviceOrProfileOwnerAdminLocked.info.getPackageName();
                    if (!TextUtils.isEmpty(deviceOrProfileOwnerAdminLocked.mOrganizationId) && !deviceOrProfileOwnerAdminLocked.mOrganizationId.equals(str2)) {
                        z = false;
                    }
                    Preconditions.checkState(z, "The organization ID has been previously set to a different value and cannot be changed");
                    String calculateEnterpriseId = this.mEsidCalculator.calculateEnterpriseId(deviceOrProfileOwnerAdminLocked.info.getPackageName(), str2);
                    deviceOrProfileOwnerAdminLocked.mOrganizationId = str2;
                    deviceOrProfileOwnerAdminLocked.mEnrollmentSpecificId = calculateEnterpriseId;
                    saveSettingsLocked(i, false, false, false);
                } finally {
                }
            }
            DevicePolicyEventLogger.createEvent(FrameworkStatsLog.DEVICE_POLICY_EVENT__EVENT_ID__SET_ORGANIZATION_ID).setAdmin(packageName).setBoolean(isManagedProfile(i)).write();
        }
    }

    public final void setOrganizationName(ComponentName componentName, String str, CharSequence charSequence) {
        ActiveAdmin activeAdmin;
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            String str2 = null;
            if (isPermissionCheckFlagEnabled()) {
                activeAdmin = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY", callerIdentity.mPackageName).mActiveAdmin;
            } else {
                Objects.requireNonNull(componentName, "ComponentName is null");
                Preconditions.checkCallAuthorization(isDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
                activeAdmin = null;
            }
            CharSequence truncateIfLonger = PolicySizeVerifier.truncateIfLonger(charSequence, 200);
            synchronized (getLockObject()) {
                try {
                    if (!isPermissionCheckFlagEnabled()) {
                        activeAdmin = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                    }
                    if (!TextUtils.equals(activeAdmin.organizationName, truncateIfLonger)) {
                        if (truncateIfLonger != null && truncateIfLonger.length() != 0) {
                            str2 = truncateIfLonger.toString();
                        }
                        activeAdmin.organizationName = str2;
                        saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setOverrideApnsEnabled(ComponentName componentName, boolean z) {
        if (this.mHasFeature) {
            if (this.mHasTelephonyFeature || this.mHasTelephonyDataFeature) {
                Objects.requireNonNull(componentName, "ComponentName is null");
                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
                checkCanExecuteOrThrowUnsafe(36);
                ContentValues contentValues = new ContentValues();
                contentValues.put("enforced", Boolean.valueOf(z));
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda34 devicePolicyManagerService$$ExternalSyntheticLambda34 = new DevicePolicyManagerService$$ExternalSyntheticLambda34(0, this, contentValues);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda34);
            }
        }
    }

    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r1v0, types: [com.android.server.devicepolicy.DevicePolicyManagerService] */
    /* JADX WARN: Type inference failed for: r1v3, types: [com.android.server.devicepolicy.DevicePolicyManagerService$Injector, java.lang.Object] */
    public final String[] setPackagesSuspended(ComponentName componentName, String str, String[] strArr, boolean z) {
        String[] suspend;
        ActiveAdmin profileOwnerOrDeviceOwnerLocked;
        String[] packagesSuspendedByAdmin;
        DevicePolicyManagerService devicePolicyManagerService = this;
        String[] strArr2 = strArr;
        int i = 0;
        if (Flags.unmanagedModeMigration()) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = devicePolicyManagerService.enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE", callerIdentity.mPackageName);
            devicePolicyManagerService.checkCanExecuteOrThrowUnsafe(20);
            ArraySet arraySet = new ArraySet(strArr2);
            DevicePolicyEngine devicePolicyEngine = devicePolicyManagerService.mDevicePolicyEngine;
            PolicyDefinition policyDefinition = PolicyDefinition.PACKAGES_SUSPENDED;
            Set set = (Set) devicePolicyEngine.getResolvedPolicy(policyDefinition, UserHandle.getUserId(callerIdentity.mUid));
            Set set2 = (Set) devicePolicyManagerService.mDevicePolicyEngine.getLocalPolicySetByAdmin(policyDefinition, enforcePermissionAndGetEnforcingAdmin, UserHandle.getUserId(callerIdentity.mUid));
            if (set2 == null) {
                set2 = new ArraySet();
            }
            if (z) {
                set2.addAll(arraySet);
            } else {
                set2.removeAll(arraySet);
            }
            if (set2.isEmpty()) {
                devicePolicyManagerService.mDevicePolicyEngine.removeLocalPolicy(policyDefinition, enforcePermissionAndGetEnforcingAdmin, UserHandle.getUserId(callerIdentity.mUid));
            } else {
                devicePolicyManagerService.mDevicePolicyEngine.setLocalPolicy(policyDefinition, enforcePermissionAndGetEnforcingAdmin, new PackageSetPolicyValue(set2), UserHandle.getUserId(callerIdentity.mUid), false);
            }
            Set set3 = (Set) devicePolicyManagerService.mDevicePolicyEngine.getResolvedPolicy(policyDefinition, UserHandle.getUserId(callerIdentity.mUid));
            List listPolicyExemptAppsUnchecked = listPolicyExemptAppsUnchecked(devicePolicyManagerService.mContext);
            devicePolicyManagerService.mInjector.getClass();
            PackageSuspender packageSuspender = new PackageSuspender(set, set3, listPolicyExemptAppsUnchecked, Injector.getPackageManagerInternal(), UserHandle.getUserId(callerIdentity.mUid));
            synchronized (getLockObject()) {
                devicePolicyManagerService.mInjector.getClass();
                long clearCallingIdentity = Binder.clearCallingIdentity();
                try {
                    suspend = z ? packageSuspender.suspend(arraySet) : packageSuspender.unsuspend(arraySet);
                } catch (Throwable th) {
                    throw th;
                }
            }
            DevicePolicyEventLogger.createEvent(68).setAdmin(callerIdentity.mPackageName).setBoolean(componentName == null).setStrings(strArr2).write();
            return suspend;
        }
        CallerIdentity callerIdentity2 = getCallerIdentity(componentName, str);
        Preconditions.checkCallAuthorization((callerIdentity2.hasAdminComponent() && (devicePolicyManagerService.isProfileOwner(callerIdentity2) || devicePolicyManagerService.isDefaultDeviceOwner(callerIdentity2))) || (callerIdentity2.hasPackage() && devicePolicyManagerService.isCallerDelegate(callerIdentity2, "delegation-package-access")));
        synchronized (getLockObject()) {
            profileOwnerOrDeviceOwnerLocked = devicePolicyManagerService.getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity2.mUid));
        }
        devicePolicyManagerService.checkCanExecuteOrThrowUnsafe(20);
        HashSet hashSet = new HashSet();
        Preconditions.checkArgument(hashSet.isEmpty(), "outputExemptApps is not empty");
        List listPolicyExemptAppsUnchecked2 = listPolicyExemptAppsUnchecked(devicePolicyManagerService.mContext);
        if (!((ArrayList) listPolicyExemptAppsUnchecked2).isEmpty()) {
            HashSet hashSet2 = new HashSet(listPolicyExemptAppsUnchecked2);
            ArrayList arrayList = new ArrayList(strArr2.length);
            for (String str2 : strArr2) {
                if (hashSet2.contains(str2)) {
                    hashSet.add(str2);
                } else {
                    arrayList.add(str2);
                }
            }
            strArr2 = new String[arrayList.size()];
            arrayList.toArray(strArr2);
        }
        synchronized (getLockObject()) {
            devicePolicyManagerService.mInjector.getClass();
            long clearCallingIdentity2 = Binder.clearCallingIdentity();
            try {
                devicePolicyManagerService.mInjector.getClass();
                packagesSuspendedByAdmin = Injector.getPackageManagerInternal().setPackagesSuspendedByAdmin(UserHandle.getUserId(callerIdentity2.mUid), z, strArr2);
            } finally {
                devicePolicyManagerService.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity2);
            }
        }
        DevicePolicyEventLogger.createEvent(68).setAdmin(callerIdentity2.mPackageName).setBoolean(componentName == null).setStrings(strArr2).write();
        if (packagesSuspendedByAdmin == null) {
            Slogf.w("DevicePolicyManager", "PM failed to suspend packages (%s)", Arrays.toString(strArr2));
            return strArr2;
        }
        ArraySet arraySet2 = new ArraySet(strArr2);
        if (z) {
            arraySet2.removeAll(List.of((Object[]) packagesSuspendedByAdmin));
        } else {
            arraySet2.addAll(hashSet);
        }
        synchronized (getLockObject()) {
            try {
                ArraySet arraySet3 = new ArraySet(profileOwnerOrDeviceOwnerLocked.suspendedPackages);
                if (z) {
                    arraySet3.addAll(arraySet2);
                } else {
                    arraySet3.removeAll(arraySet2);
                }
                profileOwnerOrDeviceOwnerLocked.suspendedPackages = arraySet3.isEmpty() ? null : new ArrayList(arraySet3);
                devicePolicyManagerService.saveSettingsLocked(UserHandle.getUserId(callerIdentity2.mUid), false, false, false);
            } finally {
            }
        }
        if (hashSet.isEmpty()) {
            return packagesSuspendedByAdmin;
        }
        String[] strArr3 = new String[hashSet.size() + packagesSuspendedByAdmin.length];
        int length = packagesSuspendedByAdmin.length;
        int i2 = 0;
        while (i < length) {
            strArr3[i2] = packagesSuspendedByAdmin[i];
            i++;
            i2++;
        }
        Iterator it = hashSet.iterator();
        while (it.hasNext()) {
            strArr3[i2] = (String) it.next();
            i2++;
        }
        return strArr3;
    }

    public final void setPasswordExpirationTimeout(ComponentName componentName, String str, long j, boolean z) {
        if (this.mHasFeature && this.mLockPatternUtils.hasSecureLockScreen()) {
            if (!isPermissionCheckFlagEnabled()) {
                Objects.requireNonNull(componentName, "ComponentName is null");
            }
            Preconditions.checkArgumentNonnegative(j, "Timeout must be >= 0 ms");
            this.mInjector.getClass();
            int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            int profileParentId = z ? getProfileParentId(userHandleGetCallingUserId) : userHandleGetCallingUserId;
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = isPermissionCheckFlagEnabled() ? enforcePermissionAndGetEnforcingAdmin(profileParentId, componentName, "android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", getCallerIdentity(componentName, str).mPackageName).mActiveAdmin : getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 6, z);
                    long currentTimeMillis = j > 0 ? System.currentTimeMillis() + j : 0L;
                    activeAdminOrCheckPermissionForCallerLocked.passwordExpirationDate = currentTimeMillis;
                    activeAdminOrCheckPermissionForCallerLocked.passwordExpirationTimeout = j;
                    if (j > 0) {
                        Slogf.w("DevicePolicyManager", "setPasswordExpiration(): password will expire on " + DateFormat.getDateTimeInstance(2, 2).format(new Date(currentTimeMillis)));
                    }
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                    setExpirationAlarmCheckLocked(this.mContext, userHandleGetCallingUserId, z);
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210016, new Object[]{str, Integer.valueOf(userHandleGetCallingUserId), Integer.valueOf(profileParentId), Long.valueOf(j)});
            }
        }
    }

    public final void setPasswordExpirationTimeoutMDM(ComponentName componentName, long j, int i) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkArgumentNonnegative(j, "Timeout must be >= 0 ms");
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(6, i, componentName);
                    long currentTimeMillis = j > 0 ? System.currentTimeMillis() + j : 0L;
                    activeAdminForCallerLockedMDM.passwordExpirationDate = currentTimeMillis;
                    activeAdminForCallerLockedMDM.passwordExpirationTimeout = j;
                    if (j > 0) {
                        Slogf.w("DevicePolicyManager", "setPasswordExpiration(): password will expire on " + DateFormat.getDateTimeInstance(2, 2).format(new Date(currentTimeMillis)));
                    }
                    saveSettingsLocked(i, false, false, false);
                    setExpirationAlarmCheckLocked(this.mContext, i, false);
                    AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                    String format = String.format("Admin %s has changed password expiration time out to %d", componentName.getPackageName(), Long.valueOf(j));
                    auditLogHelper.getClass();
                    AuditLogHelper.makeAuditLogGroupSecurity(i, format);
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210016, new Object[]{componentName.getPackageName(), Integer.valueOf(i), Integer.valueOf(i), Long.valueOf(j)});
            }
        }
    }

    public final void setPasswordHistoryLength(ComponentName componentName, int i, boolean z) {
        if (this.mHasFeature && this.mLockPatternUtils.hasSecureLockScreen()) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            this.mInjector.getClass();
            int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 0, z);
                    if (activeAdminOrCheckPermissionForCallerLocked.passwordHistoryLength != i) {
                        activeAdminOrCheckPermissionForCallerLocked.passwordHistoryLength = i;
                        updatePasswordValidityCheckpointLocked(userHandleGetCallingUserId, z);
                        saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210018, new Object[]{componentName.getPackageName(), Integer.valueOf(userHandleGetCallingUserId), Integer.valueOf(z ? getProfileParentId(userHandleGetCallingUserId) : userHandleGetCallingUserId), Integer.valueOf(i)});
            }
        }
    }

    public final void setPasswordHistoryLengthMDM(ComponentName componentName, int i, int i2) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(0, i2, componentName);
                    if (activeAdminForCallerLockedMDM.passwordHistoryLength != i) {
                        activeAdminForCallerLockedMDM.passwordHistoryLength = i;
                        updatePasswordValidityCheckpointLocked(i2, false);
                        saveSettingsLocked(i2, false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (SecurityLog.isLoggingEnabled()) {
                SecurityLog.writeEvent(210018, new Object[]{componentName.getPackageName(), Integer.valueOf(i2), Integer.valueOf(i2), Integer.valueOf(i)});
            }
        }
    }

    public final void setPasswordMinimumLength(ComponentName componentName, int i, boolean z) {
        if (!this.mHasFeature || notSupportedOnAutomotive("setPasswordMinimumLength")) {
            return;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 0, z);
                ensureMinimumQuality(userHandleGetCallingUserId, activeAdminOrCheckPermissionForCallerLocked, 131072, "setPasswordMinimumLength");
                PasswordPolicy passwordPolicy = activeAdminOrCheckPermissionForCallerLocked.mPasswordPolicy;
                if (passwordPolicy.length != i) {
                    passwordPolicy.length = i;
                    updatePasswordValidityCheckpointLocked(userHandleGetCallingUserId, z);
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
                logPasswordQualitySetIfSecurityLogEnabled(componentName, userHandleGetCallingUserId, z, passwordPolicy);
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger.createEvent(2).setAdmin(componentName).setInt(i).write();
    }

    public final void setPasswordMinimumLengthMDM(ComponentName componentName, int i, int i2) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(0, i2, componentName);
                    ensureMinimumQuality(i2, activeAdminForCallerLockedMDM, 131072, "setPasswordMinimumLength");
                    PasswordPolicy passwordPolicy = activeAdminForCallerLockedMDM.mPasswordPolicy;
                    if (passwordPolicy.length != i) {
                        passwordPolicy.length = i;
                        updatePasswordValidityCheckpointLocked(i2, false);
                        saveSettingsLocked(i2, false, false, false);
                        AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                        String format = String.format("Admin %s has changed password minimum length to %d", componentName.getPackageName(), Integer.valueOf(i));
                        auditLogHelper.getClass();
                        AuditLogHelper.makeAuditLogGroupSecurity(i2, format);
                    }
                    logPasswordQualitySetIfSecurityLogEnabled(componentName, i2, false, passwordPolicy);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setPasswordMinimumLetters(ComponentName componentName, int i, boolean z) {
        if (!this.mHasFeature || notSupportedOnAutomotive("setPasswordMinimumLetters")) {
            return;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 0, z);
                ensureMinimumQuality(userHandleGetCallingUserId, activeAdminOrCheckPermissionForCallerLocked, 393216, "setPasswordMinimumLetters");
                PasswordPolicy passwordPolicy = activeAdminOrCheckPermissionForCallerLocked.mPasswordPolicy;
                if (passwordPolicy.letters != i) {
                    passwordPolicy.letters = i;
                    updatePasswordValidityCheckpointLocked(userHandleGetCallingUserId, z);
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
                logPasswordQualitySetIfSecurityLogEnabled(componentName, userHandleGetCallingUserId, z, passwordPolicy);
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger.createEvent(5).setAdmin(componentName).setInt(i).write();
    }

    public final void setPasswordMinimumLettersMDM(ComponentName componentName, int i, int i2) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(0, i2, componentName);
                    ensureMinimumQuality(i2, activeAdminForCallerLockedMDM, 393216, "setPasswordMinimumLetters");
                    PasswordPolicy passwordPolicy = activeAdminForCallerLockedMDM.mPasswordPolicy;
                    if (passwordPolicy.letters != i) {
                        passwordPolicy.letters = i;
                        updatePasswordValidityCheckpointLocked(i2, false);
                        saveSettingsLocked(i2, false, false, false);
                        AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                        String format = String.format("Admin %s has changed password minimum letters to %d", componentName.getPackageName(), Integer.valueOf(i));
                        auditLogHelper.getClass();
                        AuditLogHelper.makeAuditLogGroupSecurity(i2, format);
                    }
                    logPasswordQualitySetIfSecurityLogEnabled(componentName, i2, false, passwordPolicy);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setPasswordMinimumLowerCase(ComponentName componentName, int i, boolean z) {
        if (notSupportedOnAutomotive("setPasswordMinimumLowerCase")) {
            return;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 0, z);
                ensureMinimumQuality(userHandleGetCallingUserId, activeAdminOrCheckPermissionForCallerLocked, 393216, "setPasswordMinimumLowerCase");
                PasswordPolicy passwordPolicy = activeAdminOrCheckPermissionForCallerLocked.mPasswordPolicy;
                if (passwordPolicy.lowerCase != i) {
                    passwordPolicy.lowerCase = i;
                    updatePasswordValidityCheckpointLocked(userHandleGetCallingUserId, z);
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
                logPasswordQualitySetIfSecurityLogEnabled(componentName, userHandleGetCallingUserId, z, passwordPolicy);
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger.createEvent(6).setAdmin(componentName).setInt(i).write();
    }

    public final void setPasswordMinimumLowerCaseMDM(ComponentName componentName, int i, int i2) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(0, i2, componentName);
                ensureMinimumQuality(i2, activeAdminForCallerLockedMDM, 393216, "setPasswordMinimumLowerCase");
                PasswordPolicy passwordPolicy = activeAdminForCallerLockedMDM.mPasswordPolicy;
                if (passwordPolicy.lowerCase != i) {
                    passwordPolicy.lowerCase = i;
                    updatePasswordValidityCheckpointLocked(i2, false);
                    saveSettingsLocked(i2, false, false, false);
                    AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                    String format = String.format("Admin %s has changed password minimum lower case to %d", componentName.getPackageName(), Integer.valueOf(i));
                    auditLogHelper.getClass();
                    AuditLogHelper.makeAuditLogGroupSecurity(i2, format);
                }
                logPasswordQualitySetIfSecurityLogEnabled(componentName, i2, false, passwordPolicy);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setPasswordMinimumNonLetter(ComponentName componentName, int i, boolean z) {
        if (!this.mHasFeature || notSupportedOnAutomotive("setPasswordMinimumNonLetter")) {
            return;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 0, z);
                ensureMinimumQuality(userHandleGetCallingUserId, activeAdminOrCheckPermissionForCallerLocked, 393216, "setPasswordMinimumNonLetter");
                PasswordPolicy passwordPolicy = activeAdminOrCheckPermissionForCallerLocked.mPasswordPolicy;
                if (passwordPolicy.nonLetter != i) {
                    passwordPolicy.nonLetter = i;
                    updatePasswordValidityCheckpointLocked(userHandleGetCallingUserId, z);
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
                logPasswordQualitySetIfSecurityLogEnabled(componentName, userHandleGetCallingUserId, z, passwordPolicy);
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger.createEvent(4).setAdmin(componentName).setInt(i).write();
    }

    public final void setPasswordMinimumNonLetterMDM(ComponentName componentName, int i, int i2) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(0, i2, componentName);
                    ensureMinimumQuality(i2, activeAdminForCallerLockedMDM, 393216, "setPasswordMinimumNonLetter");
                    PasswordPolicy passwordPolicy = activeAdminForCallerLockedMDM.mPasswordPolicy;
                    if (passwordPolicy.nonLetter != i) {
                        passwordPolicy.nonLetter = i;
                        updatePasswordValidityCheckpointLocked(i2, false);
                        saveSettingsLocked(i2, false, false, false);
                        AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                        String format = String.format("Admin %s has changed password minimum non-letter to %d", componentName.getPackageName(), Integer.valueOf(i));
                        auditLogHelper.getClass();
                        AuditLogHelper.makeAuditLogGroupSecurity(i2, format);
                    }
                    logPasswordQualitySetIfSecurityLogEnabled(componentName, i2, false, passwordPolicy);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setPasswordMinimumNumeric(ComponentName componentName, int i, boolean z) {
        if (!this.mHasFeature || notSupportedOnAutomotive("setPasswordMinimumNumeric")) {
            return;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 0, z);
                ensureMinimumQuality(userHandleGetCallingUserId, activeAdminOrCheckPermissionForCallerLocked, 393216, "setPasswordMinimumNumeric");
                PasswordPolicy passwordPolicy = activeAdminOrCheckPermissionForCallerLocked.mPasswordPolicy;
                if (passwordPolicy.numeric != i) {
                    passwordPolicy.numeric = i;
                    updatePasswordValidityCheckpointLocked(userHandleGetCallingUserId, z);
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
                logPasswordQualitySetIfSecurityLogEnabled(componentName, userHandleGetCallingUserId, z, passwordPolicy);
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger.createEvent(3).setAdmin(componentName).setInt(i).write();
    }

    public final void setPasswordMinimumNumericMDM(ComponentName componentName, int i, int i2) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(0, i2, componentName);
                    ensureMinimumQuality(i2, activeAdminForCallerLockedMDM, 393216, "setPasswordMinimumNumeric");
                    PasswordPolicy passwordPolicy = activeAdminForCallerLockedMDM.mPasswordPolicy;
                    if (passwordPolicy.numeric != i) {
                        passwordPolicy.numeric = i;
                        updatePasswordValidityCheckpointLocked(i2, false);
                        saveSettingsLocked(i2, false, false, false);
                        AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                        String format = String.format("Admin %s has changed password minimum numeric to %d", componentName.getPackageName(), Integer.valueOf(i));
                        auditLogHelper.getClass();
                        AuditLogHelper.makeAuditLogGroupSecurity(i2, format);
                    }
                    logPasswordQualitySetIfSecurityLogEnabled(componentName, i2, false, passwordPolicy);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setPasswordMinimumSymbols(ComponentName componentName, int i, boolean z) {
        if (!this.mHasFeature || notSupportedOnAutomotive("setPasswordMinimumSymbols")) {
            return;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 0, z);
                ensureMinimumQuality(userHandleGetCallingUserId, activeAdminOrCheckPermissionForCallerLocked, 393216, "setPasswordMinimumSymbols");
                PasswordPolicy passwordPolicy = activeAdminOrCheckPermissionForCallerLocked.mPasswordPolicy;
                if (passwordPolicy.symbols != i) {
                    passwordPolicy.symbols = i;
                    updatePasswordValidityCheckpointLocked(userHandleGetCallingUserId, z);
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
                logPasswordQualitySetIfSecurityLogEnabled(componentName, userHandleGetCallingUserId, z, passwordPolicy);
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger.createEvent(8).setAdmin(componentName).setInt(i).write();
    }

    public final void setPasswordMinimumSymbolsMDM(ComponentName componentName, int i, int i2) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(0, i2, componentName);
                    ensureMinimumQuality(i2, activeAdminForCallerLockedMDM, 393216, "setPasswordMinimumSymbols");
                    PasswordPolicy passwordPolicy = activeAdminForCallerLockedMDM.mPasswordPolicy;
                    if (passwordPolicy.symbols != i) {
                        passwordPolicy.symbols = i;
                        updatePasswordValidityCheckpointLocked(i2, false);
                        saveSettingsLocked(i2, false, false, false);
                        AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                        String format = String.format("Admin %s has changed password minimum symbols to %d", componentName.getPackageName(), Integer.valueOf(i));
                        auditLogHelper.getClass();
                        AuditLogHelper.makeAuditLogGroupSecurity(i2, format);
                    }
                    logPasswordQualitySetIfSecurityLogEnabled(componentName, i2, false, passwordPolicy);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setPasswordMinimumUpperCase(ComponentName componentName, int i, boolean z) {
        if (!this.mHasFeature || notSupportedOnAutomotive("setPasswordMinimumUpperCase")) {
            return;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        this.mInjector.getClass();
        int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
        synchronized (getLockObject()) {
            try {
                ActiveAdmin activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 0, z);
                ensureMinimumQuality(userHandleGetCallingUserId, activeAdminOrCheckPermissionForCallerLocked, 393216, "setPasswordMinimumUpperCase");
                PasswordPolicy passwordPolicy = activeAdminOrCheckPermissionForCallerLocked.mPasswordPolicy;
                if (passwordPolicy.upperCase != i) {
                    passwordPolicy.upperCase = i;
                    updatePasswordValidityCheckpointLocked(userHandleGetCallingUserId, z);
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                }
                logPasswordQualitySetIfSecurityLogEnabled(componentName, userHandleGetCallingUserId, z, passwordPolicy);
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger.createEvent(7).setAdmin(componentName).setInt(i).write();
    }

    public final void setPasswordMinimumUpperCaseMDM(ComponentName componentName, int i, int i2) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(0, i2, componentName);
                    ensureMinimumQuality(i2, activeAdminForCallerLockedMDM, 393216, "setPasswordMinimumUpperCase");
                    PasswordPolicy passwordPolicy = activeAdminForCallerLockedMDM.mPasswordPolicy;
                    if (passwordPolicy.upperCase != i) {
                        passwordPolicy.upperCase = i;
                        updatePasswordValidityCheckpointLocked(i2, false);
                        saveSettingsLocked(i2, false, false, false);
                        AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                        String format = String.format("Admin %s has changed password minimum upper case to %d", componentName.getPackageName(), Integer.valueOf(i));
                        auditLogHelper.getClass();
                        AuditLogHelper.makeAuditLogGroupSecurity(i2, format);
                    }
                    logPasswordQualitySetIfSecurityLogEnabled(componentName, i2, false, passwordPolicy);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    /* JADX WARN: Code restructure failed: missing block: B:39:0x00ba, code lost:
    
        if (r1.intValue() != 0) goto L56;
     */
    /* JADX WARN: Removed duplicated region for block: B:19:0x0058  */
    /* JADX WARN: Removed duplicated region for block: B:28:0x008a  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void setPasswordQuality(final android.content.ComponentName r13, final int r14, final boolean r15) {
        /*
            Method dump skipped, instructions count: 261
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.setPasswordQuality(android.content.ComponentName, int, boolean):void");
    }

    public final void setPasswordQualityMDM(ComponentName componentName, int i, int i2) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            validateQualityConstant(i);
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin activeAdminForCallerLockedMDM = getActiveAdminForCallerLockedMDM(0, i2, componentName);
                    PasswordPolicy passwordPolicy = activeAdminForCallerLockedMDM.mPasswordPolicy;
                    if (passwordPolicy.quality != i) {
                        passwordPolicy.quality = i;
                        resetInactivePasswordRequirementsIfRPlus(i2, activeAdminForCallerLockedMDM);
                        updatePasswordValidityCheckpointLocked(i2, false);
                        updatePasswordQualityCacheForUserGroup(i2);
                        saveSettingsLocked(i2, false, false, false);
                        AuditLogHelper auditLogHelper = this.mAuditLogHelper;
                        String format = String.format("Admin %s has changed password quality to %d", componentName.getPackageName(), Integer.valueOf(i));
                        auditLogHelper.getClass();
                        AuditLogHelper.makeAuditLogGroupSecurity(i2, format);
                    }
                    logPasswordQualitySetIfSecurityLogEnabled(componentName, i2, false, passwordPolicy);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setPermissionGrantState(ComponentName componentName, String str, String str2, String str3, int i, final RemoteCallback remoteCallback) {
        boolean z;
        Objects.requireNonNull(remoteCallback);
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        checkCanExecuteOrThrowUnsafe(37);
        synchronized (getLockObject()) {
            try {
                if (isFinancedDeviceOwner(callerIdentity)) {
                    enforcePermissionGrantStateOnFinancedDevice(str2, str3);
                }
            } finally {
            }
        }
        Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity) || isFinancedDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-permission-grant")));
        if (((ArrayList) SENSOR_PERMISSIONS).contains(str3) && i == 1 && !canAdminGrantSensorsPermissions()) {
            Injector injector = this.mInjector;
            String str4 = callerIdentity.mPackageName;
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            injector.getClass();
            if (Injector.isChangeEnabled(userId, str4, 277035314L)) {
                throw new SecurityException("Caller not permitted to grant sensor permissions.");
            }
            Slogf.e("DevicePolicyManager", "Caller attempted to grant sensor permissions but denied");
            remoteCallback.sendResult(Bundle.EMPTY);
            return;
        }
        synchronized (getLockObject()) {
            this.mInjector.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                try {
                    if (getTargetSdk(UserHandle.getUserId(callerIdentity.mUid), callerIdentity.mPackageName) < 29 && getTargetSdk(UserHandle.getUserId(callerIdentity.mUid), str2) < 23) {
                        remoteCallback.sendResult((Bundle) null);
                        return;
                    }
                    z = false;
                    try {
                        if ((this.mInjector.mContext.getPackageManager().getPermissionInfo(str3, 0).protectionLevel & 15) == 1) {
                            z = true;
                        }
                    } catch (PackageManager.NameNotFoundException unused) {
                    }
                } catch (SecurityException e) {
                    Slogf.e("DevicePolicyManager", "Could not set permission grant state", e);
                    remoteCallback.sendResult((Bundle) null);
                    this.mInjector.getClass();
                }
                if (!z) {
                    remoteCallback.sendResult((Bundle) null);
                    return;
                }
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                synchronized (getLockObject()) {
                    this.mInjector.getClass();
                    clearCallingIdentity = Binder.clearCallingIdentity();
                    try {
                        try {
                            final boolean z2 = getTargetSdk(UserHandle.getUserId(callerIdentity.mUid), callerIdentity.mPackageName) >= 29;
                            if (i == 1 || i == 2 || i == 0) {
                                this.mInjector.getPermissionControllerManager(UserHandle.getUserHandleForUid(callerIdentity.mUid)).setRuntimePermissionGrantStateByDeviceAdmin(callerIdentity.mPackageName, new AdminPermissionControlParams(str2, str3, i, canAdminGrantSensorsPermissions()), this.mContext.getMainExecutor(), new Consumer() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda129
                                    @Override // java.util.function.Consumer
                                    public final void accept(Object obj) {
                                        boolean z3 = z2;
                                        RemoteCallback remoteCallback2 = remoteCallback;
                                        Boolean bool = (Boolean) obj;
                                        if (!z3 || bool.booleanValue()) {
                                            remoteCallback2.sendResult(Bundle.EMPTY);
                                        } else {
                                            remoteCallback2.sendResult((Bundle) null);
                                        }
                                    }
                                });
                            }
                            this.mInjector.getClass();
                        } catch (SecurityException e2) {
                            Slogf.e("DevicePolicyManager", "Could not set permission grant state", e2);
                            remoteCallback.sendResult((Bundle) null);
                            this.mInjector.getClass();
                        }
                        Binder.restoreCallingIdentity(clearCallingIdentity);
                    } finally {
                    }
                }
                if (str2 == null || str2.isEmpty() || str2.equalsIgnoreCase("null")) {
                    str2 = "unknown";
                }
                Bundle bundle = new Bundle();
                bundle.putCharSequence("targetPackageName", str2);
                DevicePolicyEventLogger.createEvent(19).setAdmin(callerIdentity.mPackageName).setStrings(new String[]{str3}).setKnoxBundleValue(bundle).setInt(i).setBoolean(isCallerDelegate(callerIdentity)).write();
            } finally {
            }
        }
    }

    public final void setPermissionPolicy(ComponentName componentName, String str, int i) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        Preconditions.checkCallAuthorization((callerIdentity.hasAdminComponent() && (isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity))) || (callerIdentity.hasPackage() && isCallerDelegate(callerIdentity, "delegation-permission-grant")));
        checkCanExecuteOrThrowUnsafe(38);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userData = getUserData(userId);
                if (userData.mPermissionPolicy != i) {
                    userData.mPermissionPolicy = i;
                    DevicePolicyCacheImpl devicePolicyCacheImpl = this.mPolicyCache;
                    synchronized (devicePolicyCacheImpl.mLock) {
                        devicePolicyCacheImpl.mPermissionPolicy.put(userId, i);
                    }
                    saveSettingsLocked(userId, false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger.createEvent(18).setAdmin(callerIdentity.mPackageName).setInt(i).setBoolean(componentName == null).write();
    }

    public final boolean setPermittedAccessibilityServices(ComponentName componentName, List list) {
        if (!this.mHasFeature) {
            return false;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        if (list != null) {
            Iterator it = list.iterator();
            while (it.hasNext()) {
                PolicySizeVerifier.enforceMaxPackageNameLength((String) it.next());
            }
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            this.mInjector.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                UserInfo userInfo = getUserInfo(userId);
                if (userInfo.isManagedProfile()) {
                    userId = userInfo.profileGroupId;
                }
                List list2 = (List) withAccessibilityManager(userId, new DevicePolicyManagerService$$ExternalSyntheticLambda15(4));
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                if (list2 != null) {
                    ArrayList arrayList = new ArrayList();
                    Iterator it2 = list2.iterator();
                    while (it2.hasNext()) {
                        arrayList.add(((AccessibilityServiceInfo) it2.next()).getResolveInfo().serviceInfo.packageName);
                    }
                    if (!checkPackagesInPermittedListOrSystem(userId, arrayList, list)) {
                        Slogf.e("DevicePolicyManager", "Cannot set permitted accessibility services, because it contains already enabled accesibility services.");
                        return false;
                    }
                }
            } catch (Throwable th) {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                throw th;
            }
        }
        synchronized (getLockObject()) {
            getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).permittedAccessiblityServices = list;
            saveSettingsLocked(UserHandle.getCallingUserId(), false, false, false);
        }
        DevicePolicyEventLogger.createEvent(28).setAdmin(componentName).setStrings(list != null ? (String[]) list.toArray(new String[0]) : null).write();
        return true;
    }

    public final boolean setPermittedCrossProfileNotificationListeners(ComponentName componentName, List list) {
        if (!this.mHasFeature) {
            return false;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        if (!isManagedProfile(UserHandle.getUserId(callerIdentity.mUid))) {
            return false;
        }
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity));
        synchronized (getLockObject()) {
            getProfileOwnerLocked(UserHandle.getUserId(callerIdentity.mUid)).permittedNotificationListeners = list;
            saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
        }
        return true;
    }

    public final boolean setPermittedInputMethods(ComponentName componentName, String str, List list, boolean z) {
        if (!this.mHasFeature) {
            return false;
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        final int profileParentUserIfRequested = getProfileParentUserIfRequested(UserHandle.getUserId(callerIdentity.mUid), z);
        if (z) {
            Preconditions.checkArgument(list == null || list.isEmpty(), "Permitted input methods must allow all input methods or only system input methods when called on the parent instance of an organization-owned device");
        }
        if (list != null) {
            if (!Flags.devicePolicySizeTrackingInternalBugFixEnabled()) {
                Iterator it = list.iterator();
                while (it.hasNext()) {
                    PolicySizeVerifier.enforceMaxPackageNameLength((String) it.next());
                }
            }
            Injector injector = this.mInjector;
            FunctionalUtils.ThrowingSupplier throwingSupplier = new FunctionalUtils.ThrowingSupplier() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda191
                public final Object getOrThrow() {
                    return InputMethodManagerInternal.get().getEnabledInputMethodListAsUser(profileParentUserIfRequested);
                }
            };
            injector.getClass();
            List list2 = (List) Binder.withCleanCallingIdentity(throwingSupplier);
            if (list2 != null) {
                ArrayList arrayList = new ArrayList();
                Iterator it2 = list2.iterator();
                while (it2.hasNext()) {
                    arrayList.add(((InputMethodInfo) it2.next()).getPackageName());
                }
                if (!checkPackagesInPermittedListOrSystem(profileParentUserIfRequested, arrayList, list)) {
                    Slogf.e("DevicePolicyManager", "Cannot set permitted input methods, because the list of permitted input methods excludes an already-enabled input method.");
                    return false;
                }
            }
        }
        synchronized (getLockObject()) {
            try {
                EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = enforcePermissionAndGetEnforcingAdmin(profileParentUserIfRequested, componentName, "android.permission.MANAGE_DEVICE_POLICY_INPUT_METHODS", callerIdentity.mPackageName);
                if (list == null) {
                    this.mDevicePolicyEngine.removeLocalPolicy(PolicyDefinition.PERMITTED_INPUT_METHODS, enforcePermissionAndGetEnforcingAdmin, profileParentUserIfRequested);
                } else {
                    this.mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.PERMITTED_INPUT_METHODS, enforcePermissionAndGetEnforcingAdmin, new PackageSetPolicyValue(new HashSet(list)), profileParentUserIfRequested, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger admin = DevicePolicyEventLogger.createEvent(27).setAdmin(callerIdentity.mPackageName);
        ArrayList arrayList2 = new ArrayList();
        arrayList2.add(z ? "calledFromParent" : "notCalledFromParent");
        if (list == null) {
            arrayList2.add("nullStringArray");
        } else {
            arrayList2.addAll(list);
        }
        admin.setStrings((String[]) arrayList2.toArray(new String[0])).write();
        return true;
    }

    public final void setPersonalAppsSuspended(ComponentName componentName, boolean z) {
        boolean z2;
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda7 devicePolicyManagerService$$ExternalSyntheticLambda7 = new DevicePolicyManagerService$$ExternalSyntheticLambda7(this, callerIdentity, 6);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda7);
        boolean z3 = true;
        Preconditions.checkState(true);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerLocked = getProfileOwnerLocked(userId);
                if (profileOwnerLocked.mSuspendPersonalApps != z) {
                    profileOwnerLocked.mSuspendPersonalApps = z;
                    z2 = true;
                } else {
                    z2 = false;
                }
                if (profileOwnerLocked.mProfileOffDeadline != 0) {
                    profileOwnerLocked.mProfileOffDeadline = 0L;
                } else {
                    z3 = z2;
                }
                if (z3) {
                    saveSettingsLocked(userId, false, false, false);
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        Injector injector2 = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda6 devicePolicyManagerService$$ExternalSyntheticLambda6 = new DevicePolicyManagerService$$ExternalSyntheticLambda6(this, userId, 3);
        injector2.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda6);
        DevicePolicyEventLogger.createEvent(135).setAdmin(callerIdentity.mComponentName).setBoolean(z).write();
    }

    public final void setPreferentialNetworkServiceConfigs(List list) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(null, null);
            Preconditions.checkCallAuthorization((isProfileOwner(callerIdentity) && isManagedProfile(UserHandle.getUserId(callerIdentity.mUid))) || isDefaultDeviceOwner(callerIdentity), "Caller is not managed profile owner or device owner; only managed profile owner or device owner may control the preferential network service");
            try {
                updateNetworkPreferenceForUser(UserHandle.getUserId(callerIdentity.mUid), list);
                synchronized (getLockObject()) {
                    try {
                        ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(UserHandle.getUserId(callerIdentity.mUid));
                        if (!deviceOrProfileOwnerAdminLocked.mPreferentialNetworkServiceConfigs.equals(list)) {
                            deviceOrProfileOwnerAdminLocked.mPreferentialNetworkServiceConfigs = new ArrayList(list);
                            saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                        }
                    } catch (Throwable th) {
                        throw th;
                    }
                }
                DevicePolicyEventLogger.createEvent(FrameworkStatsLog.DEVICE_POLICY_EVENT__EVENT_ID__SET_PREFERENTIAL_NETWORK_SERVICE_ENABLED).setBoolean(list.stream().anyMatch(new DevicePolicyManagerService$$ExternalSyntheticLambda9(3))).write();
            } catch (Exception e) {
                Slogf.e("DevicePolicyManager", "Failed to set preferential network service configs");
                throw e;
            }
        }
    }

    public final void setProfileEnabled(ComponentName componentName) {
        if (!this.mHasFeature) {
            logMissingFeatureAction("Cannot enable profile for " + ComponentName.flattenToShortString(componentName));
            return;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        boolean z = true;
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        Preconditions.checkCallingUser(isManagedProfile(userId));
        synchronized (getLockObject()) {
            try {
                UserInfo userInfo = getUserInfo(userId);
                if (!this.mOwners.hasDeviceOwner() || !isManagedProfile(userId)) {
                    z = false;
                }
                Log.i("DevicePolicyManager", "setProfileEnabled isAppSeparationUserId " + z);
                if (userInfo.isEnabled() && !z) {
                    Slogf.e("DevicePolicyManager", "setProfileEnabled is called when the profile is already enabled");
                    return;
                }
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda29 devicePolicyManagerService$$ExternalSyntheticLambda29 = new DevicePolicyManagerService$$ExternalSyntheticLambda29(userId, 3, this);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda29);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setProfileName(ComponentName componentName, String str) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        Bundle bundle = new Bundle();
        bundle.putInt("userId", UserHandle.getUserId(callerIdentity.mUid));
        String substring = str.substring(0, Math.min(str.length(), 200));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda44 devicePolicyManagerService$$ExternalSyntheticLambda44 = new DevicePolicyManagerService$$ExternalSyntheticLambda44(this, callerIdentity, substring, bundle);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda44);
    }

    public final boolean setProfileOwner(ComponentName componentName, int i) {
        if (!this.mHasFeature) {
            logMissingFeatureAction("Cannot set " + ComponentName.flattenToShortString(componentName) + " as profile owner for user " + i);
            return false;
        }
        Preconditions.checkArgument(componentName != null);
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        boolean hasIncompatibleAccountsOrNonAdbNoLock = hasIncompatibleAccountsOrNonAdbNoLock(callerIdentity, i, componentName);
        synchronized (getLockObject()) {
            try {
                enforceCanSetProfileOwnerLocked(callerIdentity, componentName, i, hasIncompatibleAccountsOrNonAdbNoLock);
                ActiveAdmin activeAdminUncheckedLocked = getActiveAdminUncheckedLocked(i, componentName);
                Preconditions.checkArgument((!isPackageInstalledForUser(i, componentName.getPackageName()) || activeAdminUncheckedLocked == null || getUserData(i).mRemovingAdmins.contains(componentName)) ? false : true, "Not active admin: " + componentName);
                int profileParentId = getProfileParentId(i);
                if (profileParentId != i && this.mUserManager.hasUserRestriction("no_add_managed_profile", UserHandle.of(profileParentId)) && !getUserInfo(i).isUserTypeAppSeparation()) {
                    Slogf.i("DevicePolicyManager", "Cannot set profile owner because of restriction.");
                    return false;
                }
                if (isAdb(callerIdentity)) {
                    MetricsLogger.action(this.mContext, 617, "profile-owner");
                    DevicePolicyEventLogger.createEvent(82).setAdmin(componentName).setStrings(new String[]{"profile-owner"}).write();
                }
                toggleBackupServiceActive(i, false);
                this.mOwners.setProfileOwner(i, componentName);
                this.mOwners.writeProfileOwner(i);
                Slogf.i("DevicePolicyManager", "Profile owner set: " + componentName + " on user " + i);
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda101 devicePolicyManagerService$$ExternalSyntheticLambda101 = new DevicePolicyManagerService$$ExternalSyntheticLambda101(this, i, activeAdminUncheckedLocked, 1);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda101);
                this.mDeviceAdminServiceController.startServiceForAdmin(i, componentName.getPackageName());
                return true;
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setProfileOwnerOnOrganizationOwnedDevice(ComponentName componentName, int i, boolean z) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName);
            CallerIdentity callerIdentity = getCallerIdentity(null, null);
            if (!isAdb(callerIdentity) && !hasCallingPermission("android.permission.MARK_DEVICE_ORGANIZATION_OWNED") && !hasCallingPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS")) {
                throw new SecurityException("Only the system can mark a profile owner of organization-owned device.");
            }
            synchronized (getLockObject()) {
                if (!z) {
                    try {
                        if (!isAdminTestOnlyLocked(i, componentName)) {
                            throw new SecurityException("Only a test admin can be unmarked as a profile owner of organization-owned device.");
                        }
                    } catch (Throwable th) {
                        throw th;
                    }
                }
            }
            if (isAdb(callerIdentity)) {
                if (hasIncompatibleAccountsOrNonAdbNoLock(callerIdentity, i, componentName)) {
                    throw new SecurityException("Can only be called from ADB if the device has no accounts.");
                }
            } else if (hasUserSetupCompleted(0)) {
                throw new IllegalStateException("Cannot mark profile owner as managing an organization-owned device after set-up");
            }
            synchronized (getLockObject()) {
                setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(i, componentName, z);
            }
            this.mInjector.getClass();
            KnoxPolicyHelper knoxPolicyHelper = this.mKnoxPolicyHelper;
            knoxPolicyHelper.getClass();
            long clearCallingIdentity = Binder.clearCallingIdentity();
            try {
                try {
                    if (knoxPolicyHelper.getIEDMService() != null) {
                        Log.d("KnoxPolicyHelper", "addPseudoAdminForWpcod:: containerId-" + i);
                        knoxPolicyHelper.mEdmService.addPseudoAdminForParent(i);
                    }
                } finally {
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                }
            } catch (Exception e) {
                Log.d("KnoxPolicyHelper", "addPseudoAdminForWpcod: exception: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    public final void setProfileOwnerOnOrganizationOwnedDeviceUncheckedLocked(int i, ComponentName componentName, boolean z) {
        if (!isProfileOwner(i, componentName)) {
            throw new IllegalArgumentException(String.format("Component %s is not a Profile Owner of user %d", componentName.flattenToString(), Integer.valueOf(i)));
        }
        Slogf.i("DevicePolicyManager", "%s %s as profile owner on organization-owned device for user %d", z ? "Marking" : "Unmarking", componentName.flattenToString(), Integer.valueOf(i));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda31 devicePolicyManagerService$$ExternalSyntheticLambda31 = new DevicePolicyManagerService$$ExternalSyntheticLambda31(i, this, z);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda31);
        Owners owners = this.mOwners;
        synchronized (owners.mData) {
            try {
                OwnersData.OwnerInfo ownerInfo = (OwnersData.OwnerInfo) owners.mData.mProfileOwners.get(Integer.valueOf(i));
                if (ownerInfo != null) {
                    ownerInfo.isOrganizationOwnedDevice = z;
                } else {
                    Slog.e("DevicePolicyManagerService", String.format("No profile owner for user %d to set org-owned flag.", Integer.valueOf(i)));
                }
                owners.writeProfileOwner(i);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setRecommendedGlobalProxy(ComponentName componentName, ProxyInfo proxyInfo) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        Preconditions.checkCallAuthorization(areAllUsersAffiliatedWithDeviceLocked(), "operation not allowed when device has unaffiliated users");
        this.mInjector.getClass();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda46 devicePolicyManagerService$$ExternalSyntheticLambda46 = new DevicePolicyManagerService$$ExternalSyntheticLambda46(3, this, proxyInfo);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda46);
    }

    public final void setRequiredPasswordComplexity(String str, int i, final boolean z) {
        ActiveAdmin profileOwnerOrDeviceOwnerLocked;
        if (this.mHasFeature) {
            boolean z2 = false;
            Preconditions.checkArgument(Set.of(0, Integer.valueOf(EndpointMonitorConst.FLAG_TRACING_NETWORK_EVENT_ABNORMAL_PKT), 196608, 327680).contains(Integer.valueOf(i)), "Provided complexity is not one of the allowed values.");
            if (Flags.unmanagedModeMigration()) {
                final CallerIdentity callerIdentity = getCallerIdentity(null, str);
                int profileParentId = z ? getProfileParentId(UserHandle.getUserId(callerIdentity.mUid)) : UserHandle.getUserId(callerIdentity.mUid);
                EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), null, "android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", callerIdentity.mPackageName);
                Preconditions.checkArgument(!z || isProfileOwner(callerIdentity));
                final ActiveAdmin activeAdmin = enforcePermissionAndGetEnforcingAdmin.mActiveAdmin;
                if (!z) {
                    if (activeAdmin.parentAdmin != null && activeAdmin.getParentActiveAdmin().mPasswordPolicy.quality != 0) {
                        z2 = true;
                    }
                    Preconditions.checkState(!z2, "Password quality is set on the parent when attempting to set passwordcomplexity. Clear the quality by setting the password quality on the parent to PASSWORD_QUALITY_UNSPECIFIED first");
                }
                if (i != 0) {
                    this.mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.PASSWORD_COMPLEXITY, enforcePermissionAndGetEnforcingAdmin, new IntegerPolicyValue(i), profileParentId, false);
                } else {
                    this.mDevicePolicyEngine.removeLocalPolicy(PolicyDefinition.PASSWORD_COMPLEXITY, enforcePermissionAndGetEnforcingAdmin, profileParentId);
                }
                Injector injector = this.mInjector;
                FunctionalUtils.ThrowingRunnable throwingRunnable = new FunctionalUtils.ThrowingRunnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda97
                    public final void runOrThrow() {
                        DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                        boolean z3 = z;
                        ActiveAdmin activeAdmin2 = activeAdmin;
                        CallerIdentity callerIdentity2 = callerIdentity;
                        devicePolicyManagerService.getClass();
                        if (z3) {
                            activeAdmin2.getParentActiveAdmin().mPasswordPolicy = new PasswordPolicy();
                        } else {
                            activeAdmin2.mPasswordPolicy = new PasswordPolicy();
                        }
                        synchronized (devicePolicyManagerService.getLockObject()) {
                            devicePolicyManagerService.updatePasswordValidityCheckpointLocked(UserHandle.getUserId(callerIdentity2.mUid), z3);
                        }
                        devicePolicyManagerService.updatePasswordQualityCacheForUserGroup(UserHandle.getUserId(callerIdentity2.mUid));
                        devicePolicyManagerService.saveSettingsLocked(UserHandle.getUserId(callerIdentity2.mUid), false, false, false);
                    }
                };
                injector.getClass();
                Binder.withCleanCallingIdentity(throwingRunnable);
                DevicePolicyEventLogger.createEvent(177).setAdmin(callerIdentity.mPackageName).setInt(i).setBoolean(z).write();
                logPasswordComplexityRequiredIfSecurityLogEnabled(UserHandle.getUserId(callerIdentity.mUid), i, callerIdentity.mPackageName, z);
                return;
            }
            CallerIdentity callerIdentity2 = getCallerIdentity(null, str);
            if (!isPermissionCheckFlagEnabled()) {
                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity2) || isProfileOwner(callerIdentity2));
                Preconditions.checkArgument(!z || isProfileOwner(callerIdentity2));
            }
            synchronized (getLockObject()) {
                try {
                    if (isPermissionCheckFlagEnabled()) {
                        profileOwnerOrDeviceOwnerLocked = enforcePermissionAndGetEnforcingAdmin(z ? getProfileParentId(UserHandle.getUserId(callerIdentity2.mUid)) : UserHandle.getUserId(callerIdentity2.mUid), null, "android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", callerIdentity2.mPackageName).mActiveAdmin;
                    } else {
                        profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity2.mUid));
                        Objects.requireNonNull(profileOwnerOrDeviceOwnerLocked);
                        if (z) {
                            profileOwnerOrDeviceOwnerLocked = profileOwnerOrDeviceOwnerLocked.getParentActiveAdmin();
                        }
                    }
                    if (profileOwnerOrDeviceOwnerLocked.mPasswordComplexity != i) {
                        if (!z) {
                            if (profileOwnerOrDeviceOwnerLocked.parentAdmin == null || profileOwnerOrDeviceOwnerLocked.getParentActiveAdmin().mPasswordPolicy.quality == 0) {
                                z2 = true;
                            }
                            Preconditions.checkState(z2, "Password quality is set on the parent when attempting to set passwordcomplexity. Clear the quality by setting the password quality on the parent to PASSWORD_QUALITY_UNSPECIFIED first");
                        }
                        Injector injector2 = this.mInjector;
                        DevicePolicyManagerService$$ExternalSyntheticLambda104 devicePolicyManagerService$$ExternalSyntheticLambda104 = new DevicePolicyManagerService$$ExternalSyntheticLambda104(this, profileOwnerOrDeviceOwnerLocked, i, callerIdentity2, z);
                        injector2.getClass();
                        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda104);
                        DevicePolicyEventLogger.createEvent(177).setAdmin(profileOwnerOrDeviceOwnerLocked.info.getPackageName()).setInt(i).setBoolean(z).write();
                    }
                    logPasswordComplexityRequiredIfSecurityLogEnabled(UserHandle.getUserId(callerIdentity2.mUid), i, callerIdentity2.mPackageName, z);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setRequiredStrongAuthTimeout(ComponentName componentName, String str, long j, boolean z) {
        CallerIdentity callerIdentity;
        long min;
        ActiveAdmin profileOwnerOrDeviceOwnerLocked;
        if (this.mHasFeature && this.mLockPatternUtils.hasSecureLockScreen()) {
            boolean z2 = true;
            Preconditions.checkArgument(j >= 0, "Timeout must not be a negative number.");
            if (isPermissionCheckFlagEnabled()) {
                callerIdentity = getCallerIdentity(componentName, str);
            } else {
                callerIdentity = getCallerIdentity(componentName);
                Objects.requireNonNull(componentName, "ComponentName is null");
                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
            }
            this.mInjector.getClass();
            if (Build.IS_DEBUGGABLE) {
                Injector injector = this.mInjector;
                long j2 = MINIMUM_STRONG_AUTH_TIMEOUT_MS;
                injector.getClass();
                min = Math.min(SystemProperties.getLong("persist.sys.min_str_auth_timeo", j2), j2);
            } else {
                min = MINIMUM_STRONG_AUTH_TIMEOUT_MS;
            }
            if (j != 0 && j < min) {
                j = min;
            }
            if (j > 259200000) {
                j = 259200000;
            }
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            synchronized (getLockObject()) {
                try {
                    if (isPermissionCheckFlagEnabled()) {
                        profileOwnerOrDeviceOwnerLocked = enforcePermissionAndGetEnforcingAdmin(z ? getProfileParentId(UserHandle.getUserId(callerIdentity.mUid)) : UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", callerIdentity.mPackageName).mActiveAdmin;
                    } else {
                        profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                        Objects.requireNonNull(profileOwnerOrDeviceOwnerLocked);
                        if (z) {
                            profileOwnerOrDeviceOwnerLocked = profileOwnerOrDeviceOwnerLocked.getParentActiveAdmin();
                        }
                    }
                    if (profileOwnerOrDeviceOwnerLocked.strongAuthUnlockTimeout != j) {
                        profileOwnerOrDeviceOwnerLocked.strongAuthUnlockTimeout = j;
                        saveSettingsLocked(userId, false, false, false);
                    } else {
                        z2 = false;
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (z2) {
                this.mLockSettingsInternal.refreshStrongAuthTimeout(userId);
                if (!isManagedProfile(userId) || isSeparateProfileChallengeEnabled(userId)) {
                    return;
                }
                this.mLockSettingsInternal.refreshStrongAuthTimeout(getProfileParentId(userId));
            }
        }
    }

    public final boolean setResetPasswordToken(ComponentName componentName, String str, byte[] bArr) {
        boolean z;
        this.mInjector.getClass();
        Injector.logUserForSDP(Injector.userHandleGetCallingUserId(), "Set reset token for user ");
        this.mInjector.getClass();
        SDPLog.p("admin", componentName, KnoxCustomManagerService.SPCM_KEY_TOKEN, bArr);
        if (!this.mHasFeature || !this.mLockPatternUtils.hasSecureLockScreen()) {
            return false;
        }
        if (bArr == null || bArr.length < 32) {
            throw new IllegalArgumentException("token must be at least 32-byte long");
        }
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            DevicePolicyData userData = getUserData(userId);
            long j = userData.mPasswordTokenHandle;
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda23 devicePolicyManagerService$$ExternalSyntheticLambda23 = new DevicePolicyManagerService$$ExternalSyntheticLambda23(this, j, userId, 1);
            injector.getClass();
            ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda23)).getClass();
            Injector injector2 = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda64 devicePolicyManagerService$$ExternalSyntheticLambda64 = new DevicePolicyManagerService$$ExternalSyntheticLambda64(this, bArr, userId);
            injector2.getClass();
            userData.mPasswordTokenHandle = ((Long) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda64)).longValue();
            saveSettingsLocked(userId, false, false, false);
            z = userData.mPasswordTokenHandle != 0;
        }
        return z;
    }

    public final boolean setResetPasswordTokenMDM(ComponentName componentName, byte[] bArr, int i) {
        boolean z;
        if (!this.mHasFeature) {
            return false;
        }
        if (bArr == null || bArr.length < 32) {
            throw new IllegalArgumentException("token must be at least 32-byte long");
        }
        this.mInjector.getClass();
        Injector.logUserForSDP(Injector.userHandleGetCallingUserId(), "Set reset token MDM for user ");
        this.mInjector.getClass();
        SDPLog.p("admin", componentName, KnoxCustomManagerService.SPCM_KEY_TOKEN, bArr);
        synchronized (getLockObject()) {
            try {
                getActiveAdminForCallerLockedMDM(2, i, componentName);
                DevicePolicyData userData = getUserData(i);
                this.mInjector.getClass();
                long clearCallingIdentity = Binder.clearCallingIdentity();
                try {
                    long j = userData.mPasswordTokenHandle;
                    if (j != 0) {
                        this.mLockPatternUtils.removeEscrowToken(j, i);
                    }
                    userData.mPasswordTokenHandle = this.mLockPatternUtils.addEscrowToken(bArr, i, (LockPatternUtils.EscrowTokenStateChangeCallback) null);
                    saveSettingsLocked(i, false, false, false);
                    z = userData.mPasswordTokenHandle != 0;
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                } catch (Throwable th) {
                    this.mInjector.getClass();
                    Binder.restoreCallingIdentity(clearCallingIdentity);
                    throw th;
                }
            } catch (Throwable th2) {
                throw th2;
            }
        }
        return z;
    }

    public final void setRestrictionsProvider(ComponentName componentName, ComponentName componentName2) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        checkCanExecuteOrThrowUnsafe(39);
        synchronized (getLockObject()) {
            int userId = UserHandle.getUserId(callerIdentity.mUid);
            getUserData(userId).mRestrictionsProvider = componentName2;
            saveSettingsLocked(userId, false, false, false);
        }
    }

    public final void setScreenCaptureDisabled(ComponentName componentName, String str, boolean z, boolean z2) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            int identifier = Binder.getCallingUserHandle().getIdentifier();
            EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = enforcePermissionAndGetEnforcingAdmin(z2 ? getProfileParentId(identifier) : identifier, componentName, "android.permission.MANAGE_DEVICE_POLICY_SCREEN_CAPTURE", callerIdentity.mPackageName);
            if ((z2 && isProfileOwnerOfOrganizationOwnedDevice(callerIdentity)) || isDefaultDeviceOwner(callerIdentity)) {
                if (z) {
                    this.mDevicePolicyEngine.setGlobalPolicy(PolicyDefinition.SCREEN_CAPTURE_DISABLED, enforcePermissionAndGetEnforcingAdmin, new BooleanPolicyValue(z));
                } else {
                    this.mDevicePolicyEngine.removeGlobalPolicy(PolicyDefinition.SCREEN_CAPTURE_DISABLED, enforcePermissionAndGetEnforcingAdmin);
                }
            } else if (z) {
                this.mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.SCREEN_CAPTURE_DISABLED, enforcePermissionAndGetEnforcingAdmin, new BooleanPolicyValue(z), identifier, false);
            } else {
                this.mDevicePolicyEngine.removeLocalPolicy(PolicyDefinition.SCREEN_CAPTURE_DISABLED, enforcePermissionAndGetEnforcingAdmin, identifier);
            }
            DevicePolicyEventLogger.createEvent(29).setAdmin(callerIdentity.mPackageName).setBoolean(z).write();
        }
    }

    public final void setSecondaryLockscreenEnabled(ComponentName componentName, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        boolean z2 = true;
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity));
        Preconditions.checkCallAuthorization(!isManagedProfile(UserHandle.getUserId(callerIdentity.mUid)), "User %d is not allowed to call setSecondaryLockscreenEnabled", new Object[]{Integer.valueOf(UserHandle.getUserId(callerIdentity.mUid))});
        synchronized (getLockObject()) {
            try {
                if (!isAdminTestOnlyLocked(UserHandle.getUserId(callerIdentity.mUid), componentName) && !isSupervisionComponentLocked(callerIdentity.mComponentName)) {
                    z2 = false;
                }
                Preconditions.checkCallAuthorization(z2, "Admin %s is not the default supervision component", new Object[]{callerIdentity.mComponentName});
                getUserData(UserHandle.getUserId(callerIdentity.mUid)).mSecondaryLockscreenEnabled = z;
                saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setSecureSetting(ComponentName componentName, String str, String str2) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        boolean z = true;
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        synchronized (getLockObject()) {
            try {
                if (isDeviceOwner(userId, componentName)) {
                    if (!((ArraySet) SECURE_SETTINGS_DEVICEOWNER_ALLOWLIST).contains(str) && !isCurrentUserDemo()) {
                        throw new SecurityException(String.format("Permission denial: Device owners cannot update %1$s", str));
                    }
                } else if (!((ArraySet) SECURE_SETTINGS_ALLOWLIST).contains(str) && !isCurrentUserDemo()) {
                    throw new SecurityException(String.format("Permission denial: Profile owners cannot update %1$s", str));
                }
                if (str.equals("location_mode")) {
                    String packageName = componentName.getPackageName();
                    this.mInjector.getClass();
                    if (Injector.isChangeEnabled(userId, packageName, 117835097L)) {
                        throw new UnsupportedOperationException("location_mode is deprecated. Please use setLocationEnabled() instead.");
                    }
                }
                if (!str.equals("install_non_market_apps")) {
                    Injector injector = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda173 devicePolicyManagerService$$ExternalSyntheticLambda173 = new DevicePolicyManagerService$$ExternalSyntheticLambda173(this, str, userId, str2);
                    injector.getClass();
                    Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda173);
                    DevicePolicyEventLogger.createEvent(14).setAdmin(componentName).setStrings(new String[]{str, str2}).write();
                    return;
                }
                if (getTargetSdk(userId, componentName.getPackageName()) >= 26) {
                    throw new UnsupportedOperationException("install_non_market_apps is deprecated. Please use one of the user restrictions no_install_unknown_sources or no_install_unknown_sources_globally instead.");
                }
                if (this.mUserManager.isManagedProfile(userId)) {
                    try {
                        String packageName2 = componentName.getPackageName();
                        if (Integer.parseInt(str2) != 0) {
                            z = false;
                        }
                        setUserRestriction(componentName, packageName2, "no_install_unknown_sources", z, false);
                        DevicePolicyEventLogger.createEvent(14).setAdmin(componentName).setStrings(new String[]{str, str2}).write();
                    } catch (NumberFormatException unused) {
                        Slogf.e("DevicePolicyManager", "Invalid value: " + str2 + " for setting " + str);
                    }
                } else {
                    Slogf.e("DevicePolicyManager", "Ignoring setSecureSetting request for " + str + ". User restriction no_install_unknown_sources or no_install_unknown_sources_globally should be used instead.");
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setSecurityLoggingEnabled(ComponentName componentName, String str, boolean z) {
        if (this.mHasFeature) {
            CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            boolean z2 = true;
            if (Flags.securityLogV2Enabled()) {
                EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING", callerIdentity.mPackageName);
                if (z) {
                    this.mDevicePolicyEngine.setGlobalPolicy(PolicyDefinition.SECURITY_LOGGING, enforcePermissionAndGetEnforcingAdmin, new BooleanPolicyValue(true));
                } else {
                    this.mDevicePolicyEngine.removeGlobalPolicy(PolicyDefinition.SECURITY_LOGGING, enforcePermissionAndGetEnforcingAdmin);
                }
            } else {
                synchronized (getLockObject()) {
                    try {
                        if (componentName != null) {
                            if (!isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) && !isDefaultDeviceOwner(callerIdentity)) {
                                z2 = false;
                            }
                            Preconditions.checkCallAuthorization(z2);
                        } else {
                            Preconditions.checkCallAuthorization(isCallerDelegate(callerIdentity, "delegation-security-logging"));
                        }
                        this.mInjector.getClass();
                        if (z == SecurityLog.getLoggingEnabledProperty()) {
                            return;
                        }
                        this.mInjector.getClass();
                        SecurityLog.setLoggingEnabledProperty(z);
                        if (z) {
                            this.mSecurityLogMonitor.start(getSecurityLoggingEnabledUser());
                            maybePauseDeviceWideLoggingLocked();
                        } else {
                            this.mSecurityLogMonitor.stop();
                        }
                    } catch (Throwable th) {
                        throw th;
                    }
                }
            }
            DevicePolicyEventLogger.createEvent(15).setAdmin(callerIdentity.mPackageName).setBoolean(z).write();
        }
    }

    public final void setShortSupportMessage(ComponentName componentName, String str, CharSequence charSequence) {
        CallerIdentity callerIdentity;
        ActiveAdmin activeAdminForUidLocked;
        if (this.mHasFeature) {
            CharSequence truncateIfLonger = PolicySizeVerifier.truncateIfLonger(charSequence, 200);
            if (isPermissionCheckFlagEnabled()) {
                callerIdentity = getCallerIdentity(componentName, str);
                activeAdminForUidLocked = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE", callerIdentity.mPackageName).mActiveAdmin;
            } else {
                callerIdentity = getCallerIdentity(componentName);
                Objects.requireNonNull(componentName, "ComponentName is null");
                synchronized (getLockObject()) {
                    activeAdminForUidLocked = getActiveAdminForUidLocked(callerIdentity.mUid, componentName);
                }
            }
            synchronized (getLockObject()) {
                try {
                    if (!TextUtils.equals(activeAdminForUidLocked.shortSupportMessage, truncateIfLonger)) {
                        activeAdminForUidLocked.shortSupportMessage = truncateIfLonger;
                        saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    }
                } catch (Throwable th) {
                    throw th;
                }
            }
            DevicePolicyEventLogger.createEvent(43).setAdmin(callerIdentity.mPackageName).write();
        }
    }

    public final void setShowNewUserDisclaimer(int i, String str) {
        Slogf.i("DevicePolicyManager", "Setting new user disclaimer for user " + i + " as " + str);
        synchronized (getLockObject()) {
            getUserData(i).mNewUserDisclaimer = str;
            saveSettingsLocked(i, false, false, false);
        }
    }

    public final void setStartUserSessionMessage(ComponentName componentName, CharSequence charSequence) {
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
            String charSequence2 = charSequence != null ? charSequence.toString() : null;
            synchronized (getLockObject()) {
                try {
                    ActiveAdmin deviceOwnerAdminLocked = getDeviceOwnerAdminLocked();
                    if (TextUtils.equals(deviceOwnerAdminLocked.startUserSessionMessage, charSequence)) {
                        return;
                    }
                    deviceOwnerAdminLocked.startUserSessionMessage = charSequence2;
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                    this.mInjector.getClass();
                    Injector.getActivityManagerInternal().setSwitchingFromSystemUserMessage(charSequence2);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    /* JADX WARN: Code restructure failed: missing block: B:19:0x0063, code lost:
    
        if (android.app.ActivityTaskManager.getService().getLockTaskModeState() != 0) goto L25;
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final boolean setStatusBarDisabled(android.content.ComponentName r8, java.lang.String r9, boolean r10) {
        /*
            r7 = this;
            java.lang.String r9 = "Admin "
            com.android.server.devicepolicy.CallerIdentity r0 = r7.getCallerIdentity(r8)
            java.lang.String r1 = "ComponentName is null"
            java.util.Objects.requireNonNull(r8, r1)
            boolean r1 = r7.isProfileOwner(r0)
            r2 = 1
            r3 = 0
            if (r1 != 0) goto L1c
            boolean r1 = r7.isDefaultDeviceOwner(r0)
            if (r1 == 0) goto L1a
            goto L1c
        L1a:
            r1 = r3
            goto L1d
        L1c:
            r1 = r2
        L1d:
            com.android.internal.util.Preconditions.checkCallAuthorization(r1)
            int r1 = r0.mUid
            int r1 = android.os.UserHandle.getUserId(r1)
            java.lang.Object r4 = r7.getLockObject()
            monitor-enter(r4)
            boolean r5 = r7.isUserAffiliatedWithDeviceLocked(r1)     // Catch: java.lang.Throwable -> L66
            java.lang.StringBuilder r6 = new java.lang.StringBuilder     // Catch: java.lang.Throwable -> L66
            r6.<init>(r9)     // Catch: java.lang.Throwable -> L66
            r6.append(r8)     // Catch: java.lang.Throwable -> L66
            java.lang.String r8 = " is neither the device owner or affiliated user's profile owner."
            r6.append(r8)     // Catch: java.lang.Throwable -> L66
            java.lang.String r8 = r6.toString()     // Catch: java.lang.Throwable -> L66
            com.android.internal.util.Preconditions.checkCallAuthorization(r5, r8)     // Catch: java.lang.Throwable -> L66
            boolean r8 = r7.isManagedProfile(r1)     // Catch: java.lang.Throwable -> L66
            if (r8 != 0) goto L91
            r8 = 13
            r7.checkCanExecuteOrThrowUnsafe(r8)     // Catch: java.lang.Throwable -> L66
            com.android.server.devicepolicy.DevicePolicyData r8 = r7.getUserData(r1)     // Catch: java.lang.Throwable -> L66
            boolean r9 = r8.mStatusBarDisabled     // Catch: java.lang.Throwable -> L66
            if (r9 == r10) goto L7c
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r9 = r7.mInjector     // Catch: java.lang.Throwable -> L66 android.os.RemoteException -> L68
            r9.getClass()     // Catch: java.lang.Throwable -> L66 android.os.RemoteException -> L68
            android.app.IActivityTaskManager r9 = android.app.ActivityTaskManager.getService()     // Catch: java.lang.Throwable -> L66 android.os.RemoteException -> L68
            int r9 = r9.getLockTaskModeState()     // Catch: java.lang.Throwable -> L66 android.os.RemoteException -> L68
            if (r9 == 0) goto L6f
            goto L77
        L66:
            r7 = move-exception
            goto L99
        L68:
            java.lang.String r9 = "DevicePolicyManager"
            java.lang.String r5 = "Failed to get LockTask mode"
            com.android.server.utils.Slogf.e(r9, r5)     // Catch: java.lang.Throwable -> L66
        L6f:
            boolean r9 = r7.setStatusBarDisabledInternal(r1, r10)     // Catch: java.lang.Throwable -> L66
            if (r9 != 0) goto L77
            monitor-exit(r4)     // Catch: java.lang.Throwable -> L66
            return r3
        L77:
            r8.mStatusBarDisabled = r10     // Catch: java.lang.Throwable -> L66
            r7.saveSettingsLocked(r1, r3, r3, r3)     // Catch: java.lang.Throwable -> L66
        L7c:
            monitor-exit(r4)     // Catch: java.lang.Throwable -> L66
            r7 = 38
            android.app.admin.DevicePolicyEventLogger r7 = android.app.admin.DevicePolicyEventLogger.createEvent(r7)
            java.lang.String r8 = r0.mPackageName
            android.app.admin.DevicePolicyEventLogger r7 = r7.setAdmin(r8)
            android.app.admin.DevicePolicyEventLogger r7 = r7.setBoolean(r10)
            r7.write()
            return r2
        L91:
            java.lang.SecurityException r7 = new java.lang.SecurityException     // Catch: java.lang.Throwable -> L66
            java.lang.String r8 = "Managed profile cannot disable status bar"
            r7.<init>(r8)     // Catch: java.lang.Throwable -> L66
            throw r7     // Catch: java.lang.Throwable -> L66
        L99:
            monitor-exit(r4)     // Catch: java.lang.Throwable -> L66
            throw r7
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.setStatusBarDisabled(android.content.ComponentName, java.lang.String, boolean):boolean");
    }

    public final boolean setStatusBarDisabledInternal(int i, boolean z) {
        Injector injector;
        IStatusBarService asInterface;
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                asInterface = IStatusBarService.Stub.asInterface(ServiceManager.checkService("statusbar"));
            } catch (RemoteException e) {
                Slogf.e("DevicePolicyManager", "Failed to disable the status bar", e);
                injector = this.mInjector;
            }
            if (asInterface != null) {
                asInterface.disableForUser(z ? 34013184 : 0, this.mToken, this.mContext.getPackageName(), i);
                asInterface.disable2ForUser(z ? 1 : 0, this.mToken, this.mContext.getPackageName(), i);
                return true;
            }
            injector = this.mInjector;
            injector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            return false;
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final int setStorageEncryption(ComponentName componentName, boolean z) {
        if (!this.mHasFeature) {
            return 0;
        }
        Objects.requireNonNull(componentName, "ComponentName is null");
        int callingUserId = UserHandle.getCallingUserId();
        synchronized (getLockObject()) {
            try {
                if (callingUserId != 0) {
                    Slogf.w("DevicePolicyManager", "Only owner/system user is allowed to set storage encryption. User " + UserHandle.getCallingUserId() + " is not permitted.");
                    return 0;
                }
                this.mInjector.getClass();
                this.mInjector.getClass();
                ActiveAdmin activeAdminForCallerLockedMDM = Binder.getCallingPid() == Process.myPid() ? getActiveAdminForCallerLockedMDM(7, callingUserId, componentName) : getActiveAdminForCallerLocked(7, componentName);
                if (getEncryptionStatus() == 0) {
                    return 0;
                }
                if (activeAdminForCallerLockedMDM.encryptionRequested != z) {
                    activeAdminForCallerLockedMDM.encryptionRequested = z;
                    saveSettingsLocked(callingUserId, false, false, false);
                }
                DevicePolicyData userData = getUserData(0);
                int size = userData.mAdminList.size();
                boolean z2 = false;
                for (int i = 0; i < size; i++) {
                    z2 |= ((ActiveAdmin) userData.mAdminList.get(i)).encryptionRequested;
                }
                return z2 ? 3 : 1;
            } finally {
            }
        }
    }

    public final void setStrings(List list) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.UPDATE_DEVICE_MANAGEMENT_RESOURCES"));
        Objects.requireNonNull(list, "strings must be provided.");
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda25 devicePolicyManagerService$$ExternalSyntheticLambda25 = new DevicePolicyManagerService$$ExternalSyntheticLambda25(this, list, 3);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda25);
    }

    public final void setSystemSetting(ComponentName componentName, String str, String str2, boolean z) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        Preconditions.checkStringNotEmpty(str, "String setting is null or empty");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        if (Flags.allowScreenBrightnessControlOnCope() && z) {
            Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(callerIdentity));
        }
        checkCanExecuteOrThrowUnsafe(11);
        synchronized (getLockObject()) {
            try {
                if (!((ArraySet) SYSTEM_SETTINGS_ALLOWLIST).contains(str)) {
                    throw new SecurityException(String.format("Permission denial: device owners cannot update %1$s", str));
                }
                int profileParentId = (Flags.allowScreenBrightnessControlOnCope() && z) ? getProfileParentId(UserHandle.getUserId(callerIdentity.mUid)) : UserHandle.getUserId(callerIdentity.mUid);
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda173 devicePolicyManagerService$$ExternalSyntheticLambda173 = new DevicePolicyManagerService$$ExternalSyntheticLambda173(this, str, str2, profileParentId);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda173);
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void setSystemUpdatePolicy(ComponentName componentName, String str, SystemUpdatePolicy systemUpdatePolicy) {
        CallerIdentity callerIdentity;
        boolean z;
        if (systemUpdatePolicy != null) {
            systemUpdatePolicy.validateType();
            systemUpdatePolicy.validateFreezePeriods();
            Pair systemUpdateFreezePeriodRecord = this.mOwners.getSystemUpdateFreezePeriodRecord();
            systemUpdatePolicy.validateAgainstPreviousFreezePeriod((LocalDate) systemUpdateFreezePeriodRecord.first, (LocalDate) systemUpdateFreezePeriodRecord.second, LocalDate.now());
        }
        synchronized (getLockObject()) {
            try {
                if (isPermissionCheckFlagEnabled()) {
                    callerIdentity = getCallerIdentity(componentName, str);
                    enforcePermission("android.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES", callerIdentity.mPackageName, -1);
                } else {
                    callerIdentity = getCallerIdentity(componentName);
                    if (!isProfileOwnerOfOrganizationOwnedDevice(callerIdentity) && !isDefaultDeviceOwner(callerIdentity)) {
                        z = false;
                        Preconditions.checkCallAuthorization(z);
                    }
                    z = true;
                    Preconditions.checkCallAuthorization(z);
                }
                checkCanExecuteOrThrowUnsafe(14);
                if (systemUpdatePolicy == null) {
                    Owners owners = this.mOwners;
                    synchronized (owners.mData) {
                        owners.mData.mSystemUpdatePolicy = null;
                    }
                    this.mOwners.writeDeviceOwner();
                } else {
                    Owners owners2 = this.mOwners;
                    synchronized (owners2.mData) {
                        owners2.mData.mSystemUpdatePolicy = systemUpdatePolicy;
                    }
                    updateSystemUpdateFreezePeriodsRecord(false);
                    this.mOwners.writeDeviceOwner();
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda57 devicePolicyManagerService$$ExternalSyntheticLambda57 = new DevicePolicyManagerService$$ExternalSyntheticLambda57(3, this);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda57);
        DevicePolicyEventLogger.createEvent(50).setAdmin(callerIdentity.mPackageName).setInt(systemUpdatePolicy != null ? systemUpdatePolicy.getPolicyType() : 0).write();
    }

    public final boolean setTime(ComponentName componentName, String str, final long j) {
        CallerIdentity callerIdentity;
        if (isPermissionCheckFlagEnabled()) {
            callerIdentity = getCallerIdentity(componentName, str);
            enforcePermission("android.permission.SET_TIME", callerIdentity.mPackageName, -1);
        } else {
            CallerIdentity callerIdentity2 = getCallerIdentity(componentName);
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity2) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity2));
            callerIdentity = callerIdentity2;
        }
        if (this.mInjector.settingsGlobalGetInt("auto_time") == 1) {
            return false;
        }
        DevicePolicyEventLogger.createEvent(133).setAdmin(callerIdentity.mPackageName).write();
        Injector injector = this.mInjector;
        FunctionalUtils.ThrowingRunnable throwingRunnable = new FunctionalUtils.ThrowingRunnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda105
            public final void runOrThrow() {
                DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                ((AlarmManager) devicePolicyManagerService.mInjector.mContext.getSystemService(AlarmManager.class)).setTime(j);
            }
        };
        injector.getClass();
        Binder.withCleanCallingIdentity(throwingRunnable);
        return true;
    }

    public final void setTimeAndTimezone(long j, String str) {
        try {
            AlarmManager alarmManager = (AlarmManager) this.mContext.getSystemService(AlarmManager.class);
            if (str != null) {
                alarmManager.setTimeZone(str);
            }
            if (j > 0) {
                alarmManager.setTime(j);
            }
        } catch (Exception e) {
            Slogf.e("DevicePolicyManager", "Alarm manager failed to set the system time/timezone.", e);
        }
    }

    public final boolean setTimeZone(ComponentName componentName, String str, String str2) {
        CallerIdentity callerIdentity;
        if (isPermissionCheckFlagEnabled()) {
            callerIdentity = getCallerIdentity(componentName, str);
            enforcePermission("android.permission.SET_TIME_ZONE", callerIdentity.mPackageName, -1);
        } else {
            CallerIdentity callerIdentity2 = getCallerIdentity(componentName);
            Objects.requireNonNull(componentName, "ComponentName is null");
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity2) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity2));
            callerIdentity = callerIdentity2;
        }
        if (this.mInjector.settingsGlobalGetInt("auto_time_zone") == 1) {
            return false;
        }
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda46 devicePolicyManagerService$$ExternalSyntheticLambda46 = new DevicePolicyManagerService$$ExternalSyntheticLambda46(2, this, str2);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda46);
        DevicePolicyEventLogger.createEvent(134).setAdmin(callerIdentity.mPackageName).write();
        return true;
    }

    public final void setTrustAgentConfiguration(ComponentName componentName, String str, ComponentName componentName2, PersistableBundle persistableBundle, boolean z) {
        ActiveAdmin activeAdminOrCheckPermissionForCallerLocked;
        if (this.mHasFeature && this.mLockPatternUtils.hasSecureLockScreen()) {
            if (!isPermissionCheckFlagEnabled()) {
                Objects.requireNonNull(componentName, "admin is null");
            }
            Objects.requireNonNull(componentName2, "agent is null");
            PolicySizeVerifier.enforceMaxPackageNameLength(componentName2.getPackageName());
            String flattenToString = componentName2.flattenToString();
            PolicySizeVerifier.enforceMaxStringLength(flattenToString, "agent name");
            if (persistableBundle != null) {
                PolicySizeVerifier.enforceMaxStringLength(persistableBundle, "args");
            }
            this.mInjector.getClass();
            int userHandleGetCallingUserId = Injector.userHandleGetCallingUserId();
            synchronized (getLockObject()) {
                try {
                    if (isPermissionCheckFlagEnabled()) {
                        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
                        int profileParentId = z ? getProfileParentId(userHandleGetCallingUserId) : userHandleGetCallingUserId;
                        String str2 = callerIdentity.mPackageName;
                        if (!hasAdminPolicy(9, str2)) {
                            enforcePermission("android.permission.MANAGE_DEVICE_POLICY_KEYGUARD", str2, profileParentId);
                        }
                        activeAdminOrCheckPermissionForCallerLocked = getEnforcingAdminForCaller(componentName, str2).mActiveAdmin;
                    } else {
                        activeAdminOrCheckPermissionForCallerLocked = getActiveAdminOrCheckPermissionForCallerLocked(componentName, null, 9, z);
                    }
                    checkCanExecuteOrThrowUnsafe(21);
                    activeAdminOrCheckPermissionForCallerLocked.trustAgentInfos.put(flattenToString, new ActiveAdmin.TrustAgentInfo(persistableBundle));
                    saveSettingsLocked(userHandleGetCallingUserId, false, false, false);
                } catch (Throwable th) {
                    throw th;
                }
            }
        }
    }

    public final void setTrustAgentConfigurationMDM(int i, ComponentName componentName, ComponentName componentName2, PersistableBundle persistableBundle) {
        this.mInjector.getClass();
        if (Binder.getCallingPid() != Process.myPid()) {
            throw new SecurityException("Not allowed to call setTrustAgentConfigurationMDM!");
        }
        if (this.mHasFeature) {
            Objects.requireNonNull(componentName, "admin is null");
            Objects.requireNonNull(componentName2, "agent is null");
            synchronized (getLockObject()) {
                getActiveAdminForCallerLockedMDM(9, i, componentName).trustAgentInfos.put(componentName2.flattenToString(), new ActiveAdmin.TrustAgentInfo(persistableBundle));
                saveSettingsLocked(i, false, false, false);
            }
        }
    }

    public final void setUninstallBlocked(ComponentName componentName, String str, String str2, boolean z) {
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        String str3 = callerIdentity.mPackageName;
        int i = callerIdentity.mUid;
        enforcePermissions(str3, UserHandle.getUserId(i), new String[]{"android.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL", "android.permission.MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL"});
        EnforcingAdmin enforcingAdminForCaller = getEnforcingAdminForCaller(componentName, str3);
        DevicePolicyEngine devicePolicyEngine = this.mDevicePolicyEngine;
        PolicyDefinition policyDefinition = PolicyDefinition.GENERIC_PACKAGE_UNINSTALL_BLOCKED;
        if (str2 != null) {
            policyDefinition = policyDefinition.createPolicyDefinition(new PackagePolicyKey("packageUninstallBlocked", str2));
        }
        devicePolicyEngine.setLocalPolicy(policyDefinition, enforcingAdminForCaller, new BooleanPolicyValue(z), UserHandle.getUserId(i), false);
        DevicePolicyEventLogger.createEvent(67).setAdmin(callerIdentity.mPackageName).setBoolean(isCallerDelegate(callerIdentity)).setStrings(new String[]{str2}).write();
    }

    public final void setUsbDataSignalingEnabled(String str, boolean z) {
        Objects.requireNonNull(str, "Admin package name must be provided");
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        boolean z2 = true;
        if (!Flags.policyEngineMigrationV2Enabled()) {
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity), "USB data signaling can only be controlled by a device owner or a profile owner on an organization-owned device.");
            Preconditions.checkState(canUsbDataSignalingBeDisabledInternal(this.mContext), "USB data signaling cannot be disabled.");
        }
        synchronized (getLockObject()) {
            try {
                if (Flags.policyEngineMigrationV2Enabled()) {
                    EnforcingAdmin enforcePermissionAndGetEnforcingAdmin = enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), null, "android.permission.MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING", callerIdentity.mPackageName);
                    Preconditions.checkState(canUsbDataSignalingBeDisabledInternal(this.mContext), "USB data signaling cannot be disabled.");
                    this.mDevicePolicyEngine.setGlobalPolicy(PolicyDefinition.USB_DATA_SIGNALING, enforcePermissionAndGetEnforcingAdmin, new BooleanPolicyValue(z));
                } else {
                    ActiveAdmin profileOwnerOrDeviceOwnerLocked = getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                    if (profileOwnerOrDeviceOwnerLocked.mUsbDataSignalingEnabled != z) {
                        profileOwnerOrDeviceOwnerLocked.mUsbDataSignalingEnabled = z;
                        saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                        Context context = this.mContext;
                        ActiveAdmin deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked = getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();
                        if (deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked != null && !deviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked.mUsbDataSignalingEnabled) {
                            z2 = false;
                        }
                        updateUsbDataSignal(context, z2);
                    }
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        DevicePolicyEventLogger.createEvent(198).setAdmin(str).setBoolean(z).write();
    }

    public final void setUserControlDisabledPackages(ComponentName componentName, String str, List list) {
        Objects.requireNonNull(list, "packages is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
        checkCanExecuteOrThrowUnsafe(22);
        Binder.withCleanCallingIdentity(new DevicePolicyManagerService$$ExternalSyntheticLambda1(this, list, callerIdentity, enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), componentName, "android.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL", callerIdentity.mPackageName)));
        DevicePolicyEventLogger.createEvent(129).setAdmin(callerIdentity.mPackageName).setStrings((String[]) list.toArray(new String[list.size()])).write();
    }

    public final void setUserIcon(ComponentName componentName, Bitmap bitmap) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        CallerIdentity callerIdentity = getCallerIdentity(componentName);
        Preconditions.checkCallAuthorization(isProfileOwner(callerIdentity) || isDefaultDeviceOwner(callerIdentity));
        synchronized (getLockObject()) {
            Injector injector = this.mInjector;
            DevicePolicyManagerService$$ExternalSyntheticLambda51 devicePolicyManagerService$$ExternalSyntheticLambda51 = new DevicePolicyManagerService$$ExternalSyntheticLambda51(this, callerIdentity, bitmap, 2);
            injector.getClass();
            Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda51);
        }
        DevicePolicyEventLogger.createEvent(41).setAdmin(componentName).write();
    }

    public final void setUserProvisioningState(int i, int i2) {
        boolean z;
        boolean hasProfileOwner;
        int managedUserId;
        if (!this.mHasFeature) {
            logMissingFeatureAction("Cannot set provisioning state " + i + " for user " + i2);
            return;
        }
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            int deviceOwnerUserId = this.mOwners.getDeviceOwnerUserId();
            if (i2 != deviceOwnerUserId && !(hasProfileOwner = this.mOwners.hasProfileOwner(i2)) && (managedUserId = getManagedUserId(i2)) < 0 && i != 0) {
                Slogf.w("DevicePolicyManager", "setUserProvisioningState(newState=%d, userId=%d) failed: deviceOwnerId=%d, hasProfileOwner=%b, managedUserId=%d, err=%s", Integer.valueOf(i), Integer.valueOf(i2), Integer.valueOf(deviceOwnerUserId), Boolean.valueOf(hasProfileOwner), Integer.valueOf(managedUserId), "Not allowed to change provisioning state unless a device or profile owner is set.");
                throw new IllegalStateException("Not allowed to change provisioning state unless a device or profile owner is set.");
            }
            synchronized (getLockObject()) {
                try {
                    if (!isAdb(callerIdentity)) {
                        z = true;
                    } else {
                        if (getUserProvisioningState(i2) != 0 || i != 3) {
                            throw new IllegalStateException("Not allowed to change provisioning state unless current provisioning state is unmanaged, and new stateis finalized.");
                        }
                        z = false;
                    }
                    DevicePolicyData userData = getUserData(i2);
                    if (z) {
                        int i3 = userData.mUserProvisioningState;
                        if (i3 == 0) {
                            if (i != 0) {
                            }
                            throw new IllegalStateException("Cannot move to user provisioning state [" + i + "] from state [" + i3 + "]");
                        }
                        if (i3 == 1 || i3 == 2) {
                            if (i == 3) {
                            }
                            throw new IllegalStateException("Cannot move to user provisioning state [" + i + "] from state [" + i3 + "]");
                        }
                        if (i3 == 4) {
                            if (i == 5) {
                            }
                            throw new IllegalStateException("Cannot move to user provisioning state [" + i + "] from state [" + i3 + "]");
                        }
                        if (i3 == 5 && i == 0) {
                        }
                        throw new IllegalStateException("Cannot move to user provisioning state [" + i + "] from state [" + i3 + "]");
                    }
                    userData.mUserProvisioningState = i;
                    saveSettingsLocked(i2, false, false, false);
                } finally {
                }
            }
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        } catch (Throwable th) {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            throw th;
        }
    }

    /* JADX WARN: Code restructure failed: missing block: B:72:0x0154, code lost:
    
        if (r3 == false) goto L84;
     */
    /* JADX WARN: Code restructure failed: missing block: B:75:0x0168, code lost:
    
        throw new java.lang.SecurityException("Profile owner cannot set user restriction " + r12);
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void setUserRestriction(android.content.ComponentName r10, java.lang.String r11, java.lang.String r12, boolean r13, boolean r14) {
        /*
            Method dump skipped, instructions count: 376
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.setUserRestriction(android.content.ComponentName, java.lang.String, java.lang.String, boolean, boolean):void");
    }

    /* JADX WARN: Removed duplicated region for block: B:20:0x006d A[ADDED_TO_REGION] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void setUserRestrictionForKnox(android.content.ComponentName r10, java.lang.String r11, boolean r12, int r13) {
        /*
            r9 = this;
            java.lang.String r0 = "Caller is not Device admin. cannot set user restriction "
            java.lang.String r1 = "setUserRestrictionForKnox() isCalledFromMDMAdmin = "
            java.lang.String r2 = "ComponentName is null"
            java.util.Objects.requireNonNull(r10, r2)
            boolean r2 = com.android.server.pm.UserRestrictionsUtils.isValidRestriction(r11)
            if (r2 != 0) goto L11
            return
        L11:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r2 = r9.mInjector
            r2.getClass()
            int r2 = com.android.server.devicepolicy.DevicePolicyManagerService.Injector.userHandleGetCallingUserId()
            java.lang.Object r3 = r9.getLockObject()
            monitor-enter(r3)
            r4 = 1
            r5 = 0
            r6 = 0
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r7 = r9.mInjector     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L52
            r7.getClass()     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L52
            com.android.server.devicepolicy.KnoxPolicyHelper r7 = r9.mKnoxPolicyHelper     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L52
            boolean r6 = r7.isCalledFromMDMAdmin(r2)     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L52
            com.android.server.devicepolicy.DevicePolicyData r2 = r9.getUserData(r13)     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L4d
            android.util.ArrayMap r2 = r2.mAdminMap     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L4d
            java.lang.Object r2 = r2.get(r10)     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L4d
            com.android.server.devicepolicy.ActiveAdmin r2 = (com.android.server.devicepolicy.ActiveAdmin) r2     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L4d
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r5 = r9.mInjector     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L4b
            r5.getClass()     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L4b
            int r5 = android.os.Binder.getCallingUid()     // Catch: java.lang.Throwable -> L48 java.lang.Exception -> L4b
            r7 = 1000(0x3e8, float:1.401E-42)
            if (r5 != r7) goto L5a
            r6 = r4
            goto L5a
        L48:
            r9 = move-exception
            goto Lb1
        L4b:
            r5 = move-exception
            goto L57
        L4d:
            r2 = move-exception
            r8 = r5
            r5 = r2
        L50:
            r2 = r8
            goto L57
        L52:
            r13 = move-exception
            r8 = r5
            r5 = r13
            r13 = r2
            goto L50
        L57:
            r5.printStackTrace()     // Catch: java.lang.Throwable -> L48
        L5a:
            java.lang.String r5 = "DevicePolicyManager"
            java.lang.StringBuilder r7 = new java.lang.StringBuilder     // Catch: java.lang.Throwable -> L48
            r7.<init>(r1)     // Catch: java.lang.Throwable -> L48
            r7.append(r6)     // Catch: java.lang.Throwable -> L48
            java.lang.String r1 = r7.toString()     // Catch: java.lang.Throwable -> L48
            android.util.Log.d(r5, r1)     // Catch: java.lang.Throwable -> L48
            if (r6 == 0) goto L9f
            if (r2 == 0) goto L9f
            android.os.Bundle r0 = r2.ensureUserRestrictions()     // Catch: java.lang.Throwable -> L48
            if (r12 == 0) goto L79
            r0.putBoolean(r11, r4)     // Catch: java.lang.Throwable -> L48
            goto L7c
        L79:
            r0.remove(r11)     // Catch: java.lang.Throwable -> L48
        L7c:
            r9.saveUserRestrictionsLocked(r13)     // Catch: java.lang.Throwable -> L48
            monitor-exit(r3)     // Catch: java.lang.Throwable -> L48
            boolean r9 = android.app.admin.SecurityLog.isLoggingEnabled()
            if (r9 == 0) goto L9e
            if (r12 == 0) goto L8c
            r9 = 210027(0x3346b, float:2.9431E-40)
            goto L8f
        L8c:
            r9 = 210028(0x3346c, float:2.94312E-40)
        L8f:
            java.lang.String r10 = r10.getPackageName()
            java.lang.Integer r12 = java.lang.Integer.valueOf(r13)
            java.lang.Object[] r10 = new java.lang.Object[]{r10, r12, r11}
            android.app.admin.SecurityLog.writeEvent(r9, r10)
        L9e:
            return
        L9f:
            java.lang.SecurityException r9 = new java.lang.SecurityException     // Catch: java.lang.Throwable -> L48
            java.lang.StringBuilder r10 = new java.lang.StringBuilder     // Catch: java.lang.Throwable -> L48
            r10.<init>(r0)     // Catch: java.lang.Throwable -> L48
            r10.append(r11)     // Catch: java.lang.Throwable -> L48
            java.lang.String r10 = r10.toString()     // Catch: java.lang.Throwable -> L48
            r9.<init>(r10)     // Catch: java.lang.Throwable -> L48
            throw r9     // Catch: java.lang.Throwable -> L48
        Lb1:
            monitor-exit(r3)     // Catch: java.lang.Throwable -> L48
            throw r9
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.setUserRestrictionForKnox(android.content.ComponentName, java.lang.String, boolean, int):void");
    }

    public final void setUserRestrictionGlobally(String str, String str2) {
        CallerIdentity callerIdentity = getCallerIdentity(null, str);
        EnforcingAdmin enforcePermissionForUserRestriction = enforcePermissionForUserRestriction(-1, null, str2, callerIdentity.mPackageName);
        checkCanExecuteOrThrowUnsafe(10);
        if (isDeviceOwner(callerIdentity) || isProfileOwner(callerIdentity)) {
            throw new SecurityException("Admins are not allowed to call this API.");
        }
        Injector injector = this.mInjector;
        int userId = UserHandle.getUserId(callerIdentity.mUid);
        injector.getClass();
        if (!Injector.isChangeEnabled(userId, str, 260560985L)) {
            throw new IllegalStateException("Calling package is not targeting Android U.");
        }
        if (!UserRestrictionsUtils.isValidRestriction(str2)) {
            throw new IllegalArgumentException(ConnectivityModuleConnector$$ExternalSyntheticOutline0.m("Invalid restriction key: ", str2));
        }
        setGlobalUserRestrictionInternal(enforcePermissionForUserRestriction, str2, true);
        logUserRestrictionCall(str2, true, false, callerIdentity);
    }

    public final void setWifiSsidPolicy(String str, WifiSsidPolicy wifiSsidPolicy) {
        CallerIdentity callerIdentity;
        boolean z = true;
        if (isPermissionCheckFlagEnabled()) {
            callerIdentity = getCallerIdentity(null, str);
        } else {
            callerIdentity = getCallerIdentity(null, null);
            Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isProfileOwnerOfOrganizationOwnedDevice(callerIdentity), "SSID denylist can only be controlled by a device owner or a profile owner on an organization-owned device.");
        }
        synchronized (getLockObject()) {
            try {
                ActiveAdmin profileOwnerOrDeviceOwnerLocked = isPermissionCheckFlagEnabled() ? enforcePermissionAndGetEnforcingAdmin(UserHandle.getUserId(callerIdentity.mUid), null, "android.permission.MANAGE_DEVICE_POLICY_WIFI", callerIdentity.mPackageName).mActiveAdmin : getProfileOwnerOrDeviceOwnerLocked(UserHandle.getUserId(callerIdentity.mUid));
                if (Objects.equals(wifiSsidPolicy, profileOwnerOrDeviceOwnerLocked.mWifiSsidPolicy)) {
                    z = false;
                } else {
                    profileOwnerOrDeviceOwnerLocked.mWifiSsidPolicy = wifiSsidPolicy;
                }
                if (z) {
                    saveSettingsLocked(profileOwnerOrDeviceOwnerLocked.getUserHandle().getIdentifier(), false, false, false);
                }
                this.mInjector.getClass();
                if (z) {
                    wifiSsidPolicy = getCombinedWifiSsidPolicyLocked();
                }
            } catch (Throwable th) {
                throw th;
            }
        }
        if (z) {
            notifyWifiSsidPolicyChanged(wifiSsidPolicy);
        }
    }

    public final boolean shouldAllowBypassingDevicePolicyManagementRoleQualification() {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_ROLE_HOLDERS"));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 9);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33)).booleanValue();
    }

    public final void showLocationSettingsEnabledNotification(UserHandle userHandle) {
        Intent addFlags = new Intent("android.settings.LOCATION_SOURCE_SETTINGS").addFlags(268435456);
        ActivityInfo resolveActivityInfo = addFlags.resolveActivityInfo(this.mInjector.getPackageManager(userHandle.getIdentifier()), 1048576);
        if (resolveActivityInfo != null) {
            addFlags.setComponent(resolveActivityInfo.getComponentName());
        } else {
            Slogf.wtf("DevicePolicyManager", "Failed to resolve intent for location settings");
        }
        Injector injector = this.mInjector;
        Context context = this.mContext;
        injector.getClass();
        this.mHandler.post(new DevicePolicyManagerService$$ExternalSyntheticLambda27(this, new Notification.Builder(this.mContext, SystemNotificationChannels.DEVICE_ADMIN).setSmallIcon(R.drawable.ic_lockscreen_chevron_right).setContentTitle(getUpdatableString("Core.LOCATION_CHANGED_TITLE", R.string.permdesc_receiveWapPush, new Object[0])).setContentText(getUpdatableString("Core.LOCATION_CHANGED_MESSAGE", R.string.permdesc_receiveSms, new Object[0])).setColor(this.mContext.getColor(R.color.system_notification_accent_color)).setShowWhen(true).setContentIntent(PendingIntent.getActivityAsUser(context, 0, addFlags, 201326592, null, userHandle)).setAutoCancel(true).build(), 1));
    }

    public final void startManagedQuickContact(String str, long j, boolean z, long j2, Intent intent) {
        boolean z2 = j >= 700000000;
        Intent rebuildManagedQuickContactsIntent = ContactsContract.QuickContact.rebuildManagedQuickContactsIntent(str, z2 ? j - 700000000 : j, z, j2, intent);
        int callingUserId = UserHandle.getCallingUserId();
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda113 devicePolicyManagerService$$ExternalSyntheticLambda113 = new DevicePolicyManagerService$$ExternalSyntheticLambda113(this, z2, callingUserId, rebuildManagedQuickContactsIntent);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda113);
    }

    public final void startOwnerService(int i) {
        ComponentName ownerComponent = getOwnerComponent(i);
        if (ownerComponent != null) {
            this.mDeviceAdminServiceController.startServiceForAdmin(i, ownerComponent.getPackageName());
            DevicePolicyManager.invalidateBinderCaches();
        }
    }

    public final void startProfileForSetup(int i, String str) {
        boolean z;
        Slogf.i("DevicePolicyManager", "Starting profile %d as requested by package %s", Integer.valueOf(i), str);
        long elapsedRealtime = SystemClock.elapsedRealtime();
        UserUnlockedBlockingReceiver userUnlockedBlockingReceiver = new UserUnlockedBlockingReceiver(i);
        this.mContext.registerReceiverAsUser(userUnlockedBlockingReceiver, new UserHandle(i), new IntentFilter("android.intent.action.USER_UNLOCKED"), null, null);
        try {
            this.mInjector.getClass();
            if (!Injector.getActivityManagerInternal().startProfileEvenWhenDisabled(i)) {
                throw new ServiceSpecificException(5, String.format("Unable to start user %d in background", Integer.valueOf(i)));
            }
            try {
                z = userUnlockedBlockingReceiver.mSemaphore.tryAcquire(120L, TimeUnit.SECONDS);
            } catch (InterruptedException unused) {
                z = false;
            }
            if (!z) {
                throw new ServiceSpecificException(5, String.format("Timeout whilst waiting for unlock of user %d.", Integer.valueOf(i)));
            }
            logEventDuration(192, str, elapsedRealtime);
        } finally {
            this.mContext.unregisterReceiver(userUnlockedBlockingReceiver);
        }
    }

    public final void startUninstallIntent(int i, String str) {
        UserPackage of = UserPackage.of(i, str);
        synchronized (getLockObject()) {
            try {
                if (((ArraySet) this.mPackagesToRemove).contains(of)) {
                    ((ArraySet) this.mPackagesToRemove).remove(of);
                    if (isPackageInstalledForUser(i, str)) {
                        try {
                            this.mInjector.getClass();
                            ActivityManager.getService().forceStopPackage(str, i);
                        } catch (RemoteException unused) {
                            Slogf.e("DevicePolicyManager", "Failure talking to ActivityManager while force stopping package");
                        }
                        Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE", Uri.parse("package:" + str));
                        intent.setFlags(268435456);
                        this.mContext.startActivityAsUser(intent, UserHandle.of(i));
                    }
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final int startUserInBackground(ComponentName componentName, UserHandle userHandle) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        Objects.requireNonNull(userHandle, "UserHandle is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        checkCanExecuteOrThrowUnsafe(3);
        int identifier = userHandle.getIdentifier();
        if (isManagedProfile(identifier)) {
            Slogf.w("DevicePolicyManager", "Managed profile cannot be started in background");
            return 2;
        }
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            this.mInjector.getClass();
            if (!Injector.getActivityManagerInternal().canStartMoreUsers()) {
                Slogf.w("DevicePolicyManager", "Cannot start user %d, too many users in background", Integer.valueOf(identifier));
                return 3;
            }
            Slogf.i("DevicePolicyManager", "Starting user %d in background", Integer.valueOf(identifier));
            this.mInjector.getClass();
            if (!ActivityManager.getService().startUserInBackground(identifier)) {
                Slogf.w("DevicePolicyManager", "failed to start user %d in background", Integer.valueOf(identifier));
                return 1;
            }
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            return 0;
        } catch (RemoteException unused) {
            return 1;
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final boolean startViewCalendarEventInManagedProfile(final String str, final long j, final long j2, final long j3, final boolean z, final int i) {
        if (!this.mHasFeature) {
            return false;
        }
        Preconditions.checkStringNotEmpty(str, "Package name is empty");
        final CallerIdentity callerIdentity = getCallerIdentity(null, null);
        if (!isCallingFromPackage(callerIdentity.mUid, str)) {
            throw new SecurityException("Input package name doesn't align with actual calling package.");
        }
        Injector injector = this.mInjector;
        FunctionalUtils.ThrowingSupplier throwingSupplier = new FunctionalUtils.ThrowingSupplier() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda48
            public final Object getOrThrow() {
                DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                CallerIdentity callerIdentity2 = callerIdentity;
                String str2 = str;
                long j4 = j;
                long j5 = j2;
                long j6 = j3;
                boolean z2 = z;
                int i2 = i;
                devicePolicyManagerService.getClass();
                int managedUserId = devicePolicyManagerService.getManagedUserId(UserHandle.getUserId(callerIdentity2.mUid));
                if (managedUserId < 0) {
                    return Boolean.FALSE;
                }
                if (!devicePolicyManagerService.isPackageAllowedToAccessCalendarForUser(str2, managedUserId)) {
                    Slogf.d("DevicePolicyManager", "Package %s is not allowed to access cross-profile calendar APIs", str2);
                    return Boolean.FALSE;
                }
                Intent intent = new Intent("android.provider.calendar.action.VIEW_MANAGED_PROFILE_CALENDAR_EVENT");
                intent.setPackage(str2);
                intent.putExtra("id", j4);
                intent.putExtra("beginTime", j5);
                intent.putExtra("endTime", j6);
                intent.putExtra("allDay", z2);
                intent.setFlags(i2);
                try {
                    devicePolicyManagerService.mContext.startActivityAsUser(intent, UserHandle.of(managedUserId));
                    return Boolean.TRUE;
                } catch (ActivityNotFoundException e) {
                    Slogf.e("DevicePolicyManager", "View event activity not found", e);
                    return Boolean.FALSE;
                }
            }
        };
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(throwingSupplier)).booleanValue();
    }

    public final int stopUser(ComponentName componentName, UserHandle userHandle) {
        Objects.requireNonNull(componentName, "ComponentName is null");
        Objects.requireNonNull(userHandle, "UserHandle is null");
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(getCallerIdentity(componentName)));
        checkCanExecuteOrThrowUnsafe(4);
        int identifier = userHandle.getIdentifier();
        if (!isManagedProfile(identifier)) {
            return stopUserUnchecked(identifier);
        }
        Slogf.w("DevicePolicyManager", "Managed profile cannot be stopped");
        return 2;
    }

    public final int stopUserUnchecked(int i) {
        Slogf.i("DevicePolicyManager", "Stopping user %d", Integer.valueOf(i));
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            this.mInjector.getClass();
            int stopUserWithCallback = ActivityManager.getService().stopUserWithCallback(i, (IStopUserCallback) null);
            if (stopUserWithCallback == -2) {
                this.mInjector.getClass();
                Binder.restoreCallingIdentity(clearCallingIdentity);
                return 4;
            }
            if (stopUserWithCallback != 0) {
                return 1;
            }
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
            return 0;
        } catch (RemoteException unused) {
            return 1;
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final void suspendPersonalAppsInternal(int i, int i2, boolean z) {
        if (getUserData(i).mAppsSuspended == z) {
            return;
        }
        Slogf.i("DevicePolicyManager", "%s personal apps for user %d", z ? "Suspending" : "Unsuspending", Integer.valueOf(i));
        ActiveAdmin profileOwnerAdminLocked = getProfileOwnerAdminLocked(i2);
        if (profileOwnerAdminLocked != null) {
            this.mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.PERSONAL_APPS_SUSPENDED, EnforcingAdmin.createEnterpriseEnforcingAdmin(profileOwnerAdminLocked.info.getComponent(), i2, profileOwnerAdminLocked), new BooleanPolicyValue(z), i, false);
        }
        synchronized (getLockObject()) {
            getUserData(i).mAppsSuspended = z;
            saveSettingsLocked(i, false, false, false);
        }
    }

    /* JADX WARN: Removed duplicated region for block: B:26:0x009a A[Catch: all -> 0x0085, TryCatch #1 {all -> 0x0085, blocks: (B:4:0x001d, B:13:0x0077, B:15:0x0081, B:16:0x0087, B:35:0x009f, B:37:0x00a9, B:38:0x00ac, B:24:0x0090, B:26:0x009a, B:27:0x009d), top: B:3:0x001d }] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final boolean switchUser(android.content.ComponentName r9, android.os.UserHandle r10) {
        /*
            r8 = this;
            java.lang.String r0 = "ComponentName is null"
            java.util.Objects.requireNonNull(r9, r0)
            com.android.server.devicepolicy.CallerIdentity r9 = r8.getCallerIdentity(r9)
            boolean r9 = r8.isDefaultDeviceOwner(r9)
            com.android.internal.util.Preconditions.checkCallAuthorization(r9)
            r9 = 2
            r8.checkCanExecuteOrThrowUnsafe(r9)
            int r9 = r8.getLogoutUserIdUnchecked()
            java.lang.Object r0 = r8.getLockObject()
            monitor-enter(r0)
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r1 = r8.mInjector     // Catch: java.lang.Throwable -> L85
            r1.getClass()     // Catch: java.lang.Throwable -> L85
            long r1 = android.os.Binder.clearCallingIdentity()     // Catch: java.lang.Throwable -> L85
            r3 = 0
            if (r10 == 0) goto L34
            int r10 = r10.getIdentifier()     // Catch: java.lang.Throwable -> L2e android.os.RemoteException -> L31
            goto L35
        L2e:
            r10 = move-exception
            goto L9f
        L31:
            r10 = move-exception
            r4 = r3
            goto L89
        L34:
            r10 = r3
        L35:
            java.lang.String r4 = "DevicePolicyManager"
            java.lang.String r5 = "Switching to user %d (logout user is %d)"
            java.lang.Integer r6 = java.lang.Integer.valueOf(r10)     // Catch: java.lang.Throwable -> L2e android.os.RemoteException -> L31
            java.lang.Integer r7 = java.lang.Integer.valueOf(r9)     // Catch: java.lang.Throwable -> L2e android.os.RemoteException -> L31
            java.lang.Object[] r6 = new java.lang.Object[]{r6, r7}     // Catch: java.lang.Throwable -> L2e android.os.RemoteException -> L31
            com.android.server.utils.Slogf.i(r4, r5, r6)     // Catch: java.lang.Throwable -> L2e android.os.RemoteException -> L31
            r4 = -2
            r8.setLogoutUserIdLocked(r4)     // Catch: java.lang.Throwable -> L2e android.os.RemoteException -> L31
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r4 = r8.mInjector     // Catch: java.lang.Throwable -> L2e android.os.RemoteException -> L31
            r4.getClass()     // Catch: java.lang.Throwable -> L2e android.os.RemoteException -> L31
            android.app.IActivityManager r4 = android.app.ActivityManager.getService()     // Catch: java.lang.Throwable -> L2e android.os.RemoteException -> L31
            boolean r4 = r4.switchUser(r10)     // Catch: java.lang.Throwable -> L2e android.os.RemoteException -> L31
            if (r4 != 0) goto L70
            java.lang.String r5 = "DevicePolicyManager"
            java.lang.String r6 = "Failed to switch to user %d"
            java.lang.Integer r10 = java.lang.Integer.valueOf(r10)     // Catch: java.lang.Throwable -> L6b android.os.RemoteException -> L6e
            java.lang.Object[] r10 = new java.lang.Object[]{r10}     // Catch: java.lang.Throwable -> L6b android.os.RemoteException -> L6e
            com.android.server.utils.Slogf.w(r5, r6, r10)     // Catch: java.lang.Throwable -> L6b android.os.RemoteException -> L6e
            goto L77
        L6b:
            r10 = move-exception
            r3 = r4
            goto L9f
        L6e:
            r10 = move-exception
            goto L89
        L70:
            java.lang.String r10 = "DevicePolicyManager"
            java.lang.String r5 = "Switched"
            com.android.server.utils.Slogf.d(r10, r5)     // Catch: java.lang.Throwable -> L6b android.os.RemoteException -> L6e
        L77:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r10 = r8.mInjector     // Catch: java.lang.Throwable -> L85
            r10.getClass()     // Catch: java.lang.Throwable -> L85
            android.os.Binder.restoreCallingIdentity(r1)     // Catch: java.lang.Throwable -> L85
            if (r4 != 0) goto L87
            r8.setLogoutUserIdLocked(r9)     // Catch: java.lang.Throwable -> L85
            goto L87
        L85:
            r8 = move-exception
            goto Lad
        L87:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L85
            return r4
        L89:
            java.lang.String r5 = "DevicePolicyManager"
            java.lang.String r6 = "Couldn't switch user"
            com.android.server.utils.Slogf.e(r5, r6, r10)     // Catch: java.lang.Throwable -> L6b
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r10 = r8.mInjector     // Catch: java.lang.Throwable -> L85
            r10.getClass()     // Catch: java.lang.Throwable -> L85
            android.os.Binder.restoreCallingIdentity(r1)     // Catch: java.lang.Throwable -> L85
            if (r4 != 0) goto L9d
            r8.setLogoutUserIdLocked(r9)     // Catch: java.lang.Throwable -> L85
        L9d:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L85
            return r3
        L9f:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r4 = r8.mInjector     // Catch: java.lang.Throwable -> L85
            r4.getClass()     // Catch: java.lang.Throwable -> L85
            android.os.Binder.restoreCallingIdentity(r1)     // Catch: java.lang.Throwable -> L85
            if (r3 != 0) goto Lac
            r8.setLogoutUserIdLocked(r9)     // Catch: java.lang.Throwable -> L85
        Lac:
            throw r10     // Catch: java.lang.Throwable -> L85
        Lad:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L85
            throw r8
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.switchUser(android.content.ComponentName, android.os.UserHandle):boolean");
    }

    public void systemReady(int i) {
        if (this.mHasFeature) {
            if (i == 480) {
                onLockSettingsReady();
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda58 devicePolicyManagerService$$ExternalSyntheticLambda58 = new DevicePolicyManagerService$$ExternalSyntheticLambda58(this, 0);
                injector.getClass();
                SystemServerInitThreadPool.submit("DevicePolicyManager", devicePolicyManagerService$$ExternalSyntheticLambda58);
                this.mOwners.systemReady();
                applyManagedSubscriptionsPolicyIfRequired();
                return;
            }
            if (i == 500) {
                synchronized (getLockObject()) {
                    this.mDevicePolicyEngine.reapplyAllPoliciesOnBootLocked();
                }
                return;
            }
            if (i == 550) {
                synchronized (getLockObject()) {
                    migrateToProfileOnOrganizationOwnedDeviceIfCompLocked();
                    applyProfileRestrictionsIfDeviceOwnerLocked();
                    Injector injector2 = this.mInjector;
                    DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda33 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 5);
                    injector2.getClass();
                    if (((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda33)).booleanValue()) {
                        Injector injector3 = this.mInjector;
                        DevicePolicyManagerService$$ExternalSyntheticLambda33 devicePolicyManagerService$$ExternalSyntheticLambda332 = new DevicePolicyManagerService$$ExternalSyntheticLambda33(this, 6);
                        injector3.getClass();
                        ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda332)).getClass();
                    }
                    maybeMigratePoliciesPostUpgradeToDevicePolicyEngineLocked();
                    migratePoliciesToPolicyEngineLocked();
                }
                maybeStartSecurityLogMonitorOnActivityManagerReady();
                return;
            }
            if (i != 1000) {
                return;
            }
            synchronized (getLockObject()) {
                try {
                    DevicePolicyData userData = getUserData(0);
                    if (userData.mFactoryResetFlags != 0) {
                        if (userData.mFactoryResetReason == null) {
                            Slogf.e("DevicePolicyManager", "no persisted reason for factory resetting");
                            userData.mFactoryResetReason = "requested before boot";
                        }
                        FactoryResetter.Builder builder = new FactoryResetter.Builder(this.mContext);
                        String str = userData.mFactoryResetReason;
                        Objects.requireNonNull(str);
                        builder.mReason = str;
                        builder.mForce = true;
                        int i2 = userData.mFactoryResetFlags;
                        builder.mWipeEuicc = (i2 & 4) != 0;
                        builder.mWipeAdoptableStorage = (i2 & 2) != 0;
                        builder.mWipeFactoryResetProtection = (i2 & 8) != 0;
                        FactoryResetter factoryResetter = new FactoryResetter(builder);
                        Slogf.i("DevicePolicyManager", "Factory resetting on boot using " + factoryResetter);
                        try {
                            if (!factoryResetter.factoryReset()) {
                                Slogf.wtf("DevicePolicyManager", "Factory reset using " + factoryResetter + " failed.");
                            }
                        } catch (IOException e) {
                            Slogf.wtf("DevicePolicyManager", "Could not factory reset using " + factoryResetter, e);
                        }
                    }
                } finally {
                }
            }
            synchronized (getLockObject()) {
                try {
                    if (this.mOwners.hasDeviceOwner()) {
                        int deviceOwnerUserId = this.mOwners.getDeviceOwnerUserId();
                        if (deviceOwnerUserId != 0) {
                            try {
                                this.mInjector.getClass();
                                ActivityManager.getService().startUserInBackground(deviceOwnerUserId);
                            } catch (RemoteException e2) {
                                Slogf.w("DevicePolicyManager", "Exception starting user", e2);
                            }
                        }
                    }
                } finally {
                }
            }
        }
    }

    public final void toggleBackupServiceActive(int i, boolean z) {
        this.mInjector.getClass();
        long clearCallingIdentity = Binder.clearCallingIdentity();
        try {
            try {
                this.mInjector.getClass();
                if (IBackupManager.Stub.asInterface(ServiceManager.getService("backup")) != null) {
                    this.mInjector.getClass();
                    IBackupManager.Stub.asInterface(ServiceManager.getService("backup")).setBackupServiceActive(i, z);
                }
            } catch (RemoteException e) {
                throw new IllegalStateException("Failed " + (z ? "activating" : "deactivating") + " backup service.", e);
            }
        } finally {
            this.mInjector.getClass();
            Binder.restoreCallingIdentity(clearCallingIdentity);
        }
    }

    public final void transferActiveAdminUncheckedLocked(ComponentName componentName, ComponentName componentName2, int i) {
        int i2;
        int i3;
        Object obj;
        DevicePolicyEngine devicePolicyEngine;
        EnforcingAdmin enforcingAdmin;
        DevicePolicyData userData = getUserData(i);
        if (userData.mAdminMap.containsKey(componentName2) || !userData.mAdminMap.containsKey(componentName)) {
            DeviceAdminInfo findAdmin = findAdmin(i, componentName, true);
            ActiveAdmin activeAdmin = (ActiveAdmin) userData.mAdminMap.get(componentName2);
            int uid = activeAdmin.getUid();
            EnforcingAdmin createEnterpriseEnforcingAdmin = EnforcingAdmin.createEnterpriseEnforcingAdmin(componentName2, i, activeAdmin);
            EnforcingAdmin createEnterpriseEnforcingAdmin2 = EnforcingAdmin.createEnterpriseEnforcingAdmin(componentName, i, activeAdmin);
            DevicePolicyEngine devicePolicyEngine2 = this.mDevicePolicyEngine;
            Object obj2 = devicePolicyEngine2.mLock;
            synchronized (obj2) {
                try {
                    try {
                        Iterator it = new HashSet(((HashMap) devicePolicyEngine2.mGlobalPolicies).keySet()).iterator();
                        while (it.hasNext()) {
                            PolicyState policyState = (PolicyState) ((HashMap) devicePolicyEngine2.mGlobalPolicies).get((PolicyKey) it.next());
                            if (policyState.getPoliciesSetByAdmins().containsKey(createEnterpriseEnforcingAdmin)) {
                                devicePolicyEngine2.setGlobalPolicy(policyState.mPolicyDefinition, createEnterpriseEnforcingAdmin2, (PolicyValue) policyState.getPoliciesSetByAdmins().get(createEnterpriseEnforcingAdmin));
                            }
                        }
                        int i4 = 0;
                        while (i4 < devicePolicyEngine2.mLocalPolicies.size()) {
                            int keyAt = devicePolicyEngine2.mLocalPolicies.keyAt(i4);
                            Iterator it2 = new HashSet(((Map) devicePolicyEngine2.mLocalPolicies.get(keyAt)).keySet()).iterator();
                            while (it2.hasNext()) {
                                Iterator it3 = it2;
                                PolicyState policyState2 = (PolicyState) ((Map) devicePolicyEngine2.mLocalPolicies.get(keyAt)).get((PolicyKey) it2.next());
                                if (policyState2.getPoliciesSetByAdmins().containsKey(createEnterpriseEnforcingAdmin)) {
                                    PolicyDefinition policyDefinition = policyState2.mPolicyDefinition;
                                    PolicyValue policyValue = (PolicyValue) policyState2.getPoliciesSetByAdmins().get(createEnterpriseEnforcingAdmin);
                                    i2 = keyAt;
                                    i3 = i4;
                                    obj = obj2;
                                    devicePolicyEngine = devicePolicyEngine2;
                                    enforcingAdmin = createEnterpriseEnforcingAdmin2;
                                    devicePolicyEngine2.setLocalPolicy(policyDefinition, createEnterpriseEnforcingAdmin2, policyValue, i2, false);
                                } else {
                                    i2 = keyAt;
                                    i3 = i4;
                                    obj = obj2;
                                    devicePolicyEngine = devicePolicyEngine2;
                                    enforcingAdmin = createEnterpriseEnforcingAdmin2;
                                }
                                devicePolicyEngine2 = devicePolicyEngine;
                                obj2 = obj;
                                it2 = it3;
                                keyAt = i2;
                                i4 = i3;
                                createEnterpriseEnforcingAdmin2 = enforcingAdmin;
                            }
                            i4++;
                        }
                        DevicePolicyEngine devicePolicyEngine3 = devicePolicyEngine2;
                        devicePolicyEngine3.removePoliciesForAdmin(createEnterpriseEnforcingAdmin);
                        ActiveAdmin activeAdmin2 = activeAdmin.parentAdmin;
                        if (activeAdmin2 != null) {
                            activeAdmin2.info = findAdmin;
                        }
                        activeAdmin.info = findAdmin;
                        userData.mAdminMap.remove(componentName2);
                        userData.mAdminMap.put(componentName, activeAdmin);
                        if (userData.mPasswordOwner == uid) {
                            userData.mPasswordOwner = activeAdmin.getUid();
                        }
                        if (Flags.esimManagementEnabled()) {
                            SubscriptionManager subscriptionManager = (SubscriptionManager) this.mContext.getSystemService(SubscriptionManager.class);
                            String packageName = componentName2.getPackageName();
                            SubscriptionManager subscriptionManager2 = (SubscriptionManager) this.mContext.getSystemService(SubscriptionManager.class);
                            Injector injector = this.mInjector;
                            DevicePolicyManagerService$$ExternalSyntheticLambda34 devicePolicyManagerService$$ExternalSyntheticLambda34 = new DevicePolicyManagerService$$ExternalSyntheticLambda34(2, subscriptionManager2, packageName);
                            injector.getClass();
                            for (int i5 : ((IntArray) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda34)).toArray()) {
                                try {
                                    subscriptionManager.setGroupOwner(i5, componentName.getPackageName());
                                } catch (Exception e) {
                                    Slogf.e("DevicePolicyManager", e, VibrationParam$1$$ExternalSyntheticOutline0.m(i5, "Error setting group owner for subId: "), new Object[0]);
                                }
                            }
                        }
                        saveSettingsLocked(i, false, false, false);
                        sendAdminCommandLocked(activeAdmin, "android.app.action.DEVICE_ADMIN_ENABLED", null, null, false);
                    } catch (Throwable th) {
                        th = th;
                        Object obj3 = obj2;
                        throw th;
                    }
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            }
        }
    }

    public final void transferDeviceOwnershipLocked(ComponentName componentName, ComponentName componentName2, int i) {
        transferActiveAdminUncheckedLocked(componentName2, componentName, i);
        Owners owners = this.mOwners;
        synchronized (owners.mData) {
            try {
                OwnersData ownersData = owners.mData;
                Integer num = (Integer) ownersData.mDeviceOwnerTypes.remove(ownersData.mDeviceOwner.packageName);
                OwnersData ownersData2 = owners.mData;
                OwnersData.OwnerInfo ownerInfo = ownersData2.mDeviceOwner;
                ownersData2.mDeviceOwner = new OwnersData.OwnerInfo(componentName2, ownerInfo.remoteBugreportUri, ownerInfo.remoteBugreportHash, ownerInfo.isOrganizationOwnedDevice);
                if (num != null) {
                    OwnersData ownersData3 = owners.mData;
                    ownersData3.mDeviceOwnerTypes.put(ownersData3.mDeviceOwner.packageName, num);
                }
                owners.notifyChangeLocked();
                owners.pushDeviceOwnerUidToActivityTaskManagerLocked();
            } catch (Throwable th) {
                throw th;
            }
        }
        Slogf.i("DevicePolicyManager", "Device owner set: " + componentName2 + " on user " + i);
        this.mOwners.writeDeviceOwner();
        this.mDeviceAdminServiceController.startServiceForAdmin(i, componentName2.getPackageName());
    }

    /* JADX WARN: Removed duplicated region for block: B:14:0x005a  */
    /* JADX WARN: Removed duplicated region for block: B:54:0x0170  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void transferOwnership(android.content.ComponentName r12, android.content.ComponentName r13, android.os.PersistableBundle r14) {
        /*
            Method dump skipped, instructions count: 376
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.transferOwnership(android.content.ComponentName, android.content.ComponentName, android.os.PersistableBundle):void");
    }

    public final void transferProfileOwnershipLocked(ComponentName componentName, ComponentName componentName2, int i) {
        transferActiveAdminUncheckedLocked(componentName2, componentName, i);
        Owners owners = this.mOwners;
        synchronized (owners.mData) {
            OwnersData.OwnerInfo ownerInfo = (OwnersData.OwnerInfo) owners.mData.mProfileOwners.get(Integer.valueOf(i));
            owners.mData.mProfileOwners.put(Integer.valueOf(i), new OwnersData.OwnerInfo(componentName2, ownerInfo.remoteBugreportUri, ownerInfo.remoteBugreportHash, ownerInfo.isOrganizationOwnedDevice));
            owners.notifyChangeLocked();
            owners.pushProfileOwnerUidsToActivityTaskManagerLocked();
        }
        Slogf.i("DevicePolicyManager", "Profile owner set: " + componentName2 + " on user " + i);
        this.mOwners.writeProfileOwner(i);
        this.mDeviceAdminServiceController.startServiceForAdmin(i, componentName2.getPackageName());
    }

    public final boolean triggerDevicePolicyEngineMigration(boolean z) {
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS"));
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda12 devicePolicyManagerService$$ExternalSyntheticLambda12 = new DevicePolicyManagerService$$ExternalSyntheticLambda12(this, 0, z);
        injector.getClass();
        return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda12)).booleanValue();
    }

    public final void tryRetrieveAndSendLocationUpdate(final ActiveAdmin activeAdmin, final AndroidFuture androidFuture, final String[] strArr, final int i) {
        if (i == strArr.length) {
            androidFuture.complete(Boolean.FALSE);
        } else if (((LocationManager) this.mInjector.mContext.getSystemService(LocationManager.class)).isProviderEnabled(strArr[i])) {
            ((LocationManager) this.mInjector.mContext.getSystemService(LocationManager.class)).getCurrentLocation(strArr[i], null, this.mContext.getMainExecutor(), new Consumer() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda203
                @Override // java.util.function.Consumer
                public final void accept(Object obj) {
                    DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                    ActiveAdmin activeAdmin2 = activeAdmin;
                    AndroidFuture androidFuture2 = androidFuture;
                    String[] strArr2 = strArr;
                    int i2 = i;
                    Location location = (Location) obj;
                    if (location == null) {
                        devicePolicyManagerService.tryRetrieveAndSendLocationUpdate(activeAdmin2, androidFuture2, strArr2, i2 + 1);
                        return;
                    }
                    Context context = devicePolicyManagerService.mContext;
                    Intent intent = new Intent("android.app.action.LOST_MODE_LOCATION_UPDATE");
                    intent.putExtra("android.app.extra.LOST_MODE_LOCATION", location);
                    intent.setPackage(activeAdmin2.info.getPackageName());
                    context.sendBroadcastAsUser(intent, activeAdmin2.getUserHandle());
                    androidFuture2.complete(Boolean.TRUE);
                }
            });
        } else {
            tryRetrieveAndSendLocationUpdate(activeAdmin, androidFuture, strArr, i + 1);
        }
    }

    public final void uninstallCaCerts(final ComponentName componentName, String str, final String[] strArr) {
        if (this.mHasFeature) {
            final CallerIdentity callerIdentity = getCallerIdentity(componentName, str);
            Preconditions.checkCallAuthorization(canManageCaCerts(callerIdentity));
            checkCanExecuteOrThrowUnsafe(40);
            final Bundle bundle = new Bundle();
            bundle.putInt("userId", UserHandle.getUserId(callerIdentity.mUid));
            Injector injector = this.mInjector;
            FunctionalUtils.ThrowingRunnable throwingRunnable = new FunctionalUtils.ThrowingRunnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda116
                public final void runOrThrow() {
                    DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                    CallerIdentity callerIdentity2 = callerIdentity;
                    String[] strArr2 = strArr;
                    ComponentName componentName2 = componentName;
                    Bundle bundle2 = bundle;
                    CertificateMonitor certificateMonitor = devicePolicyManagerService.mCertificateMonitor;
                    UserHandle userHandleForUid = UserHandle.getUserHandleForUid(callerIdentity2.mUid);
                    certificateMonitor.getClass();
                    try {
                        KeyChain.KeyChainConnection bindAsUser = KeyChain.bindAsUser(certificateMonitor.mInjector.mContext, userHandleForUid);
                        for (String str2 : strArr2) {
                            try {
                                bindAsUser.getService().deleteCaCertificate(str2);
                            } catch (Throwable th) {
                                if (bindAsUser != null) {
                                    try {
                                        bindAsUser.close();
                                    } catch (Throwable th2) {
                                        th.addSuppressed(th2);
                                    }
                                }
                                throw th;
                            }
                        }
                        if (bindAsUser != null) {
                            bindAsUser.close();
                        }
                    } catch (RemoteException e) {
                        Slogf.e("DevicePolicyManager", "from CaCertUninstaller: ", e);
                    } catch (InterruptedException e2) {
                        Slogf.w("DevicePolicyManager", "CaCertUninstaller: ", e2);
                        Thread.currentThread().interrupt();
                    }
                    DevicePolicyEventLogger.createEvent(24).setAdmin(callerIdentity2.mPackageName).setBoolean(componentName2 == null).setKnoxBundleValue(bundle2).write();
                }
            };
            injector.getClass();
            Binder.withCleanCallingIdentity(throwingRunnable);
            synchronized (getLockObject()) {
                if (((ArraySet) getUserData(UserHandle.getUserId(callerIdentity.mUid)).mOwnerInstalledCaCerts).removeAll(Arrays.asList(strArr))) {
                    saveSettingsLocked(UserHandle.getUserId(callerIdentity.mUid), false, false, false);
                }
            }
            this.mInjector.getClass();
            this.mKnoxAnalyticsHelper.getClass();
            KnoxAnalyticsHelper.setKnoxAnalyticsData("uninstallCaCerts", str);
        }
    }

    public final void uninstallPackageWithActiveAdmins(final String str) {
        Preconditions.checkArgument(!TextUtils.isEmpty(str));
        ComponentName componentName = null;
        CallerIdentity callerIdentity = getCallerIdentity(null, null);
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission("android.permission.MANAGE_DEVICE_ADMINS"));
        final int userId = UserHandle.getUserId(callerIdentity.mUid);
        enforceUserUnlocked(userId);
        ComponentName profileOwnerAsUser = getProfileOwnerAsUser(userId);
        if (profileOwnerAsUser != null && str.equals(profileOwnerAsUser.getPackageName())) {
            throw new IllegalArgumentException("Cannot uninstall a package with a profile owner");
        }
        ComponentName deviceOwnerComponent = getDeviceOwnerComponent(false);
        if (getDeviceOwnerUserId() == userId && deviceOwnerComponent != null && str.equals(deviceOwnerComponent.getPackageName())) {
            throw new IllegalArgumentException("Cannot uninstall a package with a device owner");
        }
        List activeAdmins = getActiveAdmins(userId);
        if (activeAdmins != null && str != null) {
            Iterator it = activeAdmins.iterator();
            while (true) {
                if (!it.hasNext()) {
                    break;
                }
                ComponentName componentName2 = (ComponentName) it.next();
                if (str.equals(componentName2.getPackageName())) {
                    componentName = componentName2;
                    break;
                }
            }
        }
        this.mInjector.getClass();
        if (!this.mKnoxPolicyHelper.isAdminRemovableInternal(componentName, userId)) {
            Log.d("DevicePolicyManager", "uninstallPackageWithActiveAdmins() has failed because this admin doesn't allow to remove - " + componentName + ", userId = " + userId);
            return;
        }
        UserPackage of = UserPackage.of(userId, str);
        synchronized (getLockObject()) {
            ((ArraySet) this.mPackagesToRemove).add(of);
        }
        List<ComponentName> activeAdmins2 = getActiveAdmins(userId);
        final ArrayList arrayList = new ArrayList();
        if (activeAdmins2 != null) {
            for (ComponentName componentName3 : activeAdmins2) {
                if (str.equals(componentName3.getPackageName())) {
                    arrayList.add(componentName3);
                    removeActiveAdmin(componentName3, userId);
                }
            }
        }
        if (arrayList.size() == 0) {
            startUninstallIntent(userId, str);
        } else {
            this.mHandler.postDelayed(new Runnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService.7
                @Override // java.lang.Runnable
                public final void run() {
                    Iterator it2 = arrayList.iterator();
                    while (it2.hasNext()) {
                        DevicePolicyManagerService.this.removeAdminArtifacts(userId, (ComponentName) it2.next());
                    }
                    DevicePolicyManagerService.this.startUninstallIntent(userId, str);
                }
            }, 10000L);
        }
    }

    public final void unregisterOnSubscriptionsChangedListener() {
        synchronized (this.mSubscriptionsChangedListenerLock) {
            try {
                if (this.mSubscriptionsChangedListener != null) {
                    ((SubscriptionManager) this.mContext.getSystemService(SubscriptionManager.class)).removeOnSubscriptionsChangedListener(this.mSubscriptionsChangedListener);
                    this.mSubscriptionsChangedListener = null;
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void unsuspendWorkAppsIfNecessary() {
        Object emptySet;
        synchronized (getLockObject()) {
            try {
                DevicePolicyData userDataUnchecked = getUserDataUnchecked(0);
                if (userDataUnchecked.mEffectiveKeepProfilesRunning) {
                    userDataUnchecked.mEffectiveKeepProfilesRunning = false;
                    saveSettingsLocked(0, false, false, false);
                    Slog.w("DevicePolicyManager", "Work apps may have been paused via suspension previously.");
                    this.mInjector.getClass();
                    PackageManagerInternal packageManagerInternal = Injector.getPackageManagerInternal();
                    Iterator it = ((ArrayList) this.mUserManagerInternal.getUsers(true)).iterator();
                    while (it.hasNext()) {
                        UserInfo userInfo = (UserInfo) it.next();
                        if (userInfo.isManagedProfile() && userInfo.isQuietModeEnabled()) {
                            int i = userInfo.id;
                            synchronized (getLockObject()) {
                                try {
                                    ActiveAdmin deviceOrProfileOwnerAdminLocked = getDeviceOrProfileOwnerAdminLocked(i);
                                    if (deviceOrProfileOwnerAdminLocked != null && deviceOrProfileOwnerAdminLocked.suspendedPackages != null) {
                                        emptySet = new ArraySet(deviceOrProfileOwnerAdminLocked.suspendedPackages);
                                    }
                                    emptySet = Collections.emptySet();
                                } finally {
                                }
                            }
                            String[] strArr = (String[]) this.mInjector.getPackageManager(i).getInstalledPackages(PackageManager.PackageInfoFlags.of(786432L)).stream().map(new DevicePolicyManagerService$$ExternalSyntheticLambda15(2)).filter(new DevicePolicyManagerService$$ExternalSyntheticLambda118(0, emptySet)).toArray(new DevicePolicyManagerService$$ExternalSyntheticLambda119(0));
                            Slogf.i("DevicePolicyManager", "Unsuspending work apps for user %d", Integer.valueOf(i));
                            packageManagerInternal.setPackagesSuspendedByAdmin(i, false, strArr);
                        }
                    }
                }
            } finally {
            }
        }
    }

    public final void updateAdminCanGrantSensorsPermissionCache(int i) {
        synchronized (getLockObject()) {
            try {
                ActiveAdmin deviceOwnerAdminLocked = isUserAffiliatedWithDeviceLocked(i) ? getDeviceOwnerAdminLocked() : getDeviceOrProfileOwnerAdminLocked(i);
                boolean z = deviceOwnerAdminLocked != null ? deviceOwnerAdminLocked.mAdminCanGrantSensorsPermissions : false;
                this.mInjector.getClass();
                if (!SemPersonaManager.isAppSeparationUserId(i)) {
                    this.mPolicyCache.mCanGrantSensorsPermissions = z;
                }
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public final void updateDialerAndSmsManagedShortcutsOverrideCache() {
        ArrayMap arrayMap = new ArrayMap();
        UserHandle mainUser = this.mUserManager.getMainUser();
        int managedUserId = mainUser == null ? -10000 : getManagedUserId(mainUser.getIdentifier());
        List roleHoldersAsUser = this.mRoleManager.getRoleHoldersAsUser("android.app.role.DIALER", UserHandle.of(managedUserId));
        List roleHoldersAsUser2 = this.mRoleManager.getRoleHoldersAsUser("android.app.role.SMS", UserHandle.of(managedUserId));
        String systemDialerPackage = ((TelecomManager) this.mContext.getSystemService(TelecomManager.class)).getSystemDialerPackage();
        String string = this.mContext.getString(R.string.config_defaultSms);
        if (systemDialerPackage != null) {
            arrayMap.put(systemDialerPackage, roleHoldersAsUser.isEmpty() ? systemDialerPackage : (String) roleHoldersAsUser.get(0));
        }
        if (string != null) {
            arrayMap.put(string, roleHoldersAsUser2.isEmpty() ? string : (String) roleHoldersAsUser2.get(0));
        }
        DevicePolicyCacheImpl devicePolicyCacheImpl = this.mPolicyCache;
        synchronized (devicePolicyCacheImpl.mLock) {
            devicePolicyCacheImpl.mLauncherShortcutOverrides = new ArrayMap(arrayMap);
        }
    }

    public final void updateMaximumTimeToLockLocked(int i) {
        if (isManagedProfile(i)) {
            long maximumTimeToLockPolicyFromAdmins = isSeparateProfileChallengeEnabled(i) ? getMaximumTimeToLockPolicyFromAdmins(getActiveAdminsForLockscreenPoliciesLocked(i)) : Long.MAX_VALUE;
            DevicePolicyData userDataUnchecked = getUserDataUnchecked(i);
            if (userDataUnchecked.mLastMaximumTimeToLock != maximumTimeToLockPolicyFromAdmins) {
                userDataUnchecked.mLastMaximumTimeToLock = maximumTimeToLockPolicyFromAdmins;
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda28 devicePolicyManagerService$$ExternalSyntheticLambda28 = new DevicePolicyManagerService$$ExternalSyntheticLambda28(this, i, userDataUnchecked);
                injector.getClass();
                Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda28);
            }
        }
        Injector injector2 = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda29 devicePolicyManagerService$$ExternalSyntheticLambda29 = new DevicePolicyManagerService$$ExternalSyntheticLambda29(i, 0, this);
        injector2.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda29);
    }

    public final void updateNetworkPreferenceForUser(int i, List list) {
        boolean z;
        if (!isManagedProfile(i)) {
            synchronized (getLockObject()) {
                try {
                    z = this.mOwners.getDeviceOwnerComponent() != null && this.mOwners.getDeviceOwnerUserId() == i;
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (!z) {
                return;
            }
        }
        ArrayList arrayList = new ArrayList();
        Iterator it = list.iterator();
        while (it.hasNext()) {
            PreferentialNetworkServiceConfig preferentialNetworkServiceConfig = (PreferentialNetworkServiceConfig) it.next();
            ProfileNetworkPreference.Builder builder = new ProfileNetworkPreference.Builder();
            if (preferentialNetworkServiceConfig.isEnabled()) {
                if (preferentialNetworkServiceConfig.isFallbackToDefaultConnectionAllowed()) {
                    builder.setPreference(1);
                } else if (preferentialNetworkServiceConfig.shouldBlockNonMatchingNetworks()) {
                    builder.setPreference(3);
                } else {
                    builder.setPreference(2);
                }
                builder.setIncludedUids(preferentialNetworkServiceConfig.getIncludedUids());
                builder.setExcludedUids(preferentialNetworkServiceConfig.getExcludedUids());
                builder.setPreferenceEnterpriseId(preferentialNetworkServiceConfig.getNetworkId());
            } else {
                builder.setPreference(0);
            }
            arrayList.add(builder.build());
        }
        Slogf.d("DevicePolicyManager", "updateNetworkPreferenceForUser to " + arrayList);
        Injector injector = this.mInjector;
        DevicePolicyManagerService$$ExternalSyntheticLambda101 devicePolicyManagerService$$ExternalSyntheticLambda101 = new DevicePolicyManagerService$$ExternalSyntheticLambda101(this, i, arrayList, 0);
        injector.getClass();
        Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda101);
    }

    public final boolean updateOverrideApn(ComponentName componentName, int i, ApnSetting apnSetting) {
        if (this.mHasFeature && (this.mHasTelephonyFeature || this.mHasTelephonyDataFeature)) {
            Objects.requireNonNull(componentName, "ComponentName is null");
            Objects.requireNonNull(apnSetting, "ApnSetting is null in updateOverrideApn");
            CallerIdentity callerIdentity = getCallerIdentity(componentName);
            ApnSetting apnSetting2 = getApnSetting(i);
            if (apnSetting2 != null && apnSetting2.getApnTypeBitmask() == 16384 && apnSetting.getApnTypeBitmask() == 16384) {
                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity) || isManagedProfileOwner(callerIdentity));
            } else {
                Preconditions.checkCallAuthorization(isDefaultDeviceOwner(callerIdentity));
            }
            if (i < 0) {
                return false;
            }
            TelephonyManager telephonyManager = (TelephonyManager) this.mContext.getSystemService(TelephonyManager.class);
            if (telephonyManager != null) {
                Injector injector = this.mInjector;
                DevicePolicyManagerService$$ExternalSyntheticLambda177 devicePolicyManagerService$$ExternalSyntheticLambda177 = new DevicePolicyManagerService$$ExternalSyntheticLambda177(this, telephonyManager, i, apnSetting);
                injector.getClass();
                return ((Boolean) Binder.withCleanCallingIdentity(devicePolicyManagerService$$ExternalSyntheticLambda177)).booleanValue();
            }
            Slogf.w("DevicePolicyManager", "TelephonyManager is null when trying to modify override apn");
        }
        return false;
    }

    public final Set updatePasswordExpirationsLocked(int i) {
        ArraySet arraySet = new ArraySet();
        List activeAdminsForLockscreenPoliciesLocked = getActiveAdminsForLockscreenPoliciesLocked(i);
        int i2 = 0;
        while (true) {
            ArrayList arrayList = (ArrayList) activeAdminsForLockscreenPoliciesLocked;
            if (i2 >= arrayList.size()) {
                return arraySet;
            }
            ActiveAdmin activeAdmin = (ActiveAdmin) arrayList.get(i2);
            if (activeAdmin.isPermissionBased || activeAdmin.info.usesPolicy(6)) {
                arraySet.add(Integer.valueOf(activeAdmin.getUserHandle().getIdentifier()));
                long j = activeAdmin.passwordExpirationTimeout;
                activeAdmin.passwordExpirationDate = j > 0 ? System.currentTimeMillis() + j : 0L;
            }
            i2++;
        }
    }

    public final void updatePasswordQualityCacheForUserGroup(int i) {
        Iterator it = (i == -1 ? this.mUserManager.getUsers() : this.mUserManager.getProfiles(i)).iterator();
        while (it.hasNext()) {
            int i2 = ((UserInfo) it.next()).id;
            DevicePolicyCacheImpl devicePolicyCacheImpl = this.mPolicyCache;
            int passwordQuality = getPasswordQuality(null, i2, false);
            synchronized (devicePolicyCacheImpl.mLock) {
                devicePolicyCacheImpl.mPasswordQuality.put(i2, passwordQuality);
            }
        }
    }

    public final Set updatePasswordValidityCheckpointLocked(int i, boolean z) {
        boolean isPasswordSufficientForUserWithoutCheckpointLocked;
        ArraySet arraySet = new ArraySet();
        int credentialOwner = getCredentialOwner(i, z);
        DevicePolicyData userData = getUserData(credentialOwner);
        PasswordMetrics userPasswordMetrics = this.mLockSettingsInternal.getUserPasswordMetrics(credentialOwner);
        if (userPasswordMetrics != null && (isPasswordSufficientForUserWithoutCheckpointLocked = isPasswordSufficientForUserWithoutCheckpointLocked(userPasswordMetrics, getProfileParentUserIfRequested(i, z))) != userData.mPasswordValidAtLastCheckpoint) {
            userData.mPasswordValidAtLastCheckpoint = isPasswordSufficientForUserWithoutCheckpointLocked;
            arraySet.add(Integer.valueOf(credentialOwner));
        }
        return arraySet;
    }

    /* JADX WARN: Removed duplicated region for block: B:14:0x0035  */
    /* JADX WARN: Removed duplicated region for block: B:19:0x0037  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final boolean updatePersonalAppsSuspension(int r13) {
        /*
            r12 = this;
            java.lang.Object r0 = r12.getLockObject()
            monitor-enter(r0)
            com.android.server.devicepolicy.ActiveAdmin r1 = r12.getProfileOwnerAdminLocked(r13)     // Catch: java.lang.Throwable -> L24
            r2 = 0
            if (r1 == 0) goto L57
            com.android.server.pm.UserManagerInternal r3 = r12.mUserManagerInternal     // Catch: java.lang.Throwable -> L24
            boolean r3 = r3.isUserUnlockingOrUnlocked(r13)     // Catch: java.lang.Throwable -> L24
            r4 = 1
            if (r3 == 0) goto L26
            android.os.UserManager r3 = r12.mUserManager     // Catch: java.lang.Throwable -> L24
            android.os.UserHandle r5 = android.os.UserHandle.of(r13)     // Catch: java.lang.Throwable -> L24
            boolean r3 = r3.isQuietModeEnabled(r5)     // Catch: java.lang.Throwable -> L24
            if (r3 == 0) goto L22
            goto L26
        L22:
            r3 = r2
            goto L27
        L24:
            r12 = move-exception
            goto L60
        L26:
            r3 = r4
        L27:
            int r3 = r12.updateProfileOffDeadlineLocked(r13, r1, r3)     // Catch: java.lang.Throwable -> L24
            boolean r5 = r1.mSuspendPersonalApps     // Catch: java.lang.Throwable -> L24
            long r6 = r1.mProfileOffDeadline     // Catch: java.lang.Throwable -> L24
            r8 = -1
            int r6 = (r6 > r8 ? 1 : (r6 == r8 ? 0 : -1))
            if (r6 != 0) goto L37
            r6 = r4
            goto L38
        L37:
            r6 = r2
        L38:
            java.lang.String r7 = "DevicePolicyManager"
            java.lang.String r8 = "Personal apps suspended explicitly: %b, by timeout: %b, notification: %d"
            java.lang.Boolean r9 = java.lang.Boolean.valueOf(r5)     // Catch: java.lang.Throwable -> L24
            java.lang.Boolean r10 = java.lang.Boolean.valueOf(r6)     // Catch: java.lang.Throwable -> L24
            java.lang.Integer r11 = java.lang.Integer.valueOf(r3)     // Catch: java.lang.Throwable -> L24
            java.lang.Object[] r9 = new java.lang.Object[]{r9, r10, r11}     // Catch: java.lang.Throwable -> L24
            com.android.server.utils.Slogf.d(r7, r8, r9)     // Catch: java.lang.Throwable -> L24
            r12.updateProfileOffDeadlineNotificationLocked(r1, r13, r3)     // Catch: java.lang.Throwable -> L24
            if (r5 != 0) goto L56
            if (r6 == 0) goto L57
        L56:
            r2 = r4
        L57:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L24
            int r0 = r12.getProfileParentId(r13)
            r12.suspendPersonalAppsInternal(r0, r13, r2)
            return r2
        L60:
            monitor-exit(r0)     // Catch: java.lang.Throwable -> L24
            throw r12
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.updatePersonalAppsSuspension(int):boolean");
    }

    /* JADX WARN: Removed duplicated region for block: B:19:0x006d  */
    /* JADX WARN: Removed duplicated region for block: B:26:0x00b1  */
    /* JADX WARN: Removed duplicated region for block: B:28:0x00ba  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final int updateProfileOffDeadlineLocked(int r10, com.android.server.devicepolicy.ActiveAdmin r11, boolean r12) {
        /*
            r9 = this;
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r0 = r9.mInjector
            r0.getClass()
            long r0 = java.lang.System.currentTimeMillis()
            long r2 = r11.mProfileOffDeadline
            r4 = 0
            int r6 = (r2 > r4 ? 1 : (r2 == r4 ? 0 : -1))
            r7 = 0
            java.lang.String r8 = "DevicePolicyManager"
            if (r6 == 0) goto L3a
            int r2 = (r0 > r2 ? 1 : (r0 == r2 ? 0 : -1))
            if (r2 <= 0) goto L3a
            java.lang.StringBuilder r0 = new java.lang.StringBuilder
            java.lang.String r1 = "Profile off deadline has been reached, off: "
            r0.<init>(r1)
            r0.append(r12)
            java.lang.String r0 = r0.toString()
            com.android.server.utils.Slogf.i(r8, r0)
            long r0 = r11.mProfileOffDeadline
            r2 = -1
            int r0 = (r0 > r2 ? 1 : (r0 == r2 ? 0 : -1))
            if (r0 == 0) goto L36
            r11.mProfileOffDeadline = r2
            r9.saveSettingsLocked(r10, r7, r7, r7)
        L36:
            if (r12 == 0) goto L39
            r7 = 2
        L39:
            return r7
        L3a:
            boolean r2 = r11.mSuspendPersonalApps
            if (r2 == 0) goto L43
            if (r6 == 0) goto L6a
            r11.mProfileOffDeadline = r4
            goto L67
        L43:
            if (r6 == 0) goto L53
            long r2 = r11.mProfileMaximumTimeOffMillis
            int r2 = (r2 > r4 ? 1 : (r2 == r4 ? 0 : -1))
            if (r2 != 0) goto L53
            java.lang.String r2 = "Profile off deadline is reset to zero"
            com.android.server.utils.Slogf.i(r8, r2)
            r11.mProfileOffDeadline = r4
            goto L67
        L53:
            if (r6 != 0) goto L6a
            long r2 = r11.mProfileMaximumTimeOffMillis
            int r2 = (r2 > r4 ? 1 : (r2 == r4 ? 0 : -1))
            if (r2 == 0) goto L6a
            if (r12 == 0) goto L6a
            java.lang.String r2 = "Profile off deadline is set."
            com.android.server.utils.Slogf.i(r8, r2)
            long r2 = r11.mProfileMaximumTimeOffMillis
            long r2 = r2 + r0
            r11.mProfileOffDeadline = r2
        L67:
            r9.saveSettingsLocked(r10, r7, r7, r7)
        L6a:
            r10 = 1
            if (r12 == 0) goto L80
            long r11 = r11.mProfileOffDeadline
            int r2 = (r11 > r4 ? 1 : (r11 == r4 ? 0 : -1))
            if (r2 != 0) goto L74
            goto L80
        L74:
            long r0 = r11 - r0
            long r2 = com.android.server.devicepolicy.DevicePolicyManagerService.MANAGED_PROFILE_OFF_WARNING_PERIOD
            int r0 = (r0 > r2 ? 1 : (r0 == r2 ? 0 : -1))
            if (r0 >= 0) goto L7e
            r7 = r10
            goto L81
        L7e:
            long r11 = r11 - r2
            goto L81
        L80:
            r11 = r4
        L81:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r0 = r9.mInjector
            android.content.Context r0 = r0.mContext
            java.lang.Class<android.app.AlarmManager> r1 = android.app.AlarmManager.class
            java.lang.Object r0 = r0.getSystemService(r1)
            android.app.AlarmManager r0 = (android.app.AlarmManager) r0
            android.content.Intent r1 = new android.content.Intent
            java.lang.String r2 = "com.android.server.ACTION_PROFILE_OFF_DEADLINE"
            r1.<init>(r2)
            android.content.Context r2 = r9.mContext
            java.lang.String r2 = r2.getPackageName()
            r1.setPackage(r2)
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r2 = r9.mInjector
            android.content.Context r9 = r9.mContext
            r2.getClass()
            r2 = 5572(0x15c4, float:7.808E-42)
            r3 = 1275068416(0x4c000000, float:3.3554432E7)
            android.app.PendingIntent r9 = android.app.PendingIntent.getBroadcast(r9, r2, r1, r3)
            int r1 = (r11 > r4 ? 1 : (r11 == r4 ? 0 : -1))
            if (r1 != 0) goto Lba
            java.lang.String r10 = "Profile off deadline alarm is removed."
            com.android.server.utils.Slogf.i(r8, r10)
            r0.cancel(r9)
            goto Lc2
        Lba:
            java.lang.String r1 = "Profile off deadline alarm is set."
            com.android.server.utils.Slogf.i(r8, r1)
            r0.set(r10, r11, r9)
        Lc2:
            return r7
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.updateProfileOffDeadlineLocked(int, com.android.server.devicepolicy.ActiveAdmin, boolean):int");
    }

    public final void updateProfileOffDeadlineNotificationLocked(ActiveAdmin activeAdmin, final int i, int i2) {
        String updatableString;
        if (i2 == 0) {
            this.mInjector.getNotificationManager().cancel(1003);
            return;
        }
        Intent intent = new Intent(ACTION_TURN_PROFILE_ON_NOTIFICATION);
        intent.setPackage(this.mContext.getPackageName());
        intent.putExtra("android.intent.extra.user_handle", i);
        Injector injector = this.mInjector;
        Context context = this.mContext;
        injector.getClass();
        Notification.Action build = new Notification.Action.Builder((Icon) null, getUpdatableString("Core.PERSONAL_APP_SUSPENSION_TURN_ON_PROFILE", 17042377, new Object[0]), PendingIntent.getBroadcast(context, 0, intent, 201326592)).build();
        boolean z = true;
        if (i2 == 1) {
            long j = activeAdmin.mProfileMaximumTimeOffMillis;
            long j2 = MS_PER_DAY;
            updatableString = getUpdatableString("Core.PERSONAL_APP_SUSPENSION_SOON_MESSAGE", 17042378, DateUtils.formatDateTime(this.mContext, activeAdmin.mProfileOffDeadline, 16), DateUtils.formatDateTime(this.mContext, activeAdmin.mProfileOffDeadline, 1), Integer.valueOf((int) (((j2 / 2) + j) / j2)));
            z = false;
        } else {
            updatableString = getUpdatableString("Core.PERSONAL_APP_SUSPENSION_MESSAGE", 17042379, new Object[0]);
        }
        int color = this.mContext.getColor(R.color.secondary_device_default_settings_light);
        Bundle bundle = new Bundle();
        bundle.putString("android.substName", getUpdatableString("Core.NOTIFICATION_WORK_PROFILE_CONTENT_DESCRIPTION", R.string.silent_mode_vibrate, new Object[0]));
        final Notification build2 = new Notification.Builder(this.mContext, SystemNotificationChannels.DEVICE_ADMIN).setSmallIcon(R.drawable.ic_eject_24dp).setOngoing(z).setAutoCancel(false).setContentTitle(getUpdatableString("Core.PERSONAL_APP_SUSPENSION_TITLE", 17042380, new Object[0])).setContentText(updatableString).setStyle(new Notification.BigTextStyle().bigText(updatableString)).setColor(color).addAction(build).addExtras(bundle).build();
        this.mHandler.post(new Runnable() { // from class: com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda211
            @Override // java.lang.Runnable
            public final void run() {
                DevicePolicyManagerService devicePolicyManagerService = DevicePolicyManagerService.this;
                devicePolicyManagerService.mInjector.getNotificationManager().notifyAsUser(null, 1003, build2, UserHandle.of(devicePolicyManagerService.getProfileParentId(i)));
            }
        });
    }

    public final void updateSystemUpdateFreezePeriodsRecord(boolean z) {
        boolean systemUpdateFreezePeriodRecord;
        Slogf.d("DevicePolicyManager", "updateSystemUpdateFreezePeriodsRecord");
        synchronized (getLockObject()) {
            try {
                SystemUpdatePolicy systemUpdatePolicy = this.mOwners.getSystemUpdatePolicy();
                if (systemUpdatePolicy == null) {
                    return;
                }
                LocalDate now = LocalDate.now();
                Pair currentFreezePeriod = systemUpdatePolicy.getCurrentFreezePeriod(now);
                if (currentFreezePeriod == null) {
                    return;
                }
                Pair systemUpdateFreezePeriodRecord2 = this.mOwners.getSystemUpdateFreezePeriodRecord();
                LocalDate localDate = (LocalDate) systemUpdateFreezePeriodRecord2.first;
                LocalDate localDate2 = (LocalDate) systemUpdateFreezePeriodRecord2.second;
                if (localDate2 != null && localDate != null) {
                    systemUpdateFreezePeriodRecord = now.equals(localDate2.plusDays(1L)) ? this.mOwners.setSystemUpdateFreezePeriodRecord(localDate, now) : now.isAfter(localDate2.plusDays(1L)) ? (localDate.isBefore((ChronoLocalDate) currentFreezePeriod.first) || localDate.isAfter((ChronoLocalDate) currentFreezePeriod.second) || localDate2.isBefore((ChronoLocalDate) currentFreezePeriod.first) || localDate2.isAfter((ChronoLocalDate) currentFreezePeriod.second)) ? this.mOwners.setSystemUpdateFreezePeriodRecord(now, now) : this.mOwners.setSystemUpdateFreezePeriodRecord(localDate, now) : now.isBefore(localDate) ? this.mOwners.setSystemUpdateFreezePeriodRecord(now, now) : false;
                    if (systemUpdateFreezePeriodRecord && z) {
                        this.mOwners.writeDeviceOwner();
                    }
                }
                systemUpdateFreezePeriodRecord = this.mOwners.setSystemUpdateFreezePeriodRecord(now, now);
                if (systemUpdateFreezePeriodRecord) {
                    this.mOwners.writeDeviceOwner();
                }
            } finally {
            }
        }
    }

    public final void updateTelephonyCrossProfileIntentFilters(int i, int i2, boolean z) {
        try {
            if (!z && i2 == -10000) {
                this.mIPackageManager.clearCrossProfileIntentFilters(i, this.mContext.getPackageName());
                return;
            }
            for (DefaultCrossProfileIntentFilter defaultCrossProfileIntentFilter : DefaultCrossProfileIntentFiltersUtils.getDefaultCrossProfileTelephonyIntentFilters(!z)) {
                int i3 = defaultCrossProfileIntentFilter.direction;
                WatchedIntentFilter watchedIntentFilter = defaultCrossProfileIntentFilter.filter;
                if (i3 == 1 ? this.mIPackageManager.removeCrossProfileIntentFilter(watchedIntentFilter.getIntentFilter$3(), this.mContext.getOpPackageName(), i, i2, defaultCrossProfileIntentFilter.flags) : this.mIPackageManager.removeCrossProfileIntentFilter(watchedIntentFilter.getIntentFilter$3(), this.mContext.getOpPackageName(), i2, i, defaultCrossProfileIntentFilter.flags)) {
                    Slogf.w("DevicePolicyManager", "Failed to remove cross-profile intent filter: " + watchedIntentFilter.getIntentFilter$3() + ", enableWorkTelephony: " + z);
                }
            }
            for (DefaultCrossProfileIntentFilter defaultCrossProfileIntentFilter2 : DefaultCrossProfileIntentFiltersUtils.getDefaultCrossProfileTelephonyIntentFilters(z)) {
                int i4 = defaultCrossProfileIntentFilter2.direction;
                WatchedIntentFilter watchedIntentFilter2 = defaultCrossProfileIntentFilter2.filter;
                if (i4 == 1) {
                    this.mIPackageManager.addCrossProfileIntentFilter(watchedIntentFilter2.getIntentFilter$3(), this.mContext.getOpPackageName(), i, i2, defaultCrossProfileIntentFilter2.flags);
                } else {
                    this.mIPackageManager.addCrossProfileIntentFilter(watchedIntentFilter2.getIntentFilter$3(), this.mContext.getOpPackageName(), i2, i, defaultCrossProfileIntentFilter2.flags);
                }
            }
        } catch (RemoteException e) {
            Slogf.wtf("DevicePolicyManager", "Error updating telephony cross profile intent filters", e);
        }
    }

    public final void updateUserSetupCompleteAndPaired() {
        List aliveUsers = this.mUserManager.getAliveUsers();
        int size = aliveUsers.size();
        for (int i = 0; i < size; i++) {
            int i2 = ((UserInfo) aliveUsers.get(i)).id;
            if (Settings.Secure.getIntForUser(this.mInjector.mContext.getContentResolver(), "user_setup_complete", 0, i2) != 0) {
                DevicePolicyData userData = getUserData(i2);
                if (!userData.mUserSetupComplete) {
                    userData.mUserSetupComplete = true;
                    if (i2 == 0) {
                        DeviceStateCacheImpl deviceStateCacheImpl = this.mStateCache;
                        synchronized (deviceStateCacheImpl.mLock) {
                            deviceStateCacheImpl.mIsDeviceProvisioned = true;
                        }
                    }
                    synchronized (getLockObject()) {
                        saveSettingsLocked(i2, false, false, false);
                    }
                }
            }
            if (this.mIsWatch && Settings.Secure.getIntForUser(this.mInjector.mContext.getContentResolver(), "device_paired", 0, i2) != 0) {
                DevicePolicyData userData2 = getUserData(i2);
                if (userData2.mPaired) {
                    continue;
                } else {
                    userData2.mPaired = true;
                    synchronized (getLockObject()) {
                        saveSettingsLocked(i2, false, false, false);
                    }
                }
            }
        }
    }

    /* JADX WARN: Code restructure failed: missing block: B:21:0x008d, code lost:
    
        if (com.android.server.devicepolicy.DevicePolicyManagerService.Injector.userHandleGetCallingUserId() == r14) goto L34;
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void wipeDataNoLock(android.content.ComponentName r9, final int r10, final java.lang.String r11, final java.lang.String r12, final int r13, boolean r14, java.lang.Boolean r15) {
        /*
            r8 = this;
            r8.wtfIfInLock()
            r0 = 1
            r1 = 0
            if (r9 == 0) goto Lc
            java.lang.String r2 = r9.getPackageName()
            goto L36
        Lc:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r2 = r8.mInjector
            r2.getClass()
            int r2 = android.os.Binder.getCallingUid()
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r3 = r8.mInjector
            android.content.Context r3 = r3.mContext
            android.content.pm.PackageManager r3 = r3.getPackageManager()
            java.lang.String[] r3 = r3.getPackagesForUid(r2)
            int r4 = r3.length
            if (r4 <= 0) goto L26
            r4 = r0
            goto L27
        L26:
            r4 = r1
        L27:
            java.lang.Integer r2 = java.lang.Integer.valueOf(r2)
            java.lang.Object[] r2 = new java.lang.Object[]{r2}
            java.lang.String r5 = "Caller %s does not have any associated packages"
            com.android.internal.util.Preconditions.checkState(r4, r5, r2)
            r2 = r3[r1]
        L36:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r3 = r8.mInjector
            com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda30 r4 = new com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda30
            r5 = 0
            r4.<init>(r8, r13, r9, r5)
            r3.getClass()
            android.os.Binder.withCleanCallingIdentity(r4)
            if (r13 != 0) goto L48
            r9 = r0
            goto L49
        L48:
            r9 = r1
        L49:
            int r3 = r8.getMainUserId()
            if (r13 != r3) goto L51
            r3 = r0
            goto L52
        L51:
            r3 = r1
        L52:
            if (r15 == 0) goto La9
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r4 = r8.mInjector
            r4.getClass()
            r4 = 242193913(0xe6f95f9, double:1.19659692E-315)
            boolean r4 = com.android.server.devicepolicy.DevicePolicyManagerService.Injector.isChangeEnabled(r13, r2, r4)
            if (r4 != 0) goto L63
            goto La9
        L63:
            boolean r3 = r15.booleanValue()
            if (r3 == 0) goto L99
            java.lang.String r9 = "android.permission.MANAGE_DEVICE_POLICY_WIPE_DATA"
            java.lang.String r1 = "android.permission.MASTER_CLEAR"
            java.lang.String[] r9 = new java.lang.String[]{r9, r1}
            boolean r15 = r15.booleanValue()
            if (r15 == 0) goto L79
            r14 = -1
            goto L7d
        L79:
            int r14 = r8.getAffectedUser(r14)
        L7d:
            r15 = 4
            boolean r15 = r8.hasAdminPolicy(r15, r2)
            if (r15 == 0) goto L90
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r15 = r8.mInjector
            r15.getClass()
            int r15 = com.android.server.devicepolicy.DevicePolicyManagerService.Injector.userHandleGetCallingUserId()
            if (r15 != r14) goto L90
            goto L93
        L90:
            r8.enforcePermissions(r2, r14, r9)
        L93:
            r9 = 0
            r8.getEnforcingAdminForCaller(r9, r2)
        L97:
            r3 = r0
            goto Lba
        L99:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r14 = r8.mInjector
            com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda31 r15 = new com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda31
            r0 = 0
            r15.<init>(r8, r9, r13, r0)
            r14.getClass()
            android.os.Binder.withCleanCallingIdentity(r15)
            r3 = r1
            goto Lba
        La9:
            boolean r14 = android.app.admin.flags.Flags.headlessSingleUserFixes()
            if (r14 == 0) goto Lb8
            int r14 = r8.getHeadlessDeviceOwnerModeForDeviceOwner()
            r15 = 2
            if (r14 != r15) goto Lb8
            r0 = r3
            goto L97
        Lb8:
            r0 = r9
            goto L97
        Lba:
            com.android.server.devicepolicy.DevicePolicyManagerService$Injector r9 = r8.mInjector
            com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda32 r14 = new com.android.server.devicepolicy.DevicePolicyManagerService$$ExternalSyntheticLambda32
            r1 = r14
            r2 = r8
            r4 = r10
            r5 = r11
            r6 = r13
            r7 = r12
            r1.<init>()
            r9.getClass()
            android.os.Binder.withCleanCallingIdentity(r14)
            return
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.wipeDataNoLock(android.content.ComponentName, int, java.lang.String, java.lang.String, int, boolean, java.lang.Boolean):void");
    }

    /* JADX WARN: Code restructure failed: missing block: B:13:0x0041, code lost:
    
        if (com.android.server.devicepolicy.DevicePolicyManagerService.Injector.userHandleGetCallingUserId() == r5) goto L17;
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct code enable 'Show inconsistent code' option in preferences
    */
    public final void wipeDataWithReason(java.lang.String r16, int r17, java.lang.String r18, boolean r19, boolean r20) {
        /*
            Method dump skipped, instructions count: 319
            To view this dump change 'Code comments level' option to 'DEBUG'
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.devicepolicy.DevicePolicyManagerService.wipeDataWithReason(java.lang.String, int, java.lang.String, boolean, boolean):void");
    }

    public final Object withAccessibilityManager(int i, Function function) {
        IBinder service = ServiceManager.getService("accessibility");
        AccessibilityManager accessibilityManager = new AccessibilityManager(this.mContext, service == null ? null : IAccessibilityManager.Stub.asInterface(service), i);
        try {
            return function.apply(accessibilityManager);
        } finally {
            accessibilityManager.removeClient();
        }
    }

    public final void wtfIfInLock() {
        if (Thread.holdsLock(this.mLockDoNoUseDirectly)) {
            Slogf.wtfStack("DevicePolicyManager", "Shouldn't be called with DPMS lock held");
        }
    }
}
